/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class VTKMapper!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEVTKMAPPERINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGNode.h> // Root Class
#include <OSGNode.h> // GeoRoots Class
#include <OSGGeometry.h> // Geometries Class
#include <OSGChunkMaterial.h> // Materials Class
#include <OSGMaterialChunk.h> // MaterialChunks Class
#include <OSGGeoPnt3fProperty.h> // Positions Class
#include <OSGGeoUInt32Property.h> // Length Class
#include <OSGGeoUInt8Property.h> // Types Class
#include <OSGGeoColor4fProperty.h> // Colors Class
#include <OSGGeoVec3fProperty.h> // Normals Class

#include "OSGVTKMapperBase.h"
#include "OSGVTKMapper.h"

#include "boost/bind.hpp"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::VTKMapper
    
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var NodePtr         VTKMapperBase::_sfRoot
    
*/

/*! \var NodePtr         VTKMapperBase::_mfGeoRoots
    
*/

/*! \var GeometryPtr     VTKMapperBase::_mfGeometries
    
*/

/*! \var ChunkMaterialPtr VTKMapperBase::_mfMaterials
    
*/

/*! \var MaterialChunkPtr VTKMapperBase::_mfMaterialChunks
    
*/

/*! \var GeoPnt3fPropertyPtr VTKMapperBase::_mfPositions
    
*/

/*! \var GeoUInt32PropertyPtr VTKMapperBase::_mfLength
    
*/

/*! \var GeoUInt8PropertyPtr VTKMapperBase::_mfTypes
    
*/

/*! \var GeoColor4fPropertyPtr VTKMapperBase::_mfColors
    
*/

/*! \var GeoVec3fPropertyPtr VTKMapperBase::_mfNormals
    
*/


void VTKMapperBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFNodePtr::Description(
        SFNodePtr::getClassType(),
        "root",
        "",
        RootFieldId, RootFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleRoot),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleRoot));

    oType.addInitialDesc(pDesc);

    pDesc = new MFNodePtr::Description(
        MFNodePtr::getClassType(),
        "geoRoots",
        "",
        GeoRootsFieldId, GeoRootsFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleGeoRoots),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleGeoRoots));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeometryPtr::Description(
        MFGeometryPtr::getClassType(),
        "geometries",
        "",
        GeometriesFieldId, GeometriesFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleGeometries),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleGeometries));

    oType.addInitialDesc(pDesc);

    pDesc = new MFChunkMaterialPtr::Description(
        MFChunkMaterialPtr::getClassType(),
        "materials",
        "",
        MaterialsFieldId, MaterialsFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleMaterials),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleMaterials));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMaterialChunkPtr::Description(
        MFMaterialChunkPtr::getClassType(),
        "materialChunks",
        "",
        MaterialChunksFieldId, MaterialChunksFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleMaterialChunks),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleMaterialChunks));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoPnt3fPropertyPtr::Description(
        MFGeoPnt3fPropertyPtr::getClassType(),
        "positions",
        "",
        PositionsFieldId, PositionsFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandlePositions),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandlePositions));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoUInt32PropertyPtr::Description(
        MFGeoUInt32PropertyPtr::getClassType(),
        "length",
        "",
        LengthFieldId, LengthFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleLength),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleLength));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoUInt8PropertyPtr::Description(
        MFGeoUInt8PropertyPtr::getClassType(),
        "types",
        "",
        TypesFieldId, TypesFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleTypes),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleTypes));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoColor4fPropertyPtr::Description(
        MFGeoColor4fPropertyPtr::getClassType(),
        "Colors",
        "",
        ColorsFieldId, ColorsFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleColors),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleColors));

    oType.addInitialDesc(pDesc);

    pDesc = new MFGeoVec3fPropertyPtr::Description(
        MFGeoVec3fPropertyPtr::getClassType(),
        "normals",
        "",
        NormalsFieldId, NormalsFieldMask,
        false,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&VTKMapperBase::editHandleNormals),
        static_cast<FieldGetMethodSig >(&VTKMapperBase::getHandleNormals));

    oType.addInitialDesc(pDesc);
}


VTKMapperBase::TypeObject VTKMapperBase::_type(
    VTKMapperBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &VTKMapperBase::createEmptyLocal,
    VTKMapper::initMethod,
    VTKMapper::exitMethod,
    (InitalInsertDescFunc) &VTKMapperBase::classDescInserter,
    false,
    0,
    "<?xml version=\"1.0\" ?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"VTKMapper\"\n"
    "\tparent=\"Group\"\n"
    "\tlibrary=\"ContribVTK\"\n"
    "\tstructure=\"concrete\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "        isNodeCore=\"true\"\n"
    ">\n"
    "\t<Field\n"
    "\t\tname=\"root\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"geoRoots\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"geometries\"\n"
    "\t\ttype=\"GeometryPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materials\"\n"
    "\t\ttype=\"ChunkMaterialPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"materialChunks\"\n"
    "\t\ttype=\"MaterialChunkPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"positions\"\n"
    "\t\ttype=\"GeoPnt3fPropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"length\"\n"
    "\t\ttype=\"GeoUInt32PropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"types\"\n"
    "\t\ttype=\"GeoUInt8PropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"Colors\"\n"
    "\t\ttype=\"GeoColor4fPropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"normals\"\n"
    "\t\ttype=\"GeoVec3fPropertyPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &VTKMapperBase::getType(void)
{
    return _type;
}

const FieldContainerType &VTKMapperBase::getType(void) const
{
    return _type;
}

UInt32 VTKMapperBase::getContainerSize(void) const
{
    return sizeof(VTKMapper);
}

/*------------------------- decorator get ------------------------------*/


//! Get the VTKMapper::_sfRoot field.
const SFNodePtr *VTKMapperBase::getSFRoot(void) const
{
    return &_sfRoot;
}

//! Get the VTKMapper::_mfGeoRoots field.
const MFNodePtr *VTKMapperBase::getMFGeoRoots(void) const
{
    return &_mfGeoRoots;
}

//! Get the VTKMapper::_mfGeometries field.
const MFGeometryPtr *VTKMapperBase::getMFGeometries(void) const
{
    return &_mfGeometries;
}

//! Get the VTKMapper::_mfMaterials field.
const MFChunkMaterialPtr *VTKMapperBase::getMFMaterials(void) const
{
    return &_mfMaterials;
}

//! Get the VTKMapper::_mfMaterialChunks field.
const MFMaterialChunkPtr *VTKMapperBase::getMFMaterialChunks(void) const
{
    return &_mfMaterialChunks;
}

//! Get the VTKMapper::_mfPositions field.
const MFGeoPnt3fPropertyPtr *VTKMapperBase::getMFPositions(void) const
{
    return &_mfPositions;
}

//! Get the VTKMapper::_mfLength field.
const MFGeoUInt32PropertyPtr *VTKMapperBase::getMFLength(void) const
{
    return &_mfLength;
}

//! Get the VTKMapper::_mfTypes field.
const MFGeoUInt8PropertyPtr *VTKMapperBase::getMFTypes(void) const
{
    return &_mfTypes;
}

//! Get the VTKMapper::_mfColors field.
const MFGeoColor4fPropertyPtr *VTKMapperBase::getMFColors(void) const
{
    return &_mfColors;
}

//! Get the VTKMapper::_mfNormals field.
const MFGeoVec3fPropertyPtr *VTKMapperBase::getMFNormals(void) const
{
    return &_mfNormals;
}



void VTKMapperBase::pushToGeoRoots(NodePtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(GeoRootsFieldMask, _mfGeoRoots);

    //addRef(value);

    _mfGeoRoots.push_back(value);
}

void VTKMapperBase::assignGeoRoots (const MFNodePtr         &value)
{
    MFNodePtr        ::const_iterator elemIt  =
        value.begin();
    MFNodePtr        ::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearGeoRoots();

    while(elemIt != elemEnd)
    {
        this->pushToGeoRoots(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoGeoRoots(UInt32                uiIndex,
                                                   NodePtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(GeoRootsFieldMask, _mfGeoRoots);

    MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfGeoRoots.insert(fieldIt, value);
}

void VTKMapperBase::replaceInGeoRoots(UInt32                uiIndex,
                                                       NodePtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfGeoRoots.size())
        return;

    editMField(GeoRootsFieldMask, _mfGeoRoots);


//    addRef(value);
//    subRef(_mfGeoRoots[uiIndex]);

//    _mfGeoRoots[uiIndex] = value;

      _mfGeoRoots.replace(uiIndex, value);
}

void VTKMapperBase::replaceInGeoRoots(NodePtrConstArg pOldElem,
                                                        NodePtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfGeoRoots.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(GeoRootsFieldMask, _mfGeoRoots);

//        MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfGeoRoots.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromGeoRoots(UInt32 uiIndex)
{
    if(uiIndex < _mfGeoRoots.size())
    {
        editMField(GeoRootsFieldMask, _mfGeoRoots);

        MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfGeoRoots.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromGeoRoots(NodePtrConstArg value)
{
    Int32 iElemIdx = _mfGeoRoots.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(GeoRootsFieldMask, _mfGeoRoots);

        MFNodePtr::iterator fieldIt = _mfGeoRoots.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfGeoRoots.erase(fieldIt);
    }
}
void VTKMapperBase::clearGeoRoots(void)
{
    editMField(GeoRootsFieldMask, _mfGeoRoots);

    MFNodePtr::iterator       fieldIt  = _mfGeoRoots.begin();
    MFNodePtr::const_iterator fieldEnd = _mfGeoRoots.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfGeoRoots.clear();
}

void VTKMapperBase::pushToGeometries(GeometryPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(GeometriesFieldMask, _mfGeometries);

    //addRef(value);

    _mfGeometries.push_back(value);
}

void VTKMapperBase::assignGeometries(const MFGeometryPtr     &value)
{
    MFGeometryPtr    ::const_iterator elemIt  =
        value.begin();
    MFGeometryPtr    ::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearGeometries();

    while(elemIt != elemEnd)
    {
        this->pushToGeometries(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoGeometries(UInt32                uiIndex,
                                                   GeometryPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(GeometriesFieldMask, _mfGeometries);

    MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfGeometries.insert(fieldIt, value);
}

void VTKMapperBase::replaceInGeometries(UInt32                uiIndex,
                                                       GeometryPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfGeometries.size())
        return;

    editMField(GeometriesFieldMask, _mfGeometries);


//    addRef(value);
//    subRef(_mfGeometries[uiIndex]);

//    _mfGeometries[uiIndex] = value;

      _mfGeometries.replace(uiIndex, value);
}

void VTKMapperBase::replaceInGeometries(GeometryPtrConstArg pOldElem,
                                                        GeometryPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfGeometries.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(GeometriesFieldMask, _mfGeometries);

//        MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfGeometries.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromGeometries(UInt32 uiIndex)
{
    if(uiIndex < _mfGeometries.size())
    {
        editMField(GeometriesFieldMask, _mfGeometries);

        MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfGeometries.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromGeometries(GeometryPtrConstArg value)
{
    Int32 iElemIdx = _mfGeometries.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(GeometriesFieldMask, _mfGeometries);

        MFGeometryPtr::iterator fieldIt = _mfGeometries.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfGeometries.erase(fieldIt);
    }
}
void VTKMapperBase::clearGeometries(void)
{
    editMField(GeometriesFieldMask, _mfGeometries);

    MFGeometryPtr::iterator       fieldIt  = _mfGeometries.begin();
    MFGeometryPtr::const_iterator fieldEnd = _mfGeometries.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfGeometries.clear();
}

void VTKMapperBase::pushToMaterials(ChunkMaterialPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(MaterialsFieldMask, _mfMaterials);

    //addRef(value);

    _mfMaterials.push_back(value);
}

void VTKMapperBase::assignMaterials(const MFChunkMaterialPtr &value)
{
    MFChunkMaterialPtr::const_iterator elemIt  =
        value.begin();
    MFChunkMaterialPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearMaterials();

    while(elemIt != elemEnd)
    {
        this->pushToMaterials(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoMaterials(UInt32                uiIndex,
                                                   ChunkMaterialPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(MaterialsFieldMask, _mfMaterials);

    MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfMaterials.insert(fieldIt, value);
}

void VTKMapperBase::replaceInMaterials(UInt32                uiIndex,
                                                       ChunkMaterialPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfMaterials.size())
        return;

    editMField(MaterialsFieldMask, _mfMaterials);


//    addRef(value);
//    subRef(_mfMaterials[uiIndex]);

//    _mfMaterials[uiIndex] = value;

      _mfMaterials.replace(uiIndex, value);
}

void VTKMapperBase::replaceInMaterials(ChunkMaterialPtrConstArg pOldElem,
                                                        ChunkMaterialPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfMaterials.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(MaterialsFieldMask, _mfMaterials);

//        MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfMaterials.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromMaterials(UInt32 uiIndex)
{
    if(uiIndex < _mfMaterials.size())
    {
        editMField(MaterialsFieldMask, _mfMaterials);

        MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfMaterials.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromMaterials(ChunkMaterialPtrConstArg value)
{
    Int32 iElemIdx = _mfMaterials.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(MaterialsFieldMask, _mfMaterials);

        MFChunkMaterialPtr::iterator fieldIt = _mfMaterials.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfMaterials.erase(fieldIt);
    }
}
void VTKMapperBase::clearMaterials(void)
{
    editMField(MaterialsFieldMask, _mfMaterials);

    MFChunkMaterialPtr::iterator       fieldIt  = _mfMaterials.begin();
    MFChunkMaterialPtr::const_iterator fieldEnd = _mfMaterials.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfMaterials.clear();
}

void VTKMapperBase::pushToMaterialChunks(MaterialChunkPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    //addRef(value);

    _mfMaterialChunks.push_back(value);
}

void VTKMapperBase::assignMaterialChunks(const MFMaterialChunkPtr &value)
{
    MFMaterialChunkPtr::const_iterator elemIt  =
        value.begin();
    MFMaterialChunkPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearMaterialChunks();

    while(elemIt != elemEnd)
    {
        this->pushToMaterialChunks(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoMaterialChunks(UInt32                uiIndex,
                                                   MaterialChunkPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfMaterialChunks.insert(fieldIt, value);
}

void VTKMapperBase::replaceInMaterialChunks(UInt32                uiIndex,
                                                       MaterialChunkPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfMaterialChunks.size())
        return;

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);


//    addRef(value);
//    subRef(_mfMaterialChunks[uiIndex]);

//    _mfMaterialChunks[uiIndex] = value;

      _mfMaterialChunks.replace(uiIndex, value);
}

void VTKMapperBase::replaceInMaterialChunks(MaterialChunkPtrConstArg pOldElem,
                                                        MaterialChunkPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfMaterialChunks.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(MaterialChunksFieldMask, _mfMaterialChunks);

//        MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfMaterialChunks.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromMaterialChunks(UInt32 uiIndex)
{
    if(uiIndex < _mfMaterialChunks.size())
    {
        editMField(MaterialChunksFieldMask, _mfMaterialChunks);

        MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfMaterialChunks.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromMaterialChunks(MaterialChunkPtrConstArg value)
{
    Int32 iElemIdx = _mfMaterialChunks.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(MaterialChunksFieldMask, _mfMaterialChunks);

        MFMaterialChunkPtr::iterator fieldIt = _mfMaterialChunks.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfMaterialChunks.erase(fieldIt);
    }
}
void VTKMapperBase::clearMaterialChunks(void)
{
    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    MFMaterialChunkPtr::iterator       fieldIt  = _mfMaterialChunks.begin();
    MFMaterialChunkPtr::const_iterator fieldEnd = _mfMaterialChunks.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfMaterialChunks.clear();
}

void VTKMapperBase::pushToPositions(GeoPnt3fPropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(PositionsFieldMask, _mfPositions);

    //addRef(value);

    _mfPositions.push_back(value);
}

void VTKMapperBase::assignPositions(const MFGeoPnt3fPropertyPtr &value)
{
    MFGeoPnt3fPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFGeoPnt3fPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearPositions();

    while(elemIt != elemEnd)
    {
        this->pushToPositions(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoPositions(UInt32                uiIndex,
                                                   GeoPnt3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(PositionsFieldMask, _mfPositions);

    MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfPositions.insert(fieldIt, value);
}

void VTKMapperBase::replaceInPositions(UInt32                uiIndex,
                                                       GeoPnt3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfPositions.size())
        return;

    editMField(PositionsFieldMask, _mfPositions);


//    addRef(value);
//    subRef(_mfPositions[uiIndex]);

//    _mfPositions[uiIndex] = value;

      _mfPositions.replace(uiIndex, value);
}

void VTKMapperBase::replaceInPositions(GeoPnt3fPropertyPtrConstArg pOldElem,
                                                        GeoPnt3fPropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfPositions.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(PositionsFieldMask, _mfPositions);

//        MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfPositions.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromPositions(UInt32 uiIndex)
{
    if(uiIndex < _mfPositions.size())
    {
        editMField(PositionsFieldMask, _mfPositions);

        MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfPositions.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromPositions(GeoPnt3fPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfPositions.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PositionsFieldMask, _mfPositions);

        MFGeoPnt3fPropertyPtr::iterator fieldIt = _mfPositions.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfPositions.erase(fieldIt);
    }
}
void VTKMapperBase::clearPositions(void)
{
    editMField(PositionsFieldMask, _mfPositions);

    MFGeoPnt3fPropertyPtr::iterator       fieldIt  = _mfPositions.begin();
    MFGeoPnt3fPropertyPtr::const_iterator fieldEnd = _mfPositions.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfPositions.clear();
}

void VTKMapperBase::pushToLength(GeoUInt32PropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(LengthFieldMask, _mfLength);

    //addRef(value);

    _mfLength.push_back(value);
}

void VTKMapperBase::assignLength   (const MFGeoUInt32PropertyPtr &value)
{
    MFGeoUInt32PropertyPtr::const_iterator elemIt  =
        value.begin();
    MFGeoUInt32PropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearLength();

    while(elemIt != elemEnd)
    {
        this->pushToLength(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoLength(UInt32                uiIndex,
                                                   GeoUInt32PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(LengthFieldMask, _mfLength);

    MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfLength.insert(fieldIt, value);
}

void VTKMapperBase::replaceInLength(UInt32                uiIndex,
                                                       GeoUInt32PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfLength.size())
        return;

    editMField(LengthFieldMask, _mfLength);


//    addRef(value);
//    subRef(_mfLength[uiIndex]);

//    _mfLength[uiIndex] = value;

      _mfLength.replace(uiIndex, value);
}

void VTKMapperBase::replaceInLength(GeoUInt32PropertyPtrConstArg pOldElem,
                                                        GeoUInt32PropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfLength.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(LengthFieldMask, _mfLength);

//        MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfLength.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromLength(UInt32 uiIndex)
{
    if(uiIndex < _mfLength.size())
    {
        editMField(LengthFieldMask, _mfLength);

        MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfLength.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromLength(GeoUInt32PropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfLength.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(LengthFieldMask, _mfLength);

        MFGeoUInt32PropertyPtr::iterator fieldIt = _mfLength.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfLength.erase(fieldIt);
    }
}
void VTKMapperBase::clearLength(void)
{
    editMField(LengthFieldMask, _mfLength);

    MFGeoUInt32PropertyPtr::iterator       fieldIt  = _mfLength.begin();
    MFGeoUInt32PropertyPtr::const_iterator fieldEnd = _mfLength.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfLength.clear();
}

void VTKMapperBase::pushToTypes(GeoUInt8PropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(TypesFieldMask, _mfTypes);

    //addRef(value);

    _mfTypes.push_back(value);
}

void VTKMapperBase::assignTypes    (const MFGeoUInt8PropertyPtr &value)
{
    MFGeoUInt8PropertyPtr::const_iterator elemIt  =
        value.begin();
    MFGeoUInt8PropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearTypes();

    while(elemIt != elemEnd)
    {
        this->pushToTypes(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoTypes(UInt32                uiIndex,
                                                   GeoUInt8PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(TypesFieldMask, _mfTypes);

    MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfTypes.insert(fieldIt, value);
}

void VTKMapperBase::replaceInTypes(UInt32                uiIndex,
                                                       GeoUInt8PropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfTypes.size())
        return;

    editMField(TypesFieldMask, _mfTypes);


//    addRef(value);
//    subRef(_mfTypes[uiIndex]);

//    _mfTypes[uiIndex] = value;

      _mfTypes.replace(uiIndex, value);
}

void VTKMapperBase::replaceInTypes(GeoUInt8PropertyPtrConstArg pOldElem,
                                                        GeoUInt8PropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfTypes.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(TypesFieldMask, _mfTypes);

//        MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfTypes.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromTypes(UInt32 uiIndex)
{
    if(uiIndex < _mfTypes.size())
    {
        editMField(TypesFieldMask, _mfTypes);

        MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfTypes.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromTypes(GeoUInt8PropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfTypes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TypesFieldMask, _mfTypes);

        MFGeoUInt8PropertyPtr::iterator fieldIt = _mfTypes.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfTypes.erase(fieldIt);
    }
}
void VTKMapperBase::clearTypes(void)
{
    editMField(TypesFieldMask, _mfTypes);

    MFGeoUInt8PropertyPtr::iterator       fieldIt  = _mfTypes.begin();
    MFGeoUInt8PropertyPtr::const_iterator fieldEnd = _mfTypes.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfTypes.clear();
}

void VTKMapperBase::pushToColors(GeoColor4fPropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(ColorsFieldMask, _mfColors);

    //addRef(value);

    _mfColors.push_back(value);
}

void VTKMapperBase::assignColors   (const MFGeoColor4fPropertyPtr &value)
{
    MFGeoColor4fPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFGeoColor4fPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearColors();

    while(elemIt != elemEnd)
    {
        this->pushToColors(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoColors(UInt32                uiIndex,
                                                   GeoColor4fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(ColorsFieldMask, _mfColors);

    MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfColors.insert(fieldIt, value);
}

void VTKMapperBase::replaceInColors(UInt32                uiIndex,
                                                       GeoColor4fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfColors.size())
        return;

    editMField(ColorsFieldMask, _mfColors);


//    addRef(value);
//    subRef(_mfColors[uiIndex]);

//    _mfColors[uiIndex] = value;

      _mfColors.replace(uiIndex, value);
}

void VTKMapperBase::replaceInColors(GeoColor4fPropertyPtrConstArg pOldElem,
                                                        GeoColor4fPropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfColors.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(ColorsFieldMask, _mfColors);

//        MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfColors.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromColors(UInt32 uiIndex)
{
    if(uiIndex < _mfColors.size())
    {
        editMField(ColorsFieldMask, _mfColors);

        MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfColors.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromColors(GeoColor4fPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfColors.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ColorsFieldMask, _mfColors);

        MFGeoColor4fPropertyPtr::iterator fieldIt = _mfColors.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfColors.erase(fieldIt);
    }
}
void VTKMapperBase::clearColors(void)
{
    editMField(ColorsFieldMask, _mfColors);

    MFGeoColor4fPropertyPtr::iterator       fieldIt  = _mfColors.begin();
    MFGeoColor4fPropertyPtr::const_iterator fieldEnd = _mfColors.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfColors.clear();
}

void VTKMapperBase::pushToNormals(GeoVec3fPropertyPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(NormalsFieldMask, _mfNormals);

    //addRef(value);

    _mfNormals.push_back(value);
}

void VTKMapperBase::assignNormals  (const MFGeoVec3fPropertyPtr &value)
{
    MFGeoVec3fPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFGeoVec3fPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<VTKMapper *>(this)->clearNormals();

    while(elemIt != elemEnd)
    {
        this->pushToNormals(*elemIt);

        ++elemIt;
    }
}

void VTKMapperBase::insertIntoNormals(UInt32                uiIndex,
                                                   GeoVec3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(NormalsFieldMask, _mfNormals);

    MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

    //addRef(value);

    fieldIt += uiIndex;

    _mfNormals.insert(fieldIt, value);
}

void VTKMapperBase::replaceInNormals(UInt32                uiIndex,
                                                       GeoVec3fPropertyPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfNormals.size())
        return;

    editMField(NormalsFieldMask, _mfNormals);


//    addRef(value);
//    subRef(_mfNormals[uiIndex]);

//    _mfNormals[uiIndex] = value;

      _mfNormals.replace(uiIndex, value);
}

void VTKMapperBase::replaceInNormals(GeoVec3fPropertyPtrConstArg pOldElem,
                                                        GeoVec3fPropertyPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfNormals.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(NormalsFieldMask, _mfNormals);

//        MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfNormals.replace(elemIdx, pNewElem);
    }
}

void VTKMapperBase::removeFromNormals(UInt32 uiIndex)
{
    if(uiIndex < _mfNormals.size())
    {
        editMField(NormalsFieldMask, _mfNormals);

        MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfNormals.erase(fieldIt);
    }
}

void VTKMapperBase::removeFromNormals(GeoVec3fPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfNormals.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(NormalsFieldMask, _mfNormals);

        MFGeoVec3fPropertyPtr::iterator fieldIt = _mfNormals.begin();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfNormals.erase(fieldIt);
    }
}
void VTKMapperBase::clearNormals(void)
{
    editMField(NormalsFieldMask, _mfNormals);

    MFGeoVec3fPropertyPtr::iterator       fieldIt  = _mfNormals.begin();
    MFGeoVec3fPropertyPtr::const_iterator fieldEnd = _mfNormals.end  ();

    while(fieldIt != fieldEnd)
    {
        //subRef(*fieldIt);

        ++fieldIt;
    }

    _mfNormals.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 VTKMapperBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (RootFieldMask & whichField))
    {
        returnValue += _sfRoot.getBinSize();
    }
    if(FieldBits::NoField != (GeoRootsFieldMask & whichField))
    {
        returnValue += _mfGeoRoots.getBinSize();
    }
    if(FieldBits::NoField != (GeometriesFieldMask & whichField))
    {
        returnValue += _mfGeometries.getBinSize();
    }
    if(FieldBits::NoField != (MaterialsFieldMask & whichField))
    {
        returnValue += _mfMaterials.getBinSize();
    }
    if(FieldBits::NoField != (MaterialChunksFieldMask & whichField))
    {
        returnValue += _mfMaterialChunks.getBinSize();
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        returnValue += _mfPositions.getBinSize();
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        returnValue += _mfLength.getBinSize();
    }
    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        returnValue += _mfTypes.getBinSize();
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        returnValue += _mfColors.getBinSize();
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        returnValue += _mfNormals.getBinSize();
    }

    return returnValue;
}

void VTKMapperBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (RootFieldMask & whichField))
    {
        _sfRoot.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GeoRootsFieldMask & whichField))
    {
        _mfGeoRoots.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GeometriesFieldMask & whichField))
    {
        _mfGeometries.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialsFieldMask & whichField))
    {
        _mfMaterials.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MaterialChunksFieldMask & whichField))
    {
        _mfMaterialChunks.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _mfPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        _mfLength.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _mfTypes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _mfColors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _mfNormals.copyToBin(pMem);
    }
}

void VTKMapperBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (RootFieldMask & whichField))
    {
        _sfRoot.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GeoRootsFieldMask & whichField))
    {
        _mfGeoRoots.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GeometriesFieldMask & whichField))
    {
        _mfGeometries.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialsFieldMask & whichField))
    {
        _mfMaterials.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MaterialChunksFieldMask & whichField))
    {
        _mfMaterialChunks.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _mfPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LengthFieldMask & whichField))
    {
        _mfLength.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _mfTypes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _mfColors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _mfNormals.copyFromBin(pMem);
    }
}

//! create a new instance of the class
VTKMapperTransitPtr VTKMapperBase::create(void)
{
    VTKMapperTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<VTKMapper>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
VTKMapperTransitPtr VTKMapperBase::createLocal(BitVector bFlags)
{
    VTKMapperTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<VTKMapper>(tmpPtr);
    }

    return fc;
}

//! create an empty new instance of the class, do not copy the prototype
VTKMapperPtr VTKMapperBase::createEmpty(void)
{
    VTKMapperPtr returnValue;

    newPtr<VTKMapper>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &= 
        ~Thread::getCurrentLocalFlags(); 

    return returnValue;
}

VTKMapperPtr VTKMapperBase::createEmptyLocal(BitVector bFlags)
{
    VTKMapperPtr returnValue;

    newPtr<VTKMapper>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr VTKMapperBase::shallowCopy(void) const
{
    VTKMapperPtr tmpPtr;

    newPtr(tmpPtr, 
           dynamic_cast<const VTKMapper *>(this), 
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}

FieldContainerTransitPtr VTKMapperBase::shallowCopyLocal(
    BitVector bFlags) const
{
    VTKMapperPtr tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const VTKMapper *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

VTKMapperBase::VTKMapperBase(void) :
    Inherited(),
    _sfRoot                   (NullFC),
    _mfGeoRoots               (),
    _mfGeometries             (),
    _mfMaterials              (),
    _mfMaterialChunks         (),
    _mfPositions              (),
    _mfLength                 (),
    _mfTypes                  (),
    _mfColors                 (),
    _mfNormals                ()
{
}

VTKMapperBase::VTKMapperBase(const VTKMapperBase &source) :
    Inherited(source),
    _sfRoot                   (NullFC),
    _mfGeoRoots               (),
    _mfGeometries             (),
    _mfMaterials              (),
    _mfMaterialChunks         (),
    _mfPositions              (),
    _mfLength                 (),
    _mfTypes                  (),
    _mfColors                 (),
    _mfNormals                ()
{
}


/*-------------------------- destructors ----------------------------------*/

VTKMapperBase::~VTKMapperBase(void)
{
}

void VTKMapperBase::onCreate(const VTKMapper *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setRoot(source->getRoot());

        MFNodePtr::const_iterator GeoRootsIt  =
            source->_mfGeoRoots.begin();
        MFNodePtr::const_iterator GeoRootsEnd =
            source->_mfGeoRoots.end  ();

        while(GeoRootsIt != GeoRootsEnd)
        {
            this->pushToGeoRoots(*GeoRootsIt);

            ++GeoRootsIt;
        }

        MFGeometryPtr::const_iterator GeometriesIt  =
            source->_mfGeometries.begin();
        MFGeometryPtr::const_iterator GeometriesEnd =
            source->_mfGeometries.end  ();

        while(GeometriesIt != GeometriesEnd)
        {
            this->pushToGeometries(*GeometriesIt);

            ++GeometriesIt;
        }

        MFChunkMaterialPtr::const_iterator MaterialsIt  =
            source->_mfMaterials.begin();
        MFChunkMaterialPtr::const_iterator MaterialsEnd =
            source->_mfMaterials.end  ();

        while(MaterialsIt != MaterialsEnd)
        {
            this->pushToMaterials(*MaterialsIt);

            ++MaterialsIt;
        }

        MFMaterialChunkPtr::const_iterator MaterialChunksIt  =
            source->_mfMaterialChunks.begin();
        MFMaterialChunkPtr::const_iterator MaterialChunksEnd =
            source->_mfMaterialChunks.end  ();

        while(MaterialChunksIt != MaterialChunksEnd)
        {
            this->pushToMaterialChunks(*MaterialChunksIt);

            ++MaterialChunksIt;
        }

        MFGeoPnt3fPropertyPtr::const_iterator PositionsIt  =
            source->_mfPositions.begin();
        MFGeoPnt3fPropertyPtr::const_iterator PositionsEnd =
            source->_mfPositions.end  ();

        while(PositionsIt != PositionsEnd)
        {
            this->pushToPositions(*PositionsIt);

            ++PositionsIt;
        }

        MFGeoUInt32PropertyPtr::const_iterator LengthIt  =
            source->_mfLength.begin();
        MFGeoUInt32PropertyPtr::const_iterator LengthEnd =
            source->_mfLength.end  ();

        while(LengthIt != LengthEnd)
        {
            this->pushToLength(*LengthIt);

            ++LengthIt;
        }

        MFGeoUInt8PropertyPtr::const_iterator TypesIt  =
            source->_mfTypes.begin();
        MFGeoUInt8PropertyPtr::const_iterator TypesEnd =
            source->_mfTypes.end  ();

        while(TypesIt != TypesEnd)
        {
            this->pushToTypes(*TypesIt);

            ++TypesIt;
        }

        MFGeoColor4fPropertyPtr::const_iterator ColorsIt  =
            source->_mfColors.begin();
        MFGeoColor4fPropertyPtr::const_iterator ColorsEnd =
            source->_mfColors.end  ();

        while(ColorsIt != ColorsEnd)
        {
            this->pushToColors(*ColorsIt);

            ++ColorsIt;
        }

        MFGeoVec3fPropertyPtr::const_iterator NormalsIt  =
            source->_mfNormals.begin();
        MFGeoVec3fPropertyPtr::const_iterator NormalsEnd =
            source->_mfNormals.end  ();

        while(NormalsIt != NormalsEnd)
        {
            this->pushToNormals(*NormalsIt);

            ++NormalsIt;
        }
    }
}

GetFieldHandlePtr VTKMapperBase::getHandleRoot            (void) const
{
    SFNodePtr::GetHandlePtr returnValue(
        new  SFNodePtr::GetHandle(
             &_sfRoot, 
             this->getType().getFieldDesc(RootFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleRoot           (void)
{
    SFNodePtr::EditHandlePtr returnValue(
        new  SFNodePtr::EditHandle(
             &_sfRoot, 
             this->getType().getFieldDesc(RootFieldId)));

    returnValue->setSetMethod(boost::bind(&VTKMapper::setRoot, 
                                          static_cast<VTKMapper *>(this), _1));

    editSField(RootFieldMask);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleGeoRoots        (void) const
{
    MFNodePtr::GetHandlePtr returnValue(
        new  MFNodePtr::GetHandle(
             &_mfGeoRoots, 
             this->getType().getFieldDesc(GeoRootsFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleGeoRoots       (void)
{
    MFNodePtr::EditHandlePtr returnValue(
        new  MFNodePtr::EditHandle(
             &_mfGeoRoots, 
             this->getType().getFieldDesc(GeoRootsFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToGeoRoots, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(GeoRootsFieldMask, _mfGeoRoots);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleGeometries      (void) const
{
    MFGeometryPtr::GetHandlePtr returnValue(
        new  MFGeometryPtr::GetHandle(
             &_mfGeometries, 
             this->getType().getFieldDesc(GeometriesFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleGeometries     (void)
{
    MFGeometryPtr::EditHandlePtr returnValue(
        new  MFGeometryPtr::EditHandle(
             &_mfGeometries, 
             this->getType().getFieldDesc(GeometriesFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToGeometries, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(GeometriesFieldMask, _mfGeometries);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleMaterials       (void) const
{
    MFChunkMaterialPtr::GetHandlePtr returnValue(
        new  MFChunkMaterialPtr::GetHandle(
             &_mfMaterials, 
             this->getType().getFieldDesc(MaterialsFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleMaterials      (void)
{
    MFChunkMaterialPtr::EditHandlePtr returnValue(
        new  MFChunkMaterialPtr::EditHandle(
             &_mfMaterials, 
             this->getType().getFieldDesc(MaterialsFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToMaterials, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(MaterialsFieldMask, _mfMaterials);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleMaterialChunks  (void) const
{
    MFMaterialChunkPtr::GetHandlePtr returnValue(
        new  MFMaterialChunkPtr::GetHandle(
             &_mfMaterialChunks, 
             this->getType().getFieldDesc(MaterialChunksFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleMaterialChunks (void)
{
    MFMaterialChunkPtr::EditHandlePtr returnValue(
        new  MFMaterialChunkPtr::EditHandle(
             &_mfMaterialChunks, 
             this->getType().getFieldDesc(MaterialChunksFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToMaterialChunks, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(MaterialChunksFieldMask, _mfMaterialChunks);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandlePositions       (void) const
{
    MFGeoPnt3fPropertyPtr::GetHandlePtr returnValue(
        new  MFGeoPnt3fPropertyPtr::GetHandle(
             &_mfPositions, 
             this->getType().getFieldDesc(PositionsFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandlePositions      (void)
{
    MFGeoPnt3fPropertyPtr::EditHandlePtr returnValue(
        new  MFGeoPnt3fPropertyPtr::EditHandle(
             &_mfPositions, 
             this->getType().getFieldDesc(PositionsFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToPositions, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(PositionsFieldMask, _mfPositions);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleLength          (void) const
{
    MFGeoUInt32PropertyPtr::GetHandlePtr returnValue(
        new  MFGeoUInt32PropertyPtr::GetHandle(
             &_mfLength, 
             this->getType().getFieldDesc(LengthFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleLength         (void)
{
    MFGeoUInt32PropertyPtr::EditHandlePtr returnValue(
        new  MFGeoUInt32PropertyPtr::EditHandle(
             &_mfLength, 
             this->getType().getFieldDesc(LengthFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToLength, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(LengthFieldMask, _mfLength);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleTypes           (void) const
{
    MFGeoUInt8PropertyPtr::GetHandlePtr returnValue(
        new  MFGeoUInt8PropertyPtr::GetHandle(
             &_mfTypes, 
             this->getType().getFieldDesc(TypesFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleTypes          (void)
{
    MFGeoUInt8PropertyPtr::EditHandlePtr returnValue(
        new  MFGeoUInt8PropertyPtr::EditHandle(
             &_mfTypes, 
             this->getType().getFieldDesc(TypesFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToTypes, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(TypesFieldMask, _mfTypes);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleColors          (void) const
{
    MFGeoColor4fPropertyPtr::GetHandlePtr returnValue(
        new  MFGeoColor4fPropertyPtr::GetHandle(
             &_mfColors, 
             this->getType().getFieldDesc(ColorsFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleColors         (void)
{
    MFGeoColor4fPropertyPtr::EditHandlePtr returnValue(
        new  MFGeoColor4fPropertyPtr::EditHandle(
             &_mfColors, 
             this->getType().getFieldDesc(ColorsFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToColors, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(ColorsFieldMask, _mfColors);

    return returnValue;
}

GetFieldHandlePtr VTKMapperBase::getHandleNormals         (void) const
{
    MFGeoVec3fPropertyPtr::GetHandlePtr returnValue(
        new  MFGeoVec3fPropertyPtr::GetHandle(
             &_mfNormals, 
             this->getType().getFieldDesc(NormalsFieldId)));

    return returnValue;
}

EditFieldHandlePtr VTKMapperBase::editHandleNormals        (void)
{
    MFGeoVec3fPropertyPtr::EditHandlePtr returnValue(
        new  MFGeoVec3fPropertyPtr::EditHandle(
             &_mfNormals, 
             this->getType().getFieldDesc(NormalsFieldId)));

    returnValue->setAddMethod(boost::bind(&VTKMapper::pushToNormals, 
                              static_cast<VTKMapper *>(this), _1));

    editMField(NormalsFieldMask, _mfNormals);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void VTKMapperBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<VTKMapperBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr VTKMapperBase::createAspectCopy(void) const
{
    VTKMapperPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const VTKMapper *>(this));

    return returnValue;
}
#endif

void VTKMapperBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<VTKMapper *>(this)->setRoot(NullFC);


    static_cast<VTKMapper *>(this)->clearGeoRoots();
    static_cast<VTKMapper *>(this)->clearGeometries();
    static_cast<VTKMapper *>(this)->clearMaterials();
    static_cast<VTKMapper *>(this)->clearMaterialChunks();
    static_cast<VTKMapper *>(this)->clearPositions();
    static_cast<VTKMapper *>(this)->clearLength();
    static_cast<VTKMapper *>(this)->clearTypes();
    static_cast<VTKMapper *>(this)->clearColors();
    static_cast<VTKMapper *>(this)->clearNormals();
}


#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<VTKMapperPtr>::_type("VTKMapperPtr", "GroupPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(VTKMapperPtr)

OSG_SFIELDTYPE_INST(FieldContainerPtrSField, 
                    VTKMapperPtr, 
                    RecordedRefCounts,
                    0);

OSG_FIELD_DLLEXPORT_DEF3(FieldContainerPtrSField, 
                         VTKMapperPtr, 
                         RecordedRefCounts,
                         0);

OSG_MFIELDTYPE_INST(FieldContainerPtrMField, 
                    VTKMapperPtr, 
                    RecordedRefCounts,
                    0);

OSG_FIELD_DLLEXPORT_DEF3(FieldContainerPtrMField, 
                         VTKMapperPtr, 
                         RecordedRefCounts,
                         0);

OSG_END_NAMESPACE
