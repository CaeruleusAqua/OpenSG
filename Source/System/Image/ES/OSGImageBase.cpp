/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Image!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEIMAGEINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>                        // DataType default header

#include <OSGFieldContainer.h> // Parents Class

#include "OSGImageBase.h"
#include "OSGImage.h"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Image
    1D/2D/3D Image with various pixel types data, optionally also can hold
    mipMap and simple multi-frame data.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var ParentFieldContainerPtr ImageBase::_mfParents
    
*/

/*! \var Int32           ImageBase::_sfDimension
    Image dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.
*/

/*! \var Int32           ImageBase::_sfWidth
    
*/

/*! \var Int32           ImageBase::_sfHeight
    
*/

/*! \var Int32           ImageBase::_sfDepth
    
*/

/*! \var Int32           ImageBase::_sfBpp
    
*/

/*! \var Int32           ImageBase::_sfMipMapCount
    
*/

/*! \var Int32           ImageBase::_sfFrameCount
    
*/

/*! \var Time            ImageBase::_sfFrameDelay
    
*/

/*! \var UInt32          ImageBase::_sfPixelFormat
    
*/

/*! \var UInt8           ImageBase::_mfPixel
    
*/

/*! \var Int32           ImageBase::_sfFrameSize
    
*/

/*! \var std::string     ImageBase::_sfName
    Texture file path.
*/

/*! \var Int32           ImageBase::_sfDataType
    Type of image data.
*/

/*! \var Int32           ImageBase::_sfComponentSize
    Size (in byte) of a single component of the image. Necessary
    for High Dynamic Range and other higher-level image types.
*/

/*! \var Int32           ImageBase::_sfSideCount
    
*/

/*! \var Int32           ImageBase::_sfSideSize
    
*/

/*! \var bool            ImageBase::_sfForceCompressedData
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceAlphaChannel
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceColorChannel
    Set to true if using the image to keep unknown data for textures.
    Generally used in conjunction with TextureChunk::externalFormat.
*/

/*! \var bool            ImageBase::_sfForceAlphaBinary
    Set to true if using the image to prevent depth sorting for 
    SimpleTexturedMaterials using this Image.
*/


void ImageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFParentFieldContainerPtr::Description(
        MFParentFieldContainerPtr::getClassType(),
        "parents",
        "",
        ParentsFieldId, ParentsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&ImageBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getMFParents));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFDimensionF)(void) const;

    GetSFDimensionF GetSFDimension = &ImageBase::getSFDimension;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dimension",
        "Image dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.\n",
        DimensionFieldId, DimensionFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFDimension),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDimension));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFDimension));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFWidthF)(void) const;

    GetSFWidthF GetSFWidth = &ImageBase::getSFWidth;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "width",
        "",
        WidthFieldId, WidthFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFWidth),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWidth));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFWidth));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFHeightF)(void) const;

    GetSFHeightF GetSFHeight = &ImageBase::getSFHeight;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "height",
        "",
        HeightFieldId, HeightFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFHeight),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFHeight));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFHeight));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFDepthF)(void) const;

    GetSFDepthF GetSFDepth = &ImageBase::getSFDepth;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "depth",
        "",
        DepthFieldId, DepthFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFDepth),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDepth));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFDepth));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFBppF)(void) const;

    GetSFBppF GetSFBpp = &ImageBase::getSFBpp;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "bpp",
        "",
        BppFieldId, BppFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFBpp),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBpp));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFBpp));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFMipMapCountF)(void) const;

    GetSFMipMapCountF GetSFMipMapCount = &ImageBase::getSFMipMapCount;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "mipMapCount",
        "",
        MipMapCountFieldId, MipMapCountFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFMipMapCount),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMipMapCount));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFMipMapCount));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFFrameCountF)(void) const;

    GetSFFrameCountF GetSFFrameCount = &ImageBase::getSFFrameCount;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "frameCount",
        "",
        FrameCountFieldId, FrameCountFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFFrameCount),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrameCount));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFFrameCount));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFTime *(ImageBase::*GetSFFrameDelayF)(void) const;

    GetSFFrameDelayF GetSFFrameDelay = &ImageBase::getSFFrameDelay;
#endif

    pDesc = new SFTime::Description(
        SFTime::getClassType(),
        "frameDelay",
        "",
        FrameDelayFieldId, FrameDelayFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFFrameDelay),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrameDelay));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFFrameDelay));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(ImageBase::*GetSFPixelFormatF)(void) const;

    GetSFPixelFormatF GetSFPixelFormat = &ImageBase::getSFPixelFormat;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "pixelFormat",
        "",
        PixelFormatFieldId, PixelFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFPixelFormat),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPixelFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFPixelFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const MFUInt8 *(ImageBase::*GetMFPixelF)(void) const;

    GetMFPixelF GetMFPixel = &ImageBase::getMFPixel;
#endif

    pDesc = new MFUInt8::Description(
        MFUInt8::getClassType(),
        "pixel",
        "",
        PixelFieldId, PixelFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editMFPixel),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFPixel));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getMFPixel));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFFrameSizeF)(void) const;

    GetSFFrameSizeF GetSFFrameSize = &ImageBase::getSFFrameSize;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "frameSize",
        "",
        FrameSizeFieldId, FrameSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFFrameSize),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrameSize));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFFrameSize));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFString *(ImageBase::*GetSFNameF)(void) const;

    GetSFNameF GetSFName = &ImageBase::getSFName;
#endif

    pDesc = new SFString::Description(
        SFString::getClassType(),
        "name",
        "Texture file path.\n",
        NameFieldId, NameFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFName),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFName));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFName));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFDataTypeF)(void) const;

    GetSFDataTypeF GetSFDataType = &ImageBase::getSFDataType;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dataType",
        "Type of image data.\n",
        DataTypeFieldId, DataTypeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFDataType),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDataType));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFDataType));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFComponentSizeF)(void) const;

    GetSFComponentSizeF GetSFComponentSize = &ImageBase::getSFComponentSize;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "componentSize",
        "Size (in byte) of a single component of the image. Necessary\n"
        "for High Dynamic Range and other higher-level image types.\n",
        ComponentSizeFieldId, ComponentSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFComponentSize),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFComponentSize));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFComponentSize));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFSideCountF)(void) const;

    GetSFSideCountF GetSFSideCount = &ImageBase::getSFSideCount;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sideCount",
        "",
        SideCountFieldId, SideCountFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFSideCount),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFSideCount));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFSideCount));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(ImageBase::*GetSFSideSizeF)(void) const;

    GetSFSideSizeF GetSFSideSize = &ImageBase::getSFSideSize;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "sideSize",
        "",
        SideSizeFieldId, SideSizeFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFSideSize),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFSideSize));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFSideSize));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceCompressedDataF)(void) const;

    GetSFForceCompressedDataF GetSFForceCompressedData = &ImageBase::getSFForceCompressedData;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceCompressedData",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceCompressedDataFieldId, ForceCompressedDataFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceCompressedData),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceCompressedData));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceCompressedData));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceAlphaChannelF)(void) const;

    GetSFForceAlphaChannelF GetSFForceAlphaChannel = &ImageBase::getSFForceAlphaChannel;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceAlphaChannel",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceAlphaChannelFieldId, ForceAlphaChannelFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceAlphaChannel),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceAlphaChannel));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceAlphaChannel));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceColorChannelF)(void) const;

    GetSFForceColorChannelF GetSFForceColorChannel = &ImageBase::getSFForceColorChannel;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceColorChannel",
        "Set to true if using the image to keep unknown data for textures.\n"
        "Generally used in conjunction with TextureChunk::externalFormat.\n",
        ForceColorChannelFieldId, ForceColorChannelFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceColorChannel),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceColorChannel));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceColorChannel));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFBool *(ImageBase::*GetSFForceAlphaBinaryF)(void) const;

    GetSFForceAlphaBinaryF GetSFForceAlphaBinary = &ImageBase::getSFForceAlphaBinary;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "forceAlphaBinary",
        "Set to true if using the image to prevent depth sorting for \n"
        "SimpleTexturedMaterials using this Image.\n",
        ForceAlphaBinaryFieldId, ForceAlphaBinaryFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&ImageBase::editSFForceAlphaBinary),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFForceAlphaBinary));
#else
        reinterpret_cast<FieldGetMethodSig >(&ImageBase::getSFForceAlphaBinary));
#endif

    oType.addInitialDesc(pDesc);
}


ImageBase::TypeObject ImageBase::_type(
    ImageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &ImageBase::createEmpty,
    Image::initMethod,
    (InitalInsertDescFunc) &ImageBase::classDescInserter,
    false,
    (ComponentSizeFieldMask | SideSizeFieldMask | FrameSizeFieldMask),
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Image\"\n"
    "\tparent=\"AttachmentContainer\"\n"
    "\tlibrary=\"System\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    "    fieldsUnmarkedOnCreate=\"(ComponentSizeFieldMask | SideSizeFieldMask | FrameSizeFieldMask)\"\n"
    ">\n"
    "1D/2D/3D Image with various pixel types data, optionally also can hold\n"
    "mipMap and simple multi-frame data.\n"
    "\t<Field\n"
    "\t\tname=\"parents\"\n"
    "\t\ttype=\"ParentFieldContainerPtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dimension\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tImage dimension, 0 for invalid, 1 for 1D, 2 for 2D and 3 for 3D data.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"width\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"height\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"depth\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bpp\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"mipMapCount\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frameCount\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frameDelay\"\n"
    "\t\ttype=\"Time\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pixelFormat\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"Image::OSG_INVALID_PF\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pixel\"\n"
    "\t\ttype=\"UInt8\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frameSize\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"name\"\n"
    "\t\ttype=\"std::string\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture file path.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dataType\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_UNSIGNED_BYTE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tType of image data.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"componentSize\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\tSize (in byte) of a single component of the image. Necessary\n"
    "        for High Dynamic Range and other higher-level image types.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sideCount\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sideSize\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceCompressedData\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to keep unknown data for textures.\n"
    "        Generally used in conjunction with TextureChunk::externalFormat.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceAlphaChannel\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to keep unknown data for textures.\n"
    "        Generally used in conjunction with TextureChunk::externalFormat.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceColorChannel\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to keep unknown data for textures.\n"
    "        Generally used in conjunction with TextureChunk::externalFormat.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"forceAlphaBinary\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Set to true if using the image to prevent depth sorting for \n"
    "        SimpleTexturedMaterials using this Image.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "1D/2D/3D Image with various pixel types data, optionally also can hold\n"
    "mipMap and simple multi-frame data.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ImageBase::getType(void)
{
    return _type;
}

const FieldContainerType &ImageBase::getType(void) const
{
    return _type;
}

UInt32 ImageBase::getContainerSize(void) const
{
    return sizeof(Image);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Image::_mfParents field.
const MFParentFieldContainerPtr *ImageBase::getMFParents(void) const
{
    return &_mfParents;
}

SFInt32 *ImageBase::editSFDimension(void)
{
    editSField(DimensionFieldMask);

    return &_sfDimension;
}

const SFInt32 *ImageBase::getSFDimension(void) const
{
    return &_sfDimension;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFDimension      (void)
{
    return this->editSFDimension      ();
}
#endif

SFInt32 *ImageBase::editSFWidth(void)
{
    editSField(WidthFieldMask);

    return &_sfWidth;
}

const SFInt32 *ImageBase::getSFWidth(void) const
{
    return &_sfWidth;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFWidth          (void)
{
    return this->editSFWidth          ();
}
#endif

SFInt32 *ImageBase::editSFHeight(void)
{
    editSField(HeightFieldMask);

    return &_sfHeight;
}

const SFInt32 *ImageBase::getSFHeight(void) const
{
    return &_sfHeight;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFHeight         (void)
{
    return this->editSFHeight         ();
}
#endif

SFInt32 *ImageBase::editSFDepth(void)
{
    editSField(DepthFieldMask);

    return &_sfDepth;
}

const SFInt32 *ImageBase::getSFDepth(void) const
{
    return &_sfDepth;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFDepth          (void)
{
    return this->editSFDepth          ();
}
#endif

SFInt32 *ImageBase::editSFBpp(void)
{
    editSField(BppFieldMask);

    return &_sfBpp;
}

const SFInt32 *ImageBase::getSFBpp(void) const
{
    return &_sfBpp;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFBpp            (void)
{
    return this->editSFBpp            ();
}
#endif

SFInt32 *ImageBase::editSFMipMapCount(void)
{
    editSField(MipMapCountFieldMask);

    return &_sfMipMapCount;
}

const SFInt32 *ImageBase::getSFMipMapCount(void) const
{
    return &_sfMipMapCount;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFMipMapCount    (void)
{
    return this->editSFMipMapCount    ();
}
#endif

SFInt32 *ImageBase::editSFFrameCount(void)
{
    editSField(FrameCountFieldMask);

    return &_sfFrameCount;
}

const SFInt32 *ImageBase::getSFFrameCount(void) const
{
    return &_sfFrameCount;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFFrameCount     (void)
{
    return this->editSFFrameCount     ();
}
#endif

SFTime *ImageBase::editSFFrameDelay(void)
{
    editSField(FrameDelayFieldMask);

    return &_sfFrameDelay;
}

const SFTime *ImageBase::getSFFrameDelay(void) const
{
    return &_sfFrameDelay;
}

#ifdef OSG_1_GET_COMPAT
SFTime              *ImageBase::getSFFrameDelay     (void)
{
    return this->editSFFrameDelay     ();
}
#endif

SFUInt32 *ImageBase::editSFPixelFormat(void)
{
    editSField(PixelFormatFieldMask);

    return &_sfPixelFormat;
}

const SFUInt32 *ImageBase::getSFPixelFormat(void) const
{
    return &_sfPixelFormat;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ImageBase::getSFPixelFormat    (void)
{
    return this->editSFPixelFormat    ();
}
#endif

MFUInt8 *ImageBase::editMFPixel(void)
{
    editMField(PixelFieldMask, _mfPixel);

    return &_mfPixel;
}

const MFUInt8 *ImageBase::getMFPixel(void) const
{
    return &_mfPixel;
}

#ifdef OSG_1_GET_COMPAT
MFUInt8             *ImageBase::getMFPixel          (void)
{
    return this->editMFPixel          ();
}
#endif

SFInt32 *ImageBase::editSFFrameSize(void)
{
    editSField(FrameSizeFieldMask);

    return &_sfFrameSize;
}

const SFInt32 *ImageBase::getSFFrameSize(void) const
{
    return &_sfFrameSize;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFFrameSize      (void)
{
    return this->editSFFrameSize      ();
}
#endif

SFString *ImageBase::editSFName(void)
{
    editSField(NameFieldMask);

    return &_sfName;
}

const SFString *ImageBase::getSFName(void) const
{
    return &_sfName;
}

#ifdef OSG_1_GET_COMPAT
SFString            *ImageBase::getSFName           (void)
{
    return this->editSFName           ();
}
#endif

SFInt32 *ImageBase::editSFDataType(void)
{
    editSField(DataTypeFieldMask);

    return &_sfDataType;
}

const SFInt32 *ImageBase::getSFDataType(void) const
{
    return &_sfDataType;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFDataType       (void)
{
    return this->editSFDataType       ();
}
#endif

SFInt32 *ImageBase::editSFComponentSize(void)
{
    editSField(ComponentSizeFieldMask);

    return &_sfComponentSize;
}

const SFInt32 *ImageBase::getSFComponentSize(void) const
{
    return &_sfComponentSize;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFComponentSize  (void)
{
    return this->editSFComponentSize  ();
}
#endif

SFInt32 *ImageBase::editSFSideCount(void)
{
    editSField(SideCountFieldMask);

    return &_sfSideCount;
}

const SFInt32 *ImageBase::getSFSideCount(void) const
{
    return &_sfSideCount;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFSideCount      (void)
{
    return this->editSFSideCount      ();
}
#endif

SFInt32 *ImageBase::editSFSideSize(void)
{
    editSField(SideSizeFieldMask);

    return &_sfSideSize;
}

const SFInt32 *ImageBase::getSFSideSize(void) const
{
    return &_sfSideSize;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ImageBase::getSFSideSize       (void)
{
    return this->editSFSideSize       ();
}
#endif

SFBool *ImageBase::editSFForceCompressedData(void)
{
    editSField(ForceCompressedDataFieldMask);

    return &_sfForceCompressedData;
}

const SFBool *ImageBase::getSFForceCompressedData(void) const
{
    return &_sfForceCompressedData;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceCompressedData(void)
{
    return this->editSFForceCompressedData();
}
#endif

SFBool *ImageBase::editSFForceAlphaChannel(void)
{
    editSField(ForceAlphaChannelFieldMask);

    return &_sfForceAlphaChannel;
}

const SFBool *ImageBase::getSFForceAlphaChannel(void) const
{
    return &_sfForceAlphaChannel;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceAlphaChannel(void)
{
    return this->editSFForceAlphaChannel();
}
#endif

SFBool *ImageBase::editSFForceColorChannel(void)
{
    editSField(ForceColorChannelFieldMask);

    return &_sfForceColorChannel;
}

const SFBool *ImageBase::getSFForceColorChannel(void) const
{
    return &_sfForceColorChannel;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceColorChannel(void)
{
    return this->editSFForceColorChannel();
}
#endif

SFBool *ImageBase::editSFForceAlphaBinary(void)
{
    editSField(ForceAlphaBinaryFieldMask);

    return &_sfForceAlphaBinary;
}

const SFBool *ImageBase::getSFForceAlphaBinary(void) const
{
    return &_sfForceAlphaBinary;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ImageBase::getSFForceAlphaBinary(void)
{
    return this->editSFForceAlphaBinary();
}
#endif


void ImageBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->pushToParents(
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->insertIntoParents(
            uiIndex,
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->replaceInParents(
            uiIndex,
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->replaceInParents(
            cast_dynamic<ParentFieldContainerPtr>(pOldElement),
            cast_dynamic<ParentFieldContainerPtr>(pNewElement));
    }
}

void ImageBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->removeFromParents(
            uiIndex);
    }
}

void ImageBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->removeFromParents(
            cast_dynamic<ParentFieldContainerPtr>(pElement));
    }
}

void ImageBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == ParentsFieldId)
    {
        static_cast<Image *>(this)->clearParents();
    }
}

void ImageBase::pushToParents(ParentFieldContainerPtrConstArg value)
{
    if(value == NullFC)
        return;

    editMField(ParentsFieldMask, _mfParents);

    addRef(value);

    _mfParents.push_back(value);
}

void ImageBase::insertIntoParents(UInt32                uiIndex,
                                                   ParentFieldContainerPtrConstArg value   )
{
    if(value == NullFC)
        return;

    editMField(ParentsFieldMask, _mfParents);

    MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

    addRef(value);

    fieldIt += uiIndex;

    _mfParents.insert(fieldIt, value);
}

void ImageBase::replaceInParents(UInt32                uiIndex,
                                                       ParentFieldContainerPtrConstArg value   )
{
    if(value == NullFC)
        return;

    if(uiIndex >= _mfParents.size())
        return;

    editMField(ParentsFieldMask, _mfParents);

    addRef(value);

    subRef(_mfParents[uiIndex]);

    _mfParents[uiIndex] = value;
}

void ImageBase::replaceInParents(ParentFieldContainerPtrConstArg pOldElem,
                                                        ParentFieldContainerPtrConstArg pNewElem)
{
    if(pNewElem == NullFC)
        return;

    Int32  elemIdx = _mfParents.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(ParentsFieldMask, _mfParents);

        MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

        fieldIt += elemIdx;

        addRef(pNewElem);
        subRef(pOldElem);

        (*fieldIt) = pNewElem;
    }
}

void ImageBase::removeFromParents(UInt32 uiIndex)
{
    if(uiIndex < _mfParents.size())
    {
        editMField(ParentsFieldMask, _mfParents);

        MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

        fieldIt += uiIndex;

        subRef(*fieldIt);

        _mfParents.erase(fieldIt);
    }
}

void ImageBase::removeFromParents(ParentFieldContainerPtrConstArg value)
{
    Int32 iElemIdx = _mfParents.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ParentsFieldMask, _mfParents);

        MFParentFieldContainerPtr::iterator fieldIt = _mfParents.begin();

        fieldIt += iElemIdx;

        subRef(*fieldIt);

        _mfParents.erase(fieldIt);
    }
}
void ImageBase::clearParents(void)
{
    editMField(ParentsFieldMask, _mfParents);

    MFParentFieldContainerPtr::iterator       fieldIt  = _mfParents.begin();
    MFParentFieldContainerPtr::const_iterator fieldEnd = _mfParents.end  ();

    while(fieldIt != fieldEnd)
    {
        subRef(*fieldIt);

        ++fieldIt;
    }

    _mfParents.clear();
}

/*********************************** Non-ptr code ********************************/
void ImageBase::pushToPixel(const UInt8& value)
{
    editMField(PixelFieldMask, _mfPixel);
    _mfPixel.push_back(value);
}

void ImageBase::insertIntoPixel(UInt32                uiIndex,
                                                   const UInt8& value   )
{
    editMField(PixelFieldMask, _mfPixel);

    MFUInt8::iterator fieldIt = _mfPixel.begin();

    fieldIt += uiIndex;

    _mfPixel.insert(fieldIt, value);
}

void ImageBase::replaceInPixel(UInt32                uiIndex,
                                                       const UInt8& value   )
{
    if(uiIndex >= _mfPixel.size())
        return;

    editMField(PixelFieldMask, _mfPixel);

    _mfPixel[uiIndex] = value;
}

void ImageBase::replaceInPixel(const UInt8& pOldElem,
                                                        const UInt8& pNewElem)
{
    Int32  elemIdx = _mfPixel.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(PixelFieldMask, _mfPixel);

        MFUInt8::iterator fieldIt = _mfPixel.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void ImageBase::removeFromPixel(UInt32 uiIndex)
{
    if(uiIndex < _mfPixel.size())
    {
        editMField(PixelFieldMask, _mfPixel);

        MFUInt8::iterator fieldIt = _mfPixel.begin();

        fieldIt += uiIndex;
        _mfPixel.erase(fieldIt);
    }
}

void ImageBase::removeFromPixel(const UInt8& value)
{
    Int32 iElemIdx = _mfPixel.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PixelFieldMask, _mfPixel);

        MFUInt8::iterator fieldIt = _mfPixel.begin();

        fieldIt += iElemIdx;

        _mfPixel.erase(fieldIt);
    }
}

void ImageBase::clearPixel(void)
{
    editMField(PixelFieldMask, _mfPixel);

    _mfPixel.clear();
}


/*------------------------------ access -----------------------------------*/

UInt32 ImageBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        returnValue += _mfParents.getBinSize();
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        returnValue += _sfDimension.getBinSize();
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        returnValue += _sfWidth.getBinSize();
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        returnValue += _sfHeight.getBinSize();
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        returnValue += _sfDepth.getBinSize();
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        returnValue += _sfBpp.getBinSize();
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        returnValue += _sfMipMapCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        returnValue += _sfFrameCount.getBinSize();
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        returnValue += _sfFrameDelay.getBinSize();
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        returnValue += _sfPixelFormat.getBinSize();
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        returnValue += _mfPixel.getBinSize();
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        returnValue += _sfFrameSize.getBinSize();
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        returnValue += _sfName.getBinSize();
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        returnValue += _sfDataType.getBinSize();
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        returnValue += _sfComponentSize.getBinSize();
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        returnValue += _sfSideCount.getBinSize();
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        returnValue += _sfSideSize.getBinSize();
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        returnValue += _sfForceCompressedData.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        returnValue += _sfForceAlphaChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        returnValue += _sfForceColorChannel.getBinSize();
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        returnValue += _sfForceAlphaBinary.getBinSize();
    }

    return returnValue;
}

void ImageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyToBin(pMem);
    }
}

void ImageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ParentsFieldMask & whichField))
    {
        _mfParents.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DimensionFieldMask & whichField))
    {
        _sfDimension.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WidthFieldMask & whichField))
    {
        _sfWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (HeightFieldMask & whichField))
    {
        _sfHeight.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthFieldMask & whichField))
    {
        _sfDepth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BppFieldMask & whichField))
    {
        _sfBpp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MipMapCountFieldMask & whichField))
    {
        _sfMipMapCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameCountFieldMask & whichField))
    {
        _sfFrameCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameDelayFieldMask & whichField))
    {
        _sfFrameDelay.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFormatFieldMask & whichField))
    {
        _sfPixelFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PixelFieldMask & whichField))
    {
        _mfPixel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameSizeFieldMask & whichField))
    {
        _sfFrameSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NameFieldMask & whichField))
    {
        _sfName.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DataTypeFieldMask & whichField))
    {
        _sfDataType.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ComponentSizeFieldMask & whichField))
    {
        _sfComponentSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideCountFieldMask & whichField))
    {
        _sfSideCount.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SideSizeFieldMask & whichField))
    {
        _sfSideSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceCompressedDataFieldMask & whichField))
    {
        _sfForceCompressedData.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaChannelFieldMask & whichField))
    {
        _sfForceAlphaChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceColorChannelFieldMask & whichField))
    {
        _sfForceColorChannel.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ForceAlphaBinaryFieldMask & whichField))
    {
        _sfForceAlphaBinary.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
ImagePtr ImageBase::createEmpty(void)
{
    ImagePtr returnValue;

    newPtr<Image>(returnValue);

    return returnValue;
}

FieldContainerPtr ImageBase::shallowCopy(void) const
{
    ImagePtr returnValue;

    newPtr(returnValue, dynamic_cast<const Image *>(this));

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

ImageBase::ImageBase(void) :
    Inherited(),
    _mfParents                (),
    _sfDimension              (Int32(0)),
    _sfWidth                  (Int32(0)),
    _sfHeight                 (Int32(1)),
    _sfDepth                  (Int32(1)),
    _sfBpp                    (Int32(1)),
    _sfMipMapCount            (Int32(1)),
    _sfFrameCount             (Int32(1)),
    _sfFrameDelay             (Time(0)),
    _sfPixelFormat            (UInt32(Image::OSG_INVALID_PF)),
    _mfPixel                  (),
    _sfFrameSize              (Int32(0)),
    _sfName                   (),
    _sfDataType               (Int32(GL_UNSIGNED_BYTE)),
    _sfComponentSize          (Int32(1)),
    _sfSideCount              (Int32(1)),
    _sfSideSize               (Int32(0)),
    _sfForceCompressedData    (bool(false)),
    _sfForceAlphaChannel      (bool(false)),
    _sfForceColorChannel      (bool(false)),
    _sfForceAlphaBinary       (bool(false))
{
}

ImageBase::ImageBase(const ImageBase &source) :
    Inherited(source),
    _mfParents                (),
    _sfDimension              (source._sfDimension              ),
    _sfWidth                  (source._sfWidth                  ),
    _sfHeight                 (source._sfHeight                 ),
    _sfDepth                  (source._sfDepth                  ),
    _sfBpp                    (source._sfBpp                    ),
    _sfMipMapCount            (source._sfMipMapCount            ),
    _sfFrameCount             (source._sfFrameCount             ),
    _sfFrameDelay             (source._sfFrameDelay             ),
    _sfPixelFormat            (source._sfPixelFormat            ),
    _mfPixel                  (source._mfPixel                  ),
    _sfFrameSize              (source._sfFrameSize              ),
    _sfName                   (source._sfName                   ),
    _sfDataType               (source._sfDataType               ),
    _sfComponentSize          (source._sfComponentSize          ),
    _sfSideCount              (source._sfSideCount              ),
    _sfSideSize               (source._sfSideSize               ),
    _sfForceCompressedData    (source._sfForceCompressedData    ),
    _sfForceAlphaChannel      (source._sfForceAlphaChannel      ),
    _sfForceColorChannel      (source._sfForceColorChannel      ),
    _sfForceAlphaBinary       (source._sfForceAlphaBinary       )
{
}

/*-------------------------- destructors ----------------------------------*/

ImageBase::~ImageBase(void)
{
}

void ImageBase::onCreate(const Image *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        MFParentFieldContainerPtr::const_iterator ParentsIt  =
            source->_mfParents.begin();
        MFParentFieldContainerPtr::const_iterator ParentsEnd =
            source->_mfParents.end  ();

        while(ParentsIt != ParentsEnd)
        {
            this->pushToParents(*ParentsIt);

            ++ParentsIt;
        }
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void ImageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<ImageBase *>(&oFrom),
                   whichField,
                   syncMode,
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void ImageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<ImageBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void ImageBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr ImageBase::createAspectCopy(void) const
{
    ImagePtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Image *>(this));

    return returnValue;
}
#endif

void ImageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

    static_cast<Image *>(this)->clearParents();
#ifdef OSG_MT_CPTR_ASPECT
    _mfPixel.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE

#include "OSGSFieldAdaptor.ins"
#include "OSGMFieldAdaptor.ins"

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ImagePtr>::_type("ImagePtr", "AttachmentContainerPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ImagePtr)

OSG_FIELD_DLLEXPORT_DEF2(SFieldAdaptor, ImagePtr, SFFieldContainerPtr);
OSG_FIELD_DLLEXPORT_DEF2(MFieldAdaptor, ImagePtr, MFFieldContainerPtr);

OSG_END_NAMESPACE
