/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Geometry!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEGEOMETRYINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGGeoIntegralProperty.h> // Types Class
#include <OSGGeoIntegralProperty.h> // Lengths Class
#include <OSGGeoVectorProperty.h> // Properties Class
#include <OSGGeoIntegralProperty.h> // PropIndices Class

#include "OSGGeometryBase.h"
#include "OSGGeometry.h"

#include "boost/bind.hpp"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Geometry
    
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var GeoIntegralPropertyPtr GeometryBase::_sfTypes
    The types property contains the primitive's types. Legal values are 
    everything that can be passed to glBegin(). There have to be as many 
    types as lengths.
*/

/*! \var GeoIntegralPropertyPtr GeometryBase::_sfLengths
    The lengths property contains the number of vertices to use for the 
    corresponding primitive. There have to be as many  lengths as types.
*/

/*! \var GeoVectorPropertyPtr GeometryBase::_mfProperties
    The attributes used to render the geometry. The order is based on the 
    the one given in ARB_vertex_program.
*/

/*! \var GeoIntegralPropertyPtr GeometryBase::_mfPropIndices
    The indices property contains the index data. See \ref 
    PageSystemGeoIndexing for a description of the indexing options.
*/

/*! \var bool            GeometryBase::_sfDlistCache
    Flag to activate caching the geometry inside a display list.
*/

/*! \var Int32           GeometryBase::_sfClassicGLId
    The dlist id for the classic rendering mode, if used.
*/

/*! \var Int32           GeometryBase::_sfAttGLId
    The dlist id for the attribute-based rendering mode, if used.
*/


void GeometryBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUnrecFieldContainerChildGeoIntegralPropertyPtr::Description(
        SFUnrecFieldContainerChildGeoIntegralPropertyPtr::getClassType(),
        "types",
        "The types property contains the primitive's types. Legal values are \n"
        "everything that can be passed to glBegin(). There have to be as many \n"
        "types as lengths.\n",
        TypesFieldId, TypesFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandleTypes),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandleTypes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecFieldContainerChildGeoIntegralPropertyPtr::Description(
        SFUnrecFieldContainerChildGeoIntegralPropertyPtr::getClassType(),
        "lengths",
        "The lengths property contains the number of vertices to use for the \n"
        "corresponding primitive. There have to be as many  lengths as types.\n",
        LengthsFieldId, LengthsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandleLengths),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandleLengths));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecFieldContainerChildGeoVectorPropertyPtr::Description(
        MFUnrecFieldContainerChildGeoVectorPropertyPtr::getClassType(),
        "properties",
        "The attributes used to render the geometry. The order is based on the \n"
        "the one given in ARB_vertex_program.\n",
        PropertiesFieldId, PropertiesFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandleProperties),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandleProperties));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecFieldContainerChildGeoIntegralPropertyPtr::Description(
        MFUnrecFieldContainerChildGeoIntegralPropertyPtr::getClassType(),
        "propIndices",
        "The indices property contains the index data. See \\ref \n"
        "PageSystemGeoIndexing for a description of the indexing options.\n",
        PropIndicesFieldId, PropIndicesFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandlePropIndices),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandlePropIndices));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "dlistCache",
        "Flag to activate caching the geometry inside a display list.\n",
        DlistCacheFieldId, DlistCacheFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandleDlistCache),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandleDlistCache));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "classicGLId",
        "The dlist id for the classic rendering mode, if used.\n",
        ClassicGLIdFieldId, ClassicGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandleClassicGLId),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandleClassicGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "attGLId",
        "The dlist id for the attribute-based rendering mode, if used.\n",
        AttGLIdFieldId, AttGLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&GeometryBase::editHandleAttGLId),
        static_cast<FieldGetMethodSig >(&GeometryBase::getHandleAttGLId));

    oType.addInitialDesc(pDesc);
}


GeometryBase::TypeObject GeometryBase::_type(
    GeometryBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &GeometryBase::createEmptyLocal,
    Geometry::initMethod,
    Geometry::exitMethod,
    (InitalInsertDescFunc) &GeometryBase::classDescInserter,
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Geometry\"\n"
    "\tparent=\"MaterialDrawable\"\n"
    "\tlibrary=\"Drawable\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    ">\n"
    "\t<Field\n"
    "\t\tname=\"types\"\n"
    "\t\ttype=\"GeoIntegralProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        The types property contains the primitive's types. Legal values are \n"
    "        everything that can be passed to glBegin(). There have to be as many \n"
    "        types as lengths.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"lengths\"\n"
    "\t\ttype=\"GeoIntegralProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        The lengths property contains the number of vertices to use for the \n"
    "        corresponding primitive. There have to be as many  lengths as types.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"properties\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        checkNilPtr=\"false\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        The attributes used to render the geometry. The order is based on the \n"
    "        the one given in ARB_vertex_program.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"propIndices\"\n"
    "\t\ttype=\"GeoIntegralProperty\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        checkNilPtr=\"false\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        The indices property contains the index data. See \\ref \n"
    "        PageSystemGeoIndexing for a description of the indexing options.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dlistCache\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tFlag to activate caching the geometry inside a display list.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"classicGLId\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"protected\"\n"
    "\t\tfieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\tThe dlist id for the classic rendering mode, if used.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"attGLId\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"protected\"\n"
    "\t\tfieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "\tThe dlist id for the attribute-based rendering mode, if used.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &GeometryBase::getType(void)
{
    return _type;
}

const FieldContainerType &GeometryBase::getType(void) const
{
    return _type;
}

UInt32 GeometryBase::getContainerSize(void) const
{
    return sizeof(Geometry);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Geometry::_sfTypes field.
const SFUnrecFieldContainerChildGeoIntegralPropertyPtr *GeometryBase::getSFTypes(void) const
{
    return &_sfTypes;
}

//! Get the Geometry::_sfLengths field.
const SFUnrecFieldContainerChildGeoIntegralPropertyPtr *GeometryBase::getSFLengths(void) const
{
    return &_sfLengths;
}

//! Get the Geometry::_mfProperties field.
const MFUnrecFieldContainerChildGeoVectorPropertyPtr *GeometryBase::getMFProperties(void) const
{
    return &_mfProperties;
}

//! Get the Geometry::_mfPropIndices field.
const MFUnrecFieldContainerChildGeoIntegralPropertyPtr *GeometryBase::getMFPropIndices(void) const
{
    return &_mfPropIndices;
}

SFBool *GeometryBase::editSFDlistCache(void)
{
    editSField(DlistCacheFieldMask);

    return &_sfDlistCache;
}

const SFBool *GeometryBase::getSFDlistCache(void) const
{
    return &_sfDlistCache;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *GeometryBase::getSFDlistCache     (void)
{
    return this->editSFDlistCache     ();
}
#endif

SFInt32 *GeometryBase::editSFClassicGLId(void)
{
    editSField(ClassicGLIdFieldMask);

    return &_sfClassicGLId;
}

const SFInt32 *GeometryBase::getSFClassicGLId(void) const
{
    return &_sfClassicGLId;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *GeometryBase::getSFClassicGLId    (void)
{
    return this->editSFClassicGLId    ();
}
#endif

SFInt32 *GeometryBase::editSFAttGLId(void)
{
    editSField(AttGLIdFieldMask);

    return &_sfAttGLId;
}

const SFInt32 *GeometryBase::getSFAttGLId(void) const
{
    return &_sfAttGLId;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *GeometryBase::getSFAttGLId        (void)
{
    return this->editSFAttGLId        ();
}
#endif



void GeometryBase::pushToProperties(GeoVectorPropertyPtrConstArg value)
{
    editMField(PropertiesFieldMask, _mfProperties);

    //addRef(value);

    _mfProperties.push_back(value);

//    if(value == NullFC)
//        return;
}

void GeometryBase::assignProperties(const MFUnrecFieldContainerChildGeoVectorPropertyPtr &value)
{
    MFUnrecFieldContainerChildGeoVectorPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecFieldContainerChildGeoVectorPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Geometry *>(this)->clearProperties();

    while(elemIt != elemEnd)
    {
        this->pushToProperties(*elemIt);

        ++elemIt;
    }
}

void GeometryBase::insertIntoProperties(UInt32                uiIndex,
                                                   GeoVectorPropertyPtrConstArg value   )
{
    editMField(PropertiesFieldMask, _mfProperties);

    MFUnrecFieldContainerChildGeoVectorPropertyPtr::iterator fieldIt = _mfProperties.begin_nc();

    //addRef(value);

    fieldIt += uiIndex;

    _mfProperties.insert(fieldIt, value);

//    if(value == NullFC)
//        return;
}

void GeometryBase::replaceInProperties(UInt32                uiIndex,
                                                       GeoVectorPropertyPtrConstArg value   )
{
    if(uiIndex >= _mfProperties.size())
        return;

    editMField(PropertiesFieldMask, _mfProperties);


//    addRef(value);
//    subRef(_mfProperties[uiIndex]);

//    _mfProperties[uiIndex] = value;

      _mfProperties.replace(uiIndex, value);

//    if(value == NullFC)
//        return;
}

void GeometryBase::replaceInProperties(GeoVectorPropertyPtrConstArg pOldElem,
                                                        GeoVectorPropertyPtrConstArg pNewElem)
{
    Int32  elemIdx = _mfProperties.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(PropertiesFieldMask, _mfProperties);

//        MFGeoVectorPropertyPtr::iterator fieldIt = _mfProperties.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfProperties.replace(elemIdx, pNewElem);
    }
}

void GeometryBase::removeFromProperties(UInt32 uiIndex)
{
    if(uiIndex < _mfProperties.size())
    {
        editMField(PropertiesFieldMask, _mfProperties);

        MFUnrecFieldContainerChildGeoVectorPropertyPtr::iterator fieldIt = _mfProperties.begin_nc();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfProperties.erase(fieldIt);
    }
}

void GeometryBase::removeFromProperties(GeoVectorPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfProperties.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PropertiesFieldMask, _mfProperties);

        MFUnrecFieldContainerChildGeoVectorPropertyPtr::iterator fieldIt = _mfProperties.begin_nc();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfProperties.erase(fieldIt);
    }
}
void GeometryBase::clearProperties(void)
{
    editMField(PropertiesFieldMask, _mfProperties);


    _mfProperties.clear();
}

void GeometryBase::pushToPropIndices(GeoIntegralPropertyPtrConstArg value)
{
    editMField(PropIndicesFieldMask, _mfPropIndices);

    //addRef(value);

    _mfPropIndices.push_back(value);

//    if(value == NullFC)
//        return;
}

void GeometryBase::assignPropIndices(const MFUnrecFieldContainerChildGeoIntegralPropertyPtr &value)
{
    MFUnrecFieldContainerChildGeoIntegralPropertyPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecFieldContainerChildGeoIntegralPropertyPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Geometry *>(this)->clearPropIndices();

    while(elemIt != elemEnd)
    {
        this->pushToPropIndices(*elemIt);

        ++elemIt;
    }
}

void GeometryBase::insertIntoPropIndices(UInt32                uiIndex,
                                                   GeoIntegralPropertyPtrConstArg value   )
{
    editMField(PropIndicesFieldMask, _mfPropIndices);

    MFUnrecFieldContainerChildGeoIntegralPropertyPtr::iterator fieldIt = _mfPropIndices.begin_nc();

    //addRef(value);

    fieldIt += uiIndex;

    _mfPropIndices.insert(fieldIt, value);

//    if(value == NullFC)
//        return;
}

void GeometryBase::replaceInPropIndices(UInt32                uiIndex,
                                                       GeoIntegralPropertyPtrConstArg value   )
{
    if(uiIndex >= _mfPropIndices.size())
        return;

    editMField(PropIndicesFieldMask, _mfPropIndices);


//    addRef(value);
//    subRef(_mfPropIndices[uiIndex]);

//    _mfPropIndices[uiIndex] = value;

      _mfPropIndices.replace(uiIndex, value);

//    if(value == NullFC)
//        return;
}

void GeometryBase::replaceInPropIndices(GeoIntegralPropertyPtrConstArg pOldElem,
                                                        GeoIntegralPropertyPtrConstArg pNewElem)
{
    Int32  elemIdx = _mfPropIndices.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(PropIndicesFieldMask, _mfPropIndices);

//        MFGeoIntegralPropertyPtr::iterator fieldIt = _mfPropIndices.begin();

//        fieldIt += elemIdx;
//        addRef(pNewElem);
//        subRef(pOldElem);

//        (*fieldIt) = pNewElem;
          _mfPropIndices.replace(elemIdx, pNewElem);
    }
}

void GeometryBase::removeFromPropIndices(UInt32 uiIndex)
{
    if(uiIndex < _mfPropIndices.size())
    {
        editMField(PropIndicesFieldMask, _mfPropIndices);

        MFUnrecFieldContainerChildGeoIntegralPropertyPtr::iterator fieldIt = _mfPropIndices.begin_nc();

        fieldIt += uiIndex;

        //subRef(*fieldIt);

        _mfPropIndices.erase(fieldIt);
    }
}

void GeometryBase::removeFromPropIndices(GeoIntegralPropertyPtrConstArg value)
{
    Int32 iElemIdx = _mfPropIndices.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(PropIndicesFieldMask, _mfPropIndices);

        MFUnrecFieldContainerChildGeoIntegralPropertyPtr::iterator fieldIt = _mfPropIndices.begin_nc();

        fieldIt += iElemIdx;

        //subRef(*fieldIt);

        _mfPropIndices.erase(fieldIt);
    }
}
void GeometryBase::clearPropIndices(void)
{
    editMField(PropIndicesFieldMask, _mfPropIndices);


    _mfPropIndices.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 GeometryBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        returnValue += _sfTypes.getBinSize();
    }
    if(FieldBits::NoField != (LengthsFieldMask & whichField))
    {
        returnValue += _sfLengths.getBinSize();
    }
    if(FieldBits::NoField != (PropertiesFieldMask & whichField))
    {
        returnValue += _mfProperties.getBinSize();
    }
    if(FieldBits::NoField != (PropIndicesFieldMask & whichField))
    {
        returnValue += _mfPropIndices.getBinSize();
    }
    if(FieldBits::NoField != (DlistCacheFieldMask & whichField))
    {
        returnValue += _sfDlistCache.getBinSize();
    }
    if(FieldBits::NoField != (ClassicGLIdFieldMask & whichField))
    {
        returnValue += _sfClassicGLId.getBinSize();
    }
    if(FieldBits::NoField != (AttGLIdFieldMask & whichField))
    {
        returnValue += _sfAttGLId.getBinSize();
    }

    return returnValue;
}

void GeometryBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _sfTypes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LengthsFieldMask & whichField))
    {
        _sfLengths.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PropertiesFieldMask & whichField))
    {
        _mfProperties.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PropIndicesFieldMask & whichField))
    {
        _mfPropIndices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DlistCacheFieldMask & whichField))
    {
        _sfDlistCache.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ClassicGLIdFieldMask & whichField))
    {
        _sfClassicGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AttGLIdFieldMask & whichField))
    {
        _sfAttGLId.copyToBin(pMem);
    }
}

void GeometryBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (TypesFieldMask & whichField))
    {
        _sfTypes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LengthsFieldMask & whichField))
    {
        _sfLengths.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PropertiesFieldMask & whichField))
    {
        _mfProperties.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PropIndicesFieldMask & whichField))
    {
        _mfPropIndices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DlistCacheFieldMask & whichField))
    {
        _sfDlistCache.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ClassicGLIdFieldMask & whichField))
    {
        _sfClassicGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AttGLIdFieldMask & whichField))
    {
        _sfAttGLId.copyFromBin(pMem);
    }
}

//! create a new instance of the class
GeometryTransitPtr GeometryBase::create(void)
{
    GeometryTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Geometry>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
GeometryTransitPtr GeometryBase::createLocal(BitVector bFlags)
{
    GeometryTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Geometry>(tmpPtr);
    }

    return fc;
}

//! create an empty new instance of the class, do not copy the prototype
GeometryPtr GeometryBase::createEmpty(void)
{
    GeometryPtr returnValue;

    newPtr<Geometry>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &= 
        ~Thread::getCurrentLocalFlags(); 

    return returnValue;
}

GeometryPtr GeometryBase::createEmptyLocal(BitVector bFlags)
{
    GeometryPtr returnValue;

    newPtr<Geometry>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr GeometryBase::shallowCopy(void) const
{
    GeometryPtr tmpPtr;

    newPtr(tmpPtr, 
           dynamic_cast<const Geometry *>(this), 
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}

FieldContainerTransitPtr GeometryBase::shallowCopyLocal(
    BitVector bFlags) const
{
    GeometryPtr tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Geometry *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

GeometryBase::GeometryBase(void) :
    Inherited(),
    _sfTypes                  (this, 
                          TypesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfLengths                (this, 
                          LengthsFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _mfProperties             (this, 
                          PropertiesFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfPropIndices            (this, 
                          PropIndicesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfDlistCache             (bool(true)),
    _sfClassicGLId            (Int32(0)),
    _sfAttGLId                (Int32(0))
{
}

GeometryBase::GeometryBase(const GeometryBase &source) :
    Inherited(source),
    _sfTypes                  (this, 
                          TypesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfLengths                (this, 
                          LengthsFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _mfProperties             (this, 
                          PropertiesFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfPropIndices            (this, 
                          PropIndicesFieldId,
                          GeoIntegralProperty::ParentsFieldId),
    _sfDlistCache             (source._sfDlistCache             ),
    _sfClassicGLId            (source._sfClassicGLId            ),
    _sfAttGLId                (source._sfAttGLId                )
{
}


/*-------------------------- destructors ----------------------------------*/

GeometryBase::~GeometryBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool GeometryBase::unlinkChild(
    const FieldContainerPtr pChild,
    const UInt16            childFieldId)
{
    if(childFieldId == TypesFieldId)
    {
        GeoIntegralPropertyPtr pTypedChild =
            dynamic_cast<GeoIntegralPropertyPtr>(pChild);
            
        if(pTypedChild != NullFC)
        {
            if(pTypedChild == _sfTypes.getValue())
            {
                editSField(TypesFieldMask);

                _sfTypes.setValue(NullFC);
                
                return true;
            }
            
            FWARNING(("GeometryBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));
            
            return false;
        }
        
        return false;
    }
    
    if(childFieldId == LengthsFieldId)
    {
        GeoIntegralPropertyPtr pTypedChild =
            dynamic_cast<GeoIntegralPropertyPtr>(pChild);
            
        if(pTypedChild != NullFC)
        {
            if(pTypedChild == _sfLengths.getValue())
            {
                editSField(LengthsFieldMask);

                _sfLengths.setValue(NullFC);
                
                return true;
            }
            
            FWARNING(("GeometryBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));
            
            return false;
        }
        
        return false;
    }
    
    if(childFieldId == PropertiesFieldId)
    {
        GeoVectorPropertyPtr pTypedChild =
            dynamic_cast<GeoVectorPropertyPtr>(pChild);
            
        if(pTypedChild != NullFC)
        {
            MFUnrecFieldContainerChildGeoVectorPropertyPtr::iterator pI =
                _mfProperties.find_nc(pTypedChild);
                
            if(pI != _mfProperties.end())
            {
                editMField(PropertiesFieldMask, _mfProperties);

                _mfProperties.erase(pI);
                
                return true;
            }
            
            FWARNING(("GeometryBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));
            
            return false;
        }
        
        return false;
    }
    
    if(childFieldId == PropIndicesFieldId)
    {
        GeoIntegralPropertyPtr pTypedChild =
            dynamic_cast<GeoIntegralPropertyPtr>(pChild);
            
        if(pTypedChild != NullFC)
        {
            MFUnrecFieldContainerChildGeoIntegralPropertyPtr::iterator pI =
                _mfPropIndices.find_nc(pTypedChild);
                
            if(pI != _mfPropIndices.end())
            {
                editMField(PropIndicesFieldMask, _mfPropIndices);

                _mfPropIndices.erase(pI);
                
                return true;
            }
            
            FWARNING(("GeometryBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));
            
            return false;
        }
        
        return false;
    }
    
    
    return Inherited::unlinkChild(pChild, childFieldId);
}

void GeometryBase::onCreate(const Geometry *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setTypes(source->getTypes());

        this->setLengths(source->getLengths());

        MFUnrecFieldContainerChildGeoVectorPropertyPtr::const_iterator PropertiesIt  =
            source->_mfProperties.begin();
        MFUnrecFieldContainerChildGeoVectorPropertyPtr::const_iterator PropertiesEnd =
            source->_mfProperties.end  ();

        while(PropertiesIt != PropertiesEnd)
        {
            this->pushToProperties(*PropertiesIt);

            ++PropertiesIt;
        }

        MFUnrecFieldContainerChildGeoIntegralPropertyPtr::const_iterator PropIndicesIt  =
            source->_mfPropIndices.begin();
        MFUnrecFieldContainerChildGeoIntegralPropertyPtr::const_iterator PropIndicesEnd =
            source->_mfPropIndices.end  ();

        while(PropIndicesIt != PropIndicesEnd)
        {
            this->pushToPropIndices(*PropIndicesIt);

            ++PropIndicesIt;
        }
    }
}

GetFieldHandlePtr GeometryBase::getHandleTypes           (void) const
{
    SFUnrecFieldContainerChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoIntegralPropertyPtr::GetHandle(
             &_sfTypes, 
             this->getType().getFieldDesc(TypesFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleTypes          (void)
{
    SFUnrecFieldContainerChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoIntegralPropertyPtr::EditHandle(
             &_sfTypes, 
             this->getType().getFieldDesc(TypesFieldId)));

    returnValue->setSetMethod(boost::bind(&Geometry::setTypes, 
                                          static_cast<Geometry *>(this), _1));

    editSField(TypesFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleLengths         (void) const
{
    SFUnrecFieldContainerChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoIntegralPropertyPtr::GetHandle(
             &_sfLengths, 
             this->getType().getFieldDesc(LengthsFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleLengths        (void)
{
    SFUnrecFieldContainerChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoIntegralPropertyPtr::EditHandle(
             &_sfLengths, 
             this->getType().getFieldDesc(LengthsFieldId)));

    returnValue->setSetMethod(boost::bind(&Geometry::setLengths, 
                                          static_cast<Geometry *>(this), _1));

    editSField(LengthsFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleProperties      (void) const
{
    MFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  MFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandle(
             &_mfProperties, 
             this->getType().getFieldDesc(PropertiesFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleProperties     (void)
{
    MFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  MFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandle(
             &_mfProperties, 
             this->getType().getFieldDesc(PropertiesFieldId)));

    returnValue->setAddMethod(boost::bind(&Geometry::pushToProperties, 
                              static_cast<Geometry *>(this), _1));

    editMField(PropertiesFieldMask, _mfProperties);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandlePropIndices     (void) const
{
    MFUnrecFieldContainerChildGeoIntegralPropertyPtr::GetHandlePtr returnValue(
        new  MFUnrecFieldContainerChildGeoIntegralPropertyPtr::GetHandle(
             &_mfPropIndices, 
             this->getType().getFieldDesc(PropIndicesFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandlePropIndices    (void)
{
    MFUnrecFieldContainerChildGeoIntegralPropertyPtr::EditHandlePtr returnValue(
        new  MFUnrecFieldContainerChildGeoIntegralPropertyPtr::EditHandle(
             &_mfPropIndices, 
             this->getType().getFieldDesc(PropIndicesFieldId)));

    returnValue->setAddMethod(boost::bind(&Geometry::pushToPropIndices, 
                              static_cast<Geometry *>(this), _1));

    editMField(PropIndicesFieldMask, _mfPropIndices);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleDlistCache      (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDlistCache, 
             this->getType().getFieldDesc(DlistCacheFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleDlistCache     (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDlistCache, 
             this->getType().getFieldDesc(DlistCacheFieldId)));

    editSField(DlistCacheFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleClassicGLId     (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfClassicGLId, 
             this->getType().getFieldDesc(ClassicGLIdFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleClassicGLId    (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfClassicGLId, 
             this->getType().getFieldDesc(ClassicGLIdFieldId)));

    editSField(ClassicGLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr GeometryBase::getHandleAttGLId         (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfAttGLId, 
             this->getType().getFieldDesc(AttGLIdFieldId)));

    return returnValue;
}

EditFieldHandlePtr GeometryBase::editHandleAttGLId        (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfAttGLId, 
             this->getType().getFieldDesc(AttGLIdFieldId)));

    editSField(AttGLIdFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void GeometryBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<GeometryBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr GeometryBase::createAspectCopy(void) const
{
    GeometryPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Geometry *>(this));

    return returnValue;
}
#endif

void GeometryBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Geometry *>(this)->setTypes(NullFC);

    static_cast<Geometry *>(this)->setLengths(NullFC);


    static_cast<Geometry *>(this)->clearProperties();
    static_cast<Geometry *>(this)->clearPropIndices();
}


#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<GeometryPtr>::_type("GeometryPtr", "MaterialDrawablePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(GeometryPtr)

OSG_EXPORT_PTR_SFIELD_FULL(FieldContainerPtrSField, 
                           GeometryPtr, 
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(FieldContainerPtrMField, 
                           GeometryPtr, 
                           0);

OSG_END_NAMESPACE
