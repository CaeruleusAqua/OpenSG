/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Particles!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGGeoVectorProperty.h> // Positions Class
#include <OSGGeoVectorProperty.h> // SecPositions Class
#include <OSGGeoVectorProperty.h> // Colors Class
#include <OSGGeoVectorProperty.h> // Normals Class

#include "OSGParticlesBase.h"
#include "OSGParticles.h"

#include "boost/bind.hpp"

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Particles
    \ingroup GrpSystemNodeCoresDrawablesParticles

    See \ref PageSystemParticles for details.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var UInt32          ParticlesBase::_sfMode
    The particle mode, see OSG::Particles::modeE for options.
*/

/*! \var GeoVectorProperty * ParticlesBase::_sfPositions
    The positions of the particles. This is the primary defining
    information for a particle.
*/

/*! \var Vec3f           ParticlesBase::_mfSizes
    The particle sizes. If not set (1,1,1) will be used, if only one entry
    is set, it will be used for all particles. If the number of sizes if
    equal to the number of positions every particle will get its own size.
    Most modes only use the X coordinate of the vector. Particles with 
    size[0] == 0 are ignored.
*/

/*! \var GeoVectorProperty * ParticlesBase::_sfSecPositions
    The secondary position of the particle. This information is only used
    by a few rendering modes, e.g. the streak mode. Usually it represents
    the particle's last position.
*/

/*! \var GeoVectorProperty * ParticlesBase::_sfColors
    The particle colors (optional).
*/

/*! \var GeoVectorProperty * ParticlesBase::_sfNormals
    Most particles will be automatically aligned to the view
    direction. If normals are set they will be used to define the
    direction the particles are facing.
*/

/*! \var Int32           ParticlesBase::_mfIndices
    Indices for the particles. Useful to select subsets of all particles for 
    rendering.
*/

/*! \var Real32          ParticlesBase::_mfTextureZs
    The texture z coordinate of the particles. Useful in conjunction with 3D 
    textures to use different texture images on different particles.
*/

/*! \var UInt32          ParticlesBase::_sfDrawOrder
    Define an optional sorting on the particles, see OSG::Particles::DrawOrderE
    for variants. Default is unordered.
*/

/*! \var bool            ParticlesBase::_sfDynamic
    Hint to tell the system whether particles are expected to change position or
    not. Is used to speed up sorting.
*/

/*! \var UInt32          ParticlesBase::_sfPump
    
*/

/*! \var ParticleBSPTree ParticlesBase::_sfBsp
    
*/

/*! \var Int32           ParticlesBase::_sfNumParticles
    Optional number of particles to use. If set to -1, all the particles in 
    pos, or indices if set, will be used.
*/


void ParticlesBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mode",
        "The particle mode, see OSG::Particles::modeE for options.\n",
        ModeFieldId, ModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleMode),
        static_cast<FieldGetMethodSig >(&Particles::getHandleMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "positions",
        "The positions of the particles. This is the primary defining\n"
        "information for a particle.\n",
        PositionsFieldId, PositionsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandlePositions),
        static_cast<FieldGetMethodSig >(&Particles::getHandlePositions));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "sizes",
        "The particle sizes. If not set (1,1,1) will be used, if only one entry\n"
        "is set, it will be used for all particles. If the number of sizes if\n"
        "equal to the number of positions every particle will get its own size.\n"
        "Most modes only use the X coordinate of the vector. Particles with \n"
        "size[0] == 0 are ignored.\n",
        SizesFieldId, SizesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleSizes),
        static_cast<FieldGetMethodSig >(&Particles::getHandleSizes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "secPositions",
        "The secondary position of the particle. This information is only used\n"
        "by a few rendering modes, e.g. the streak mode. Usually it represents\n"
        "the particle's last position.\n",
        SecPositionsFieldId, SecPositionsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleSecPositions),
        static_cast<FieldGetMethodSig >(&Particles::getHandleSecPositions));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "colors",
        "The particle colors (optional).\n",
        ColorsFieldId, ColorsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleColors),
        static_cast<FieldGetMethodSig >(&Particles::getHandleColors));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecChildGeoVectorPropertyPtr::Description(
        SFUnrecChildGeoVectorPropertyPtr::getClassType(),
        "normals",
        "Most particles will be automatically aligned to the view\n"
        "direction. If normals are set they will be used to define the\n"
        "direction the particles are facing.\n",
        NormalsFieldId, NormalsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleNormals),
        static_cast<FieldGetMethodSig >(&Particles::getHandleNormals));

    oType.addInitialDesc(pDesc);

    pDesc = new MFInt32::Description(
        MFInt32::getClassType(),
        "indices",
        "Indices for the particles. Useful to select subsets of all particles for \n"
        "rendering.\n",
        IndicesFieldId, IndicesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleIndices),
        static_cast<FieldGetMethodSig >(&Particles::getHandleIndices));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "textureZs",
        "The texture z coordinate of the particles. Useful in conjunction with 3D \n"
        "textures to use different texture images on different particles.\n",
        TextureZsFieldId, TextureZsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleTextureZs),
        static_cast<FieldGetMethodSig >(&Particles::getHandleTextureZs));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "drawOrder",
        "Define an optional sorting on the particles, see OSG::Particles::DrawOrderE\n"
        "for variants. Default is unordered.\n",
        DrawOrderFieldId, DrawOrderFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleDrawOrder),
        static_cast<FieldGetMethodSig >(&Particles::getHandleDrawOrder));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "dynamic",
        "Hint to tell the system whether particles are expected to change position or\n"
        "not. Is used to speed up sorting.\n",
        DynamicFieldId, DynamicFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleDynamic),
        static_cast<FieldGetMethodSig >(&Particles::getHandleDynamic));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "pump",
        "",
        PumpFieldId, PumpFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandlePump),
        static_cast<FieldGetMethodSig >(&Particles::getHandlePump));

    oType.addInitialDesc(pDesc);

    pDesc = new SFParticleBSPTree::Description(
        SFParticleBSPTree::getClassType(),
        "bsp",
        "",
        BspFieldId, BspFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleBsp),
        static_cast<FieldGetMethodSig >(&Particles::getHandleBsp));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numParticles",
        "Optional number of particles to use. If set to -1, all the particles in \n"
        "pos, or indices if set, will be used.\n",
        NumParticlesFieldId, NumParticlesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Particles::editHandleNumParticles),
        static_cast<FieldGetMethodSig >(&Particles::getHandleNumParticles));

    oType.addInitialDesc(pDesc);
}


ParticlesBase::TypeObject ParticlesBase::_type(
    ParticlesBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&ParticlesBase::createEmptyLocal),
    Particles::initMethod,
    Particles::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&Particles::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Particles\"\n"
    "\tparent=\"MaterialDrawable\"\n"
    "\tlibrary=\"Drawable\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    ">\n"
    "\\ingroup GrpSystemNodeCoresDrawablesParticles\n"
    "\n"
    "See \\ref PageSystemParticles for details.\n"
    "\t<Field\n"
    "\t\tname=\"mode\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"2\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe particle mode, see OSG::Particles::modeE for options.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"positions\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        The positions of the particles. This is the primary defining\n"
    "        information for a particle.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sizes\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The particle sizes. If not set (1,1,1) will be used, if only one entry\n"
    "        is set, it will be used for all particles. If the number of sizes if\n"
    "        equal to the number of positions every particle will get its own size.\n"
    "        Most modes only use the X coordinate of the vector. Particles with \n"
    "        size[0] == 0 are ignored.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"secPositions\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        The secondary position of the particle. This information is only used\n"
    "        by a few rendering modes, e.g. the streak mode. Usually it represents\n"
    "        the particle's last position.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"colors\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "\tThe particle colors (optional).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"normals\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "        linkParentField=\"Parents\"\n"
    "\t>\n"
    "        Most particles will be automatically aligned to the view\n"
    "        direction. If normals are set they will be used to define the\n"
    "        direction the particles are facing.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"indices\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Indices for the particles. Useful to select subsets of all particles for \n"
    "        rendering.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"textureZs\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The texture z coordinate of the particles. Useful in conjunction with 3D \n"
    "        textures to use different texture images on different particles.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"drawOrder\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Define an optional sorting on the particles, see OSG::Particles::DrawOrderE\n"
    "        for variants. Default is unordered.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dynamic\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Hint to tell the system whether particles are expected to change position or\n"
    "        not. Is used to speed up sorting.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pump\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"protected\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bsp\"\n"
    "\t\ttype=\"ParticleBSPTree\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\theader=\"OSGParticleBSP.h\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"numParticles\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "                defaultValue=\"-1\"\n"
    "\t>\n"
    "        Optional number of particles to use. If set to -1, all the particles in \n"
    "        pos, or indices if set, will be used.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "\\ingroup GrpSystemNodeCoresDrawablesParticles\n"
    "\n"
    "See \\ref PageSystemParticles for details.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ParticlesBase::getType(void)
{
    return _type;
}

const FieldContainerType &ParticlesBase::getType(void) const
{
    return _type;
}

UInt32 ParticlesBase::getContainerSize(void) const
{
    return sizeof(Particles);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *ParticlesBase::editSFMode(void)
{
    editSField(ModeFieldMask);

    return &_sfMode;
}

const SFUInt32 *ParticlesBase::getSFMode(void) const
{
    return &_sfMode;
}


//! Get the Particles::_sfPositions field.
const SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::getSFPositions(void) const
{
    return &_sfPositions;
}

SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::editSFPositions      (void)
{
    editSField(PositionsFieldMask);

    return &_sfPositions;
}

MFVec3f *ParticlesBase::editMFSizes(void)
{
    editMField(SizesFieldMask, _mfSizes);

    return &_mfSizes;
}

const MFVec3f *ParticlesBase::getMFSizes(void) const
{
    return &_mfSizes;
}


//! Get the Particles::_sfSecPositions field.
const SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::getSFSecPositions(void) const
{
    return &_sfSecPositions;
}

SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::editSFSecPositions   (void)
{
    editSField(SecPositionsFieldMask);

    return &_sfSecPositions;
}

//! Get the Particles::_sfColors field.
const SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::getSFColors(void) const
{
    return &_sfColors;
}

SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::editSFColors         (void)
{
    editSField(ColorsFieldMask);

    return &_sfColors;
}

//! Get the Particles::_sfNormals field.
const SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::getSFNormals(void) const
{
    return &_sfNormals;
}

SFUnrecChildGeoVectorPropertyPtr *ParticlesBase::editSFNormals        (void)
{
    editSField(NormalsFieldMask);

    return &_sfNormals;
}

MFInt32 *ParticlesBase::editMFIndices(void)
{
    editMField(IndicesFieldMask, _mfIndices);

    return &_mfIndices;
}

const MFInt32 *ParticlesBase::getMFIndices(void) const
{
    return &_mfIndices;
}


MFReal32 *ParticlesBase::editMFTextureZs(void)
{
    editMField(TextureZsFieldMask, _mfTextureZs);

    return &_mfTextureZs;
}

const MFReal32 *ParticlesBase::getMFTextureZs(void) const
{
    return &_mfTextureZs;
}


SFUInt32 *ParticlesBase::editSFDrawOrder(void)
{
    editSField(DrawOrderFieldMask);

    return &_sfDrawOrder;
}

const SFUInt32 *ParticlesBase::getSFDrawOrder(void) const
{
    return &_sfDrawOrder;
}


SFBool *ParticlesBase::editSFDynamic(void)
{
    editSField(DynamicFieldMask);

    return &_sfDynamic;
}

const SFBool *ParticlesBase::getSFDynamic(void) const
{
    return &_sfDynamic;
}


SFUInt32 *ParticlesBase::editSFPump(void)
{
    editSField(PumpFieldMask);

    return &_sfPump;
}

const SFUInt32 *ParticlesBase::getSFPump(void) const
{
    return &_sfPump;
}


SFParticleBSPTree *ParticlesBase::editSFBsp(void)
{
    editSField(BspFieldMask);

    return &_sfBsp;
}

const SFParticleBSPTree *ParticlesBase::getSFBsp(void) const
{
    return &_sfBsp;
}


SFInt32 *ParticlesBase::editSFNumParticles(void)
{
    editSField(NumParticlesFieldMask);

    return &_sfNumParticles;
}

const SFInt32 *ParticlesBase::getSFNumParticles(void) const
{
    return &_sfNumParticles;
}






/*------------------------------ access -----------------------------------*/

UInt32 ParticlesBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        returnValue += _sfMode.getBinSize();
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        returnValue += _sfPositions.getBinSize();
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        returnValue += _mfSizes.getBinSize();
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        returnValue += _sfSecPositions.getBinSize();
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        returnValue += _sfColors.getBinSize();
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        returnValue += _sfNormals.getBinSize();
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        returnValue += _mfIndices.getBinSize();
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        returnValue += _mfTextureZs.getBinSize();
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        returnValue += _sfDrawOrder.getBinSize();
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        returnValue += _sfDynamic.getBinSize();
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        returnValue += _sfPump.getBinSize();
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        returnValue += _sfBsp.getBinSize();
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        returnValue += _sfNumParticles.getBinSize();
    }

    return returnValue;
}

void ParticlesBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyToBin(pMem);
    }
}

void ParticlesBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ParticlesTransitPtr ParticlesBase::createLocal(BitVector bFlags)
{
    ParticlesTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Particles>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
ParticlesTransitPtr ParticlesBase::createDependent(BitVector bFlags)
{
    ParticlesTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Particles>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ParticlesTransitPtr ParticlesBase::create(void)
{
    ParticlesTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Particles>(tmpPtr);
    }

    return fc;
}

Particles *ParticlesBase::createEmptyLocal(BitVector bFlags)
{
    Particles *returnValue;

    newPtr<Particles>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Particles *ParticlesBase::createEmpty(void)
{
    Particles *returnValue;

    newPtr<Particles>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr ParticlesBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Particles *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Particles *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ParticlesBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Particles *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Particles *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr ParticlesBase::shallowCopy(void) const
{
    Particles *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Particles *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

ParticlesBase::ParticlesBase(void) :
    Inherited(),
    _sfMode                   (UInt32(2)),
    _sfPositions              (this,
                          PositionsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfSizes                  (),
    _sfSecPositions           (this,
                          SecPositionsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfColors                 (this,
                          ColorsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfNormals                (this,
                          NormalsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfIndices                (),
    _mfTextureZs              (),
    _sfDrawOrder              (UInt32(0)),
    _sfDynamic                (bool(true)),
    _sfPump                   (),
    _sfBsp                    (),
    _sfNumParticles           (Int32(-1))
{
}

ParticlesBase::ParticlesBase(const ParticlesBase &source) :
    Inherited(source),
    _sfMode                   (source._sfMode                   ),
    _sfPositions              (this,
                          PositionsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfSizes                  (source._mfSizes                  ),
    _sfSecPositions           (this,
                          SecPositionsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfColors                 (this,
                          ColorsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _sfNormals                (this,
                          NormalsFieldId,
                          GeoVectorProperty::ParentsFieldId),
    _mfIndices                (source._mfIndices                ),
    _mfTextureZs              (source._mfTextureZs              ),
    _sfDrawOrder              (source._sfDrawOrder              ),
    _sfDynamic                (source._sfDynamic                ),
    _sfPump                   (source._sfPump                   ),
    _sfBsp                    (source._sfBsp                    ),
    _sfNumParticles           (source._sfNumParticles           )
{
}


/*-------------------------- destructors ----------------------------------*/

ParticlesBase::~ParticlesBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool ParticlesBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == PositionsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(pTypedChild == _sfPositions.getValue())
            {
                editSField(PositionsFieldMask);

                _sfPositions.setValue(NULL);

                return true;
            }

            FWARNING(("ParticlesBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));

            return false;
        }

        return false;
    }

    if(childFieldId == SecPositionsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(pTypedChild == _sfSecPositions.getValue())
            {
                editSField(SecPositionsFieldMask);

                _sfSecPositions.setValue(NULL);

                return true;
            }

            FWARNING(("ParticlesBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));

            return false;
        }

        return false;
    }

    if(childFieldId == ColorsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(pTypedChild == _sfColors.getValue())
            {
                editSField(ColorsFieldMask);

                _sfColors.setValue(NULL);

                return true;
            }

            FWARNING(("ParticlesBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));

            return false;
        }

        return false;
    }

    if(childFieldId == NormalsFieldId)
    {
        GeoVectorProperty * pTypedChild =
            dynamic_cast<GeoVectorProperty *>(pChild);

        if(pTypedChild != NULL)
        {
            if(pTypedChild == _sfNormals.getValue())
            {
                editSField(NormalsFieldMask);

                _sfNormals.setValue(NULL);

                return true;
            }

            FWARNING(("ParticlesBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void ParticlesBase::onCreate(const Particles *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Particles *pThis = static_cast<Particles *>(this);

        pThis->setPositions(source->getPositions());

        pThis->setSecPositions(source->getSecPositions());

        pThis->setColors(source->getColors());

        pThis->setNormals(source->getNormals());
    }
}

GetFieldHandlePtr ParticlesBase::getHandleMode            (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfMode,
             this->getType().getFieldDesc(ModeFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleMode           (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfMode,
             this->getType().getFieldDesc(ModeFieldId),
             this));


    editSField(ModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandlePositions       (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfPositions,
             this->getType().getFieldDesc(PositionsFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandlePositions      (void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfPositions,
             this->getType().getFieldDesc(PositionsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Particles::setPositions,
                    static_cast<Particles *>(this), _1));

    editSField(PositionsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleSizes           (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfSizes,
             this->getType().getFieldDesc(SizesFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleSizes          (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfSizes,
             this->getType().getFieldDesc(SizesFieldId),
             this));


    editMField(SizesFieldMask, _mfSizes);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleSecPositions    (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfSecPositions,
             this->getType().getFieldDesc(SecPositionsFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleSecPositions   (void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfSecPositions,
             this->getType().getFieldDesc(SecPositionsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Particles::setSecPositions,
                    static_cast<Particles *>(this), _1));

    editSField(SecPositionsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleColors          (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfColors,
             this->getType().getFieldDesc(ColorsFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleColors         (void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfColors,
             this->getType().getFieldDesc(ColorsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Particles::setColors,
                    static_cast<Particles *>(this), _1));

    editSField(ColorsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleNormals         (void) const
{
    SFUnrecChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::GetHandle(
             &_sfNormals,
             this->getType().getFieldDesc(NormalsFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleNormals        (void)
{
    SFUnrecChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecChildGeoVectorPropertyPtr::EditHandle(
             &_sfNormals,
             this->getType().getFieldDesc(NormalsFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Particles::setNormals,
                    static_cast<Particles *>(this), _1));

    editSField(NormalsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleIndices         (void) const
{
    MFInt32::GetHandlePtr returnValue(
        new  MFInt32::GetHandle(
             &_mfIndices,
             this->getType().getFieldDesc(IndicesFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleIndices        (void)
{
    MFInt32::EditHandlePtr returnValue(
        new  MFInt32::EditHandle(
             &_mfIndices,
             this->getType().getFieldDesc(IndicesFieldId),
             this));


    editMField(IndicesFieldMask, _mfIndices);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleTextureZs       (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfTextureZs,
             this->getType().getFieldDesc(TextureZsFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleTextureZs      (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfTextureZs,
             this->getType().getFieldDesc(TextureZsFieldId),
             this));


    editMField(TextureZsFieldMask, _mfTextureZs);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleDrawOrder       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfDrawOrder,
             this->getType().getFieldDesc(DrawOrderFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleDrawOrder      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfDrawOrder,
             this->getType().getFieldDesc(DrawOrderFieldId),
             this));


    editSField(DrawOrderFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleDynamic         (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDynamic,
             this->getType().getFieldDesc(DynamicFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleDynamic        (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDynamic,
             this->getType().getFieldDesc(DynamicFieldId),
             this));


    editSField(DynamicFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandlePump            (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfPump,
             this->getType().getFieldDesc(PumpFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandlePump           (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfPump,
             this->getType().getFieldDesc(PumpFieldId),
             this));


    editSField(PumpFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleBsp             (void) const
{
    SFParticleBSPTree::GetHandlePtr returnValue(
        new  SFParticleBSPTree::GetHandle(
             &_sfBsp,
             this->getType().getFieldDesc(BspFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleBsp            (void)
{
    SFParticleBSPTree::EditHandlePtr returnValue(
        new  SFParticleBSPTree::EditHandle(
             &_sfBsp,
             this->getType().getFieldDesc(BspFieldId),
             this));


    editSField(BspFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleNumParticles    (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumParticles,
             this->getType().getFieldDesc(NumParticlesFieldId),
             const_cast<ParticlesBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleNumParticles   (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumParticles,
             this->getType().getFieldDesc(NumParticlesFieldId),
             this));


    editSField(NumParticlesFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ParticlesBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Particles *pThis = static_cast<Particles *>(this);

    pThis->execSync(static_cast<Particles *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *ParticlesBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Particles *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Particles *>(pRefAspect),
                  dynamic_cast<const Particles *>(this));

    return returnValue;
}
#endif

void ParticlesBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Particles *>(this)->setPositions(NULL);

    static_cast<Particles *>(this)->setSecPositions(NULL);

    static_cast<Particles *>(this)->setColors(NULL);

    static_cast<Particles *>(this)->setNormals(NULL);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfSizes.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfIndices.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfTextureZs.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<Particles *>::_type("ParticlesPtr", "MaterialDrawablePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(Particles *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Particles *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Particles *,
                           0);

OSG_END_NAMESPACE
