/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Particles!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILEPARTICLESINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGGeoVectorProperty.h> // Positions Class
#include <OSGGeoVectorProperty.h> // SecPositions Class
#include <OSGGeoVectorProperty.h> // Colors Class
#include <OSGGeoVectorProperty.h> // Normals Class

#include "OSGParticlesBase.h"
#include "OSGParticles.h"

#include "boost/bind.hpp"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Particles
    \ingroup GrpSystemNodeCoresDrawablesParticles

    See \ref PageSystemParticles for details.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var UInt32          ParticlesBase::_sfMode
    The particle mode, see OSG::Particles::modeE for options.
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfPositions
    The positions of the particles. This is the primary defining
    information for a particle.
*/

/*! \var Vec3f           ParticlesBase::_mfSizes
    The particle sizes. If not set (1,1,1) will be used, if only one entry
    is set, it will be used for all particles. If the number of sizes if
    equal to the number of positions every particle will get its own size.
    Most modes only use the X coordinate of the vector. Particles with 
    size[0] == 0 are ignored.
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfSecPositions
    The secondary position of the particle. This information is only used
    by a few rendering modes, e.g. the streak mode. Usually it represents
    the particle's last position.
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfColors
    The particle colors (optional).
*/

/*! \var GeoVectorPropertyPtr ParticlesBase::_sfNormals
    Most particles will be automatically aligned to the view
    direction. If normals are set they will be used to define the
    direction the particles are facing.
*/

/*! \var Int32           ParticlesBase::_mfIndices
    Indices for the particles. Useful to select subsets of all particles for 
    rendering.
*/

/*! \var Real32          ParticlesBase::_mfTextureZs
    The texture z coordinate of the particles. Useful in conjunction with 3D 
    textures to use different texture images on different particles.
*/

/*! \var UInt32          ParticlesBase::_sfDrawOrder
    Define an optional sorting on the particles, see OSG::Particles::DrawOrderE
    for variants. Default is unordered.
*/

/*! \var bool            ParticlesBase::_sfDynamic
    Hint to tell the system whether particles are expected to change position or
    not. Is used to speed up sorting.
*/

/*! \var UInt32          ParticlesBase::_sfPump
    
*/

/*! \var ParticleBSPTree ParticlesBase::_sfBsp
    
*/

/*! \var Int32           ParticlesBase::_sfNumParticles
    Optional number of particles to use. If set to -1, all the particles in 
    pos, or indices if set, will be used.
*/


void ParticlesBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mode",
        "The particle mode, see OSG::Particles::modeE for options.\n",
        ModeFieldId, ModeFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleMode),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecFieldContainerChildGeoVectorPropertyPtr::Description(
        SFUnrecFieldContainerChildGeoVectorPropertyPtr::getClassType(),
        "positions",
        "The positions of the particles. This is the primary defining\n"
        "information for a particle.\n",
        PositionsFieldId, PositionsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandlePositions),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandlePositions));

    oType.addInitialDesc(pDesc);

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "sizes",
        "The particle sizes. If not set (1,1,1) will be used, if only one entry\n"
        "is set, it will be used for all particles. If the number of sizes if\n"
        "equal to the number of positions every particle will get its own size.\n"
        "Most modes only use the X coordinate of the vector. Particles with \n"
        "size[0] == 0 are ignored.\n",
        SizesFieldId, SizesFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleSizes),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleSizes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecFieldContainerChildGeoVectorPropertyPtr::Description(
        SFUnrecFieldContainerChildGeoVectorPropertyPtr::getClassType(),
        "secPositions",
        "The secondary position of the particle. This information is only used\n"
        "by a few rendering modes, e.g. the streak mode. Usually it represents\n"
        "the particle's last position.\n",
        SecPositionsFieldId, SecPositionsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleSecPositions),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleSecPositions));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecFieldContainerChildGeoVectorPropertyPtr::Description(
        SFUnrecFieldContainerChildGeoVectorPropertyPtr::getClassType(),
        "colors",
        "The particle colors (optional).\n",
        ColorsFieldId, ColorsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleColors),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleColors));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecFieldContainerChildGeoVectorPropertyPtr::Description(
        SFUnrecFieldContainerChildGeoVectorPropertyPtr::getClassType(),
        "normals",
        "Most particles will be automatically aligned to the view\n"
        "direction. If normals are set they will be used to define the\n"
        "direction the particles are facing.\n",
        NormalsFieldId, NormalsFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleNormals),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleNormals));

    oType.addInitialDesc(pDesc);

    pDesc = new MFInt32::Description(
        MFInt32::getClassType(),
        "indices",
        "Indices for the particles. Useful to select subsets of all particles for \n"
        "rendering.\n",
        IndicesFieldId, IndicesFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleIndices),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleIndices));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "textureZs",
        "The texture z coordinate of the particles. Useful in conjunction with 3D \n"
        "textures to use different texture images on different particles.\n",
        TextureZsFieldId, TextureZsFieldMask,
        false,
        Field::MFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleTextureZs),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleTextureZs));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "drawOrder",
        "Define an optional sorting on the particles, see OSG::Particles::DrawOrderE\n"
        "for variants. Default is unordered.\n",
        DrawOrderFieldId, DrawOrderFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleDrawOrder),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleDrawOrder));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "dynamic",
        "Hint to tell the system whether particles are expected to change position or\n"
        "not. Is used to speed up sorting.\n",
        DynamicFieldId, DynamicFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleDynamic),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleDynamic));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "pump",
        "",
        PumpFieldId, PumpFieldMask,
        true,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandlePump),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandlePump));

    oType.addInitialDesc(pDesc);

    pDesc = new SFParticleBSPTree::Description(
        SFParticleBSPTree::getClassType(),
        "bsp",
        "",
        BspFieldId, BspFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleBsp),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleBsp));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "numParticles",
        "Optional number of particles to use. If set to -1, all the particles in \n"
        "pos, or indices if set, will be used.\n",
        NumParticlesFieldId, NumParticlesFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast<FieldEditMethodSig>(&ParticlesBase::editHandleNumParticles),
        static_cast<FieldGetMethodSig >(&ParticlesBase::getHandleNumParticles));

    oType.addInitialDesc(pDesc);
}


ParticlesBase::TypeObject ParticlesBase::_type(
    ParticlesBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &ParticlesBase::createEmptyLocal,
    Particles::initMethod,
    Particles::exitMethod,
    (InitalInsertDescFunc) &ParticlesBase::classDescInserter,
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"Particles\"\n"
    "\tparent=\"MaterialDrawable\"\n"
    "\tlibrary=\"Drawable\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    ">\n"
    "\\ingroup GrpSystemNodeCoresDrawablesParticles\n"
    "\n"
    "See \\ref PageSystemParticles for details.\n"
    "\t<Field\n"
    "\t\tname=\"mode\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"2\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe particle mode, see OSG::Particles::modeE for options.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"positions\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "\t>\n"
    "        The positions of the particles. This is the primary defining\n"
    "        information for a particle.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sizes\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The particle sizes. If not set (1,1,1) will be used, if only one entry\n"
    "        is set, it will be used for all particles. If the number of sizes if\n"
    "        equal to the number of positions every particle will get its own size.\n"
    "        Most modes only use the X coordinate of the vector. Particles with \n"
    "        size[0] == 0 are ignored.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"secPositions\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "\t>\n"
    "        The secondary position of the particle. This information is only used\n"
    "        by a few rendering modes, e.g. the streak mode. Usually it represents\n"
    "        the particle's last position.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"colors\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "\t>\n"
    "\tThe particle colors (optional).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"normals\"\n"
    "\t\ttype=\"GeoVectorProperty\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        category=\"childpointer\"\n"
    "        childParentType=\"FieldContainer\"\n"
    "\t>\n"
    "        Most particles will be automatically aligned to the view\n"
    "        direction. If normals are set they will be used to define the\n"
    "        direction the particles are facing.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"indices\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Indices for the particles. Useful to select subsets of all particles for \n"
    "        rendering.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"textureZs\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The texture z coordinate of the particles. Useful in conjunction with 3D \n"
    "        textures to use different texture images on different particles.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"drawOrder\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Define an optional sorting on the particles, see OSG::Particles::DrawOrderE\n"
    "        for variants. Default is unordered.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"dynamic\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Hint to tell the system whether particles are expected to change position or\n"
    "        not. Is used to speed up sorting.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pump\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"private\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bsp\"\n"
    "\t\ttype=\"ParticleBSPTree\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\theader=\"OSGParticleBSP.h\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"numParticles\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "                defaultValue=\"-1\"\n"
    "\t>\n"
    "        Optional number of particles to use. If set to -1, all the particles in \n"
    "        pos, or indices if set, will be used.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "\\ingroup GrpSystemNodeCoresDrawablesParticles\n"
    "\n"
    "See \\ref PageSystemParticles for details.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ParticlesBase::getType(void)
{
    return _type;
}

const FieldContainerType &ParticlesBase::getType(void) const
{
    return _type;
}

UInt32 ParticlesBase::getContainerSize(void) const
{
    return sizeof(Particles);
}

/*------------------------- decorator get ------------------------------*/


SFUInt32 *ParticlesBase::editSFMode(void)
{
    editSField(ModeFieldMask);

    return &_sfMode;
}

const SFUInt32 *ParticlesBase::getSFMode(void) const
{
    return &_sfMode;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ParticlesBase::getSFMode           (void)
{
    return this->editSFMode           ();
}
#endif

//! Get the Particles::_sfPositions field.
const SFUnrecFieldContainerChildGeoVectorPropertyPtr *ParticlesBase::getSFPositions(void) const
{
    return &_sfPositions;
}

MFVec3f *ParticlesBase::editMFSizes(void)
{
    editMField(SizesFieldMask, _mfSizes);

    return &_mfSizes;
}

const MFVec3f *ParticlesBase::getMFSizes(void) const
{
    return &_mfSizes;
}

#ifdef OSG_1_GET_COMPAT
MFVec3f             *ParticlesBase::getMFSizes          (void)
{
    return this->editMFSizes          ();
}
#endif

//! Get the Particles::_sfSecPositions field.
const SFUnrecFieldContainerChildGeoVectorPropertyPtr *ParticlesBase::getSFSecPositions(void) const
{
    return &_sfSecPositions;
}

//! Get the Particles::_sfColors field.
const SFUnrecFieldContainerChildGeoVectorPropertyPtr *ParticlesBase::getSFColors(void) const
{
    return &_sfColors;
}

//! Get the Particles::_sfNormals field.
const SFUnrecFieldContainerChildGeoVectorPropertyPtr *ParticlesBase::getSFNormals(void) const
{
    return &_sfNormals;
}

MFInt32 *ParticlesBase::editMFIndices(void)
{
    editMField(IndicesFieldMask, _mfIndices);

    return &_mfIndices;
}

const MFInt32 *ParticlesBase::getMFIndices(void) const
{
    return &_mfIndices;
}

#ifdef OSG_1_GET_COMPAT
MFInt32             *ParticlesBase::getMFIndices        (void)
{
    return this->editMFIndices        ();
}
#endif

MFReal32 *ParticlesBase::editMFTextureZs(void)
{
    editMField(TextureZsFieldMask, _mfTextureZs);

    return &_mfTextureZs;
}

const MFReal32 *ParticlesBase::getMFTextureZs(void) const
{
    return &_mfTextureZs;
}

#ifdef OSG_1_GET_COMPAT
MFReal32            *ParticlesBase::getMFTextureZs      (void)
{
    return this->editMFTextureZs      ();
}
#endif

SFUInt32 *ParticlesBase::editSFDrawOrder(void)
{
    editSField(DrawOrderFieldMask);

    return &_sfDrawOrder;
}

const SFUInt32 *ParticlesBase::getSFDrawOrder(void) const
{
    return &_sfDrawOrder;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ParticlesBase::getSFDrawOrder      (void)
{
    return this->editSFDrawOrder      ();
}
#endif

SFBool *ParticlesBase::editSFDynamic(void)
{
    editSField(DynamicFieldMask);

    return &_sfDynamic;
}

const SFBool *ParticlesBase::getSFDynamic(void) const
{
    return &_sfDynamic;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *ParticlesBase::getSFDynamic        (void)
{
    return this->editSFDynamic        ();
}
#endif

SFUInt32 *ParticlesBase::editSFPump(void)
{
    editSField(PumpFieldMask);

    return &_sfPump;
}

const SFUInt32 *ParticlesBase::getSFPump(void) const
{
    return &_sfPump;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *ParticlesBase::getSFPump           (void)
{
    return this->editSFPump           ();
}
#endif

SFParticleBSPTree *ParticlesBase::editSFBsp(void)
{
    editSField(BspFieldMask);

    return &_sfBsp;
}

const SFParticleBSPTree *ParticlesBase::getSFBsp(void) const
{
    return &_sfBsp;
}

#ifdef OSG_1_GET_COMPAT
SFParticleBSPTree   *ParticlesBase::getSFBsp            (void)
{
    return this->editSFBsp            ();
}
#endif

SFInt32 *ParticlesBase::editSFNumParticles(void)
{
    editSField(NumParticlesFieldMask);

    return &_sfNumParticles;
}

const SFInt32 *ParticlesBase::getSFNumParticles(void) const
{
    return &_sfNumParticles;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *ParticlesBase::getSFNumParticles   (void)
{
    return this->editSFNumParticles   ();
}
#endif





/*------------------------------ access -----------------------------------*/

UInt32 ParticlesBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        returnValue += _sfMode.getBinSize();
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        returnValue += _sfPositions.getBinSize();
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        returnValue += _mfSizes.getBinSize();
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        returnValue += _sfSecPositions.getBinSize();
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        returnValue += _sfColors.getBinSize();
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        returnValue += _sfNormals.getBinSize();
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        returnValue += _mfIndices.getBinSize();
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        returnValue += _mfTextureZs.getBinSize();
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        returnValue += _sfDrawOrder.getBinSize();
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        returnValue += _sfDynamic.getBinSize();
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        returnValue += _sfPump.getBinSize();
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        returnValue += _sfBsp.getBinSize();
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        returnValue += _sfNumParticles.getBinSize();
    }

    return returnValue;
}

void ParticlesBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyToBin(pMem);
    }
}

void ParticlesBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ModeFieldMask & whichField))
    {
        _sfMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PositionsFieldMask & whichField))
    {
        _sfPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SizesFieldMask & whichField))
    {
        _mfSizes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SecPositionsFieldMask & whichField))
    {
        _sfSecPositions.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ColorsFieldMask & whichField))
    {
        _sfColors.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NormalsFieldMask & whichField))
    {
        _sfNormals.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IndicesFieldMask & whichField))
    {
        _mfIndices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TextureZsFieldMask & whichField))
    {
        _mfTextureZs.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawOrderFieldMask & whichField))
    {
        _sfDrawOrder.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DynamicFieldMask & whichField))
    {
        _sfDynamic.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PumpFieldMask & whichField))
    {
        _sfPump.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BspFieldMask & whichField))
    {
        _sfBsp.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NumParticlesFieldMask & whichField))
    {
        _sfNumParticles.copyFromBin(pMem);
    }
}

void ParticlesBase::subChildPointer(FieldContainerPtr pObj, 
                                        UInt16            usFieldPos)
{
    if(usFieldPos == PositionsFieldId)
    {
        if(_sfPositions.getValue() == pObj)
        {
            editSField(PositionsFieldMask);

            _sfPositions.setValue(NullFC);
        }
    }
    else if(usFieldPos == SecPositionsFieldId)
    {
        if(_sfSecPositions.getValue() == pObj)
        {
            editSField(SecPositionsFieldMask);

            _sfSecPositions.setValue(NullFC);
        }
    }
    else if(usFieldPos == ColorsFieldId)
    {
        if(_sfColors.getValue() == pObj)
        {
            editSField(ColorsFieldMask);

            _sfColors.setValue(NullFC);
        }
    }
    else if(usFieldPos == NormalsFieldId)
    {
        if(_sfNormals.getValue() == pObj)
        {
            editSField(NormalsFieldMask);

            _sfNormals.setValue(NullFC);
        }
    }
    else
    {
        Inherited::subChildPointer(pObj, usFieldPos);
    }
}


//! create a new instance of the class
ParticlesTransitPtr ParticlesBase::create(void)
{
    ParticlesTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Particles>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ParticlesTransitPtr ParticlesBase::createLocal(BitVector bFlags)
{
    ParticlesTransitPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Particles>(tmpPtr);
    }

    return fc;
}

//! create an empty new instance of the class, do not copy the prototype
ParticlesPtr ParticlesBase::createEmpty(void)
{
    ParticlesPtr returnValue;

    newPtr<Particles>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &= 
        ~Thread::getCurrentLocalFlags(); 

    return returnValue;
}

ParticlesPtr ParticlesBase::createEmptyLocal(BitVector bFlags)
{
    ParticlesPtr returnValue;

    newPtr<Particles>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ParticlesBase::shallowCopy(void) const
{
    ParticlesPtr tmpPtr;

    newPtr(tmpPtr, 
           dynamic_cast<const Particles *>(this), 
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}

FieldContainerTransitPtr ParticlesBase::shallowCopyLocal(
    BitVector bFlags) const
{
    ParticlesPtr tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Particles *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

ParticlesBase::ParticlesBase(void) :
    Inherited(),
    _sfMode                   (UInt32(2)),
    _sfPositions              (this, PositionsFieldId),
    _mfSizes                  (),
    _sfSecPositions           (this, SecPositionsFieldId),
    _sfColors                 (this, ColorsFieldId),
    _sfNormals                (this, NormalsFieldId),
    _mfIndices                (),
    _mfTextureZs              (),
    _sfDrawOrder              (UInt32(0)),
    _sfDynamic                (bool(true)),
    _sfPump                   (),
    _sfBsp                    (),
    _sfNumParticles           (Int32(-1))
{
}

ParticlesBase::ParticlesBase(const ParticlesBase &source) :
    Inherited(source),
    _sfMode                   (source._sfMode                   ),
    _sfPositions              (this, PositionsFieldId),
    _mfSizes                  (source._mfSizes                  ),
    _sfSecPositions           (this, SecPositionsFieldId),
    _sfColors                 (this, ColorsFieldId),
    _sfNormals                (this, NormalsFieldId),
    _mfIndices                (source._mfIndices                ),
    _mfTextureZs              (source._mfTextureZs              ),
    _sfDrawOrder              (source._sfDrawOrder              ),
    _sfDynamic                (source._sfDynamic                ),
    _sfPump                   (source._sfPump                   ),
    _sfBsp                    (source._sfBsp                    ),
    _sfNumParticles           (source._sfNumParticles           )
{
}


/*-------------------------- destructors ----------------------------------*/

ParticlesBase::~ParticlesBase(void)
{
}

void ParticlesBase::onCreate(const Particles *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setPositions(source->getPositions());

        this->setSecPositions(source->getSecPositions());

        this->setColors(source->getColors());

        this->setNormals(source->getNormals());
    }
}

GetFieldHandlePtr ParticlesBase::getHandleMode            (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfMode, 
             this->getType().getFieldDesc(ModeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleMode           (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfMode, 
             this->getType().getFieldDesc(ModeFieldId)));

    editSField(ModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandlePositions       (void) const
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandle(
             &_sfPositions, 
             this->getType().getFieldDesc(PositionsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandlePositions      (void)
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandle(
             &_sfPositions, 
             this->getType().getFieldDesc(PositionsFieldId)));

    returnValue->setSetMethod(boost::bind(&Particles::setPositions, 
                                          static_cast<Particles *>(this), _1));

    editSField(PositionsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleSizes           (void) const
{
    MFVec3f::GetHandlePtr returnValue(
        new  MFVec3f::GetHandle(
             &_mfSizes, 
             this->getType().getFieldDesc(SizesFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleSizes          (void)
{
    MFVec3f::EditHandlePtr returnValue(
        new  MFVec3f::EditHandle(
             &_mfSizes, 
             this->getType().getFieldDesc(SizesFieldId)));

    editMField(SizesFieldMask, _mfSizes);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleSecPositions    (void) const
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandle(
             &_sfSecPositions, 
             this->getType().getFieldDesc(SecPositionsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleSecPositions   (void)
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandle(
             &_sfSecPositions, 
             this->getType().getFieldDesc(SecPositionsFieldId)));

    returnValue->setSetMethod(boost::bind(&Particles::setSecPositions, 
                                          static_cast<Particles *>(this), _1));

    editSField(SecPositionsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleColors          (void) const
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandle(
             &_sfColors, 
             this->getType().getFieldDesc(ColorsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleColors         (void)
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandle(
             &_sfColors, 
             this->getType().getFieldDesc(ColorsFieldId)));

    returnValue->setSetMethod(boost::bind(&Particles::setColors, 
                                          static_cast<Particles *>(this), _1));

    editSField(ColorsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleNormals         (void) const
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::GetHandle(
             &_sfNormals, 
             this->getType().getFieldDesc(NormalsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleNormals        (void)
{
    SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandlePtr returnValue(
        new  SFUnrecFieldContainerChildGeoVectorPropertyPtr::EditHandle(
             &_sfNormals, 
             this->getType().getFieldDesc(NormalsFieldId)));

    returnValue->setSetMethod(boost::bind(&Particles::setNormals, 
                                          static_cast<Particles *>(this), _1));

    editSField(NormalsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleIndices         (void) const
{
    MFInt32::GetHandlePtr returnValue(
        new  MFInt32::GetHandle(
             &_mfIndices, 
             this->getType().getFieldDesc(IndicesFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleIndices        (void)
{
    MFInt32::EditHandlePtr returnValue(
        new  MFInt32::EditHandle(
             &_mfIndices, 
             this->getType().getFieldDesc(IndicesFieldId)));

    editMField(IndicesFieldMask, _mfIndices);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleTextureZs       (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfTextureZs, 
             this->getType().getFieldDesc(TextureZsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleTextureZs      (void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfTextureZs, 
             this->getType().getFieldDesc(TextureZsFieldId)));

    editMField(TextureZsFieldMask, _mfTextureZs);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleDrawOrder       (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfDrawOrder, 
             this->getType().getFieldDesc(DrawOrderFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleDrawOrder      (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfDrawOrder, 
             this->getType().getFieldDesc(DrawOrderFieldId)));

    editSField(DrawOrderFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleDynamic         (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDynamic, 
             this->getType().getFieldDesc(DynamicFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleDynamic        (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDynamic, 
             this->getType().getFieldDesc(DynamicFieldId)));

    editSField(DynamicFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandlePump            (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfPump, 
             this->getType().getFieldDesc(PumpFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandlePump           (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfPump, 
             this->getType().getFieldDesc(PumpFieldId)));

    editSField(PumpFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleBsp             (void) const
{
    SFParticleBSPTree::GetHandlePtr returnValue(
        new  SFParticleBSPTree::GetHandle(
             &_sfBsp, 
             this->getType().getFieldDesc(BspFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleBsp            (void)
{
    SFParticleBSPTree::EditHandlePtr returnValue(
        new  SFParticleBSPTree::EditHandle(
             &_sfBsp, 
             this->getType().getFieldDesc(BspFieldId)));

    editSField(BspFieldMask);

    return returnValue;
}

GetFieldHandlePtr ParticlesBase::getHandleNumParticles    (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfNumParticles, 
             this->getType().getFieldDesc(NumParticlesFieldId)));

    return returnValue;
}

EditFieldHandlePtr ParticlesBase::editHandleNumParticles   (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfNumParticles, 
             this->getType().getFieldDesc(NumParticlesFieldId)));

    editSField(NumParticlesFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ParticlesBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<ParticlesBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr ParticlesBase::createAspectCopy(void) const
{
    ParticlesPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Particles *>(this));

    return returnValue;
}
#endif

void ParticlesBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Particles *>(this)->setPositions(NullFC);

    static_cast<Particles *>(this)->setSecPositions(NullFC);

    static_cast<Particles *>(this)->setColors(NullFC);

    static_cast<Particles *>(this)->setNormals(NullFC);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfSizes.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfIndices.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
#ifdef OSG_MT_CPTR_ASPECT
    _mfTextureZs.terminateShare(Thread::getCurrentAspect(), 
                                      oOffsets);
#endif
}


#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ParticlesPtr>::_type("ParticlesPtr", "MaterialDrawablePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ParticlesPtr)

OSG_EXPORT_PTR_SFIELD_FULL(FieldContainerPtrSField, 
                           ParticlesPtr, 
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(FieldContainerPtrMField, 
                           ParticlesPtr, 
                           0);

OSG_END_NAMESPACE
