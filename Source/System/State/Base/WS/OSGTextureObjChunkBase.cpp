/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureObjChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILETEXTUREOBJCHUNKINST

#include <stdlib.h>
#include <stdio.h>

#include <OSGConfig.h>


#include <OSGGL.h>   // InternalFormat default header
#include <OSGGL.h>   // ExternalFormat default header
#include <OSGGL.h>   // MinFilter default header
#include <OSGGL.h>   // MagFilter default header
#include <OSGGL.h>   // WrapS default header
#include <OSGGL.h>   // WrapT default header
#include <OSGGL.h>   // WrapR default header
#include <OSGGL.h>   // CompareMode default header
#include <OSGGL.h>   // CompareFunc default header
#include <OSGGL.h>   // DepthMode default header

#include <OSGImage.h> // Image Class

#include "OSGTextureObjChunkBase.h"
#include "OSGTextureObjChunk.h"

OSG_USING_NAMESPACE

// Field descriptions

/*! \var ImagePtr TextureObjChunkBase::_sfImage
    
*/
/*! \var GLenum TextureObjChunkBase::_sfInternalFormat
    	The internal texture format.

*/
/*! \var GLenum TextureObjChunkBase::_sfExternalFormat
    	    The external texture format - overwrites 
        external format of image when set to a value not equal to 
        GL_NONE (which is the default).

*/
/*! \var bool TextureObjChunkBase::_sfScale
            Specifies whether the image should be scaled to the next power of two,
        thus filling the whole texture coordinate range, or if it should be put
        in the lower left corner, leaving the rest of the texture undefined.
        This is mainly used for rapidly changing non power of two textures, to
        get around the scaling overhead.

*/
/*! \var UInt32 TextureObjChunkBase::_sfFrame
            Select the frame of the image to be used. See osg::Image about details
        concerning multi-frame images.
        \hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap
        creation is slow right now. \endhint

*/
/*! \var GLenum TextureObjChunkBase::_sfMinFilter
            The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.

*/
/*! \var GLenum TextureObjChunkBase::_sfMagFilter
            The magnification filter, default GL_LINEAR.

*/
/*! \var GLenum TextureObjChunkBase::_sfWrapS
            Texture coordinate S wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureObjChunkBase::_sfWrapT
            Texture coordinate T wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureObjChunkBase::_sfWrapR
            Texture coordinate R wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureObjChunkBase::_sfGLId
            The OpenGL texture id for this texture.

*/
/*! \var Int32 TextureObjChunkBase::_sfIgnoreGLForAspect
    	    Don't do any GL calls for aspect of given id.

*/
/*! \var Real32 TextureObjChunkBase::_sfPriority
            Priority of this texture, between 0 and 1, the default is 0.
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyLeft
            Left coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMinX
            Minimum X coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMaxX
            Maximum X coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMinY
            Minimum Y coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMaxY
            Maximum Y coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMinZ
            Minimum Z coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMaxZ
            Maximum Z coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Real32 TextureObjChunkBase::_sfAnisotropy
            Anisotropic filtering the default 1.0f means isotropic filtering.
        

*/
/*! \var Color4f TextureObjChunkBase::_sfBorderColor
    	Texture border color

*/
/*! \var GLenum TextureObjChunkBase::_sfCompareMode
    
*/
/*! \var GLenum TextureObjChunkBase::_sfCompareFunc
    
*/
/*! \var GLenum TextureObjChunkBase::_sfDepthMode
    
*/

void TextureObjChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL; 


    pDesc = new SFImagePtr::Description(
        SFImagePtr::getClassType(), 
        "image", 
        ImageFieldId, ImageFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&TextureObjChunkBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFImage));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFInternalFormatF)(void) const;

    GetSFInternalFormatF GetSFInternalFormat = &TextureObjChunkBase::getSFInternalFormat;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "internalFormat", 
        InternalFormatFieldId, InternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFInternalFormat),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFInternalFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFInternalFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFExternalFormatF)(void) const;

    GetSFExternalFormatF GetSFExternalFormat = &TextureObjChunkBase::getSFExternalFormat;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "externalFormat", 
        ExternalFormatFieldId, ExternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFExternalFormat),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFExternalFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFExternalFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(TextureObjChunkBase::*GetSFScaleF)(void) const;

    GetSFScaleF GetSFScale = &TextureObjChunkBase::getSFScale;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "scale", 
        ScaleFieldId, ScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFScale),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFScale));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFScale));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(TextureObjChunkBase::*GetSFFrameF)(void) const;

    GetSFFrameF GetSFFrame = &TextureObjChunkBase::getSFFrame;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "frame", 
        FrameFieldId, FrameFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFFrame),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrame));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFFrame));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFMinFilterF)(void) const;

    GetSFMinFilterF GetSFMinFilter = &TextureObjChunkBase::getSFMinFilter;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "minFilter", 
        MinFilterFieldId, MinFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFMinFilter),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMinFilter));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFMinFilter));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFMagFilterF)(void) const;

    GetSFMagFilterF GetSFMagFilter = &TextureObjChunkBase::getSFMagFilter;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "magFilter", 
        MagFilterFieldId, MagFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFMagFilter),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMagFilter));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFMagFilter));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFWrapSF)(void) const;

    GetSFWrapSF GetSFWrapS = &TextureObjChunkBase::getSFWrapS;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapS", 
        WrapSFieldId, WrapSFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapS),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapS));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapS));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFWrapTF)(void) const;

    GetSFWrapTF GetSFWrapT = &TextureObjChunkBase::getSFWrapT;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapT", 
        WrapTFieldId, WrapTFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapT),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapT));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapT));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFWrapRF)(void) const;

    GetSFWrapRF GetSFWrapR = &TextureObjChunkBase::getSFWrapR;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapR", 
        WrapRFieldId, WrapRFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapR),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapR));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapR));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFGLIdF)(void) const;

    GetSFGLIdF GetSFGLId = &TextureObjChunkBase::getSFGLId;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "GLId", 
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFGLId),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFGLId));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFGLId));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFIgnoreGLForAspectF)(void) const;

    GetSFIgnoreGLForAspectF GetSFIgnoreGLForAspect = &TextureObjChunkBase::getSFIgnoreGLForAspect;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "IgnoreGLForAspect", 
        IgnoreGLForAspectFieldId, IgnoreGLForAspectFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFIgnoreGLForAspect),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFIgnoreGLForAspect));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFIgnoreGLForAspect));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureObjChunkBase::*GetSFPriorityF)(void) const;

    GetSFPriorityF GetSFPriority = &TextureObjChunkBase::getSFPriority;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "priority", 
        PriorityFieldId, PriorityFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFPriority),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPriority));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFPriority));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyLeftF)(void) const;

    GetSFDirtyLeftF GetSFDirtyLeft = &TextureObjChunkBase::getSFDirtyLeft;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyLeft", 
        DirtyLeftFieldId, DirtyLeftFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyLeft),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyLeft));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyLeft));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMinXF)(void) const;

    GetSFDirtyMinXF GetSFDirtyMinX = &TextureObjChunkBase::getSFDirtyMinX;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinX", 
        DirtyMinXFieldId, DirtyMinXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinX),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinX));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinX));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMaxXF)(void) const;

    GetSFDirtyMaxXF GetSFDirtyMaxX = &TextureObjChunkBase::getSFDirtyMaxX;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxX", 
        DirtyMaxXFieldId, DirtyMaxXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxX),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxX));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxX));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMinYF)(void) const;

    GetSFDirtyMinYF GetSFDirtyMinY = &TextureObjChunkBase::getSFDirtyMinY;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinY", 
        DirtyMinYFieldId, DirtyMinYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinY),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinY));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinY));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMaxYF)(void) const;

    GetSFDirtyMaxYF GetSFDirtyMaxY = &TextureObjChunkBase::getSFDirtyMaxY;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxY", 
        DirtyMaxYFieldId, DirtyMaxYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxY),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxY));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxY));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMinZF)(void) const;

    GetSFDirtyMinZF GetSFDirtyMinZ = &TextureObjChunkBase::getSFDirtyMinZ;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinZ", 
        DirtyMinZFieldId, DirtyMinZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinZ),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinZ));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinZ));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMaxZF)(void) const;

    GetSFDirtyMaxZF GetSFDirtyMaxZ = &TextureObjChunkBase::getSFDirtyMaxZ;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxZ", 
        DirtyMaxZFieldId, DirtyMaxZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxZ),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxZ));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxZ));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFReal32 *(TextureObjChunkBase::*GetSFAnisotropyF)(void) const;

    GetSFAnisotropyF GetSFAnisotropy = &TextureObjChunkBase::getSFAnisotropy;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "anisotropy", 
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFAnisotropy),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFAnisotropy));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFAnisotropy));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFColor4f *(TextureObjChunkBase::*GetSFBorderColorF)(void) const;

    GetSFBorderColorF GetSFBorderColor = &TextureObjChunkBase::getSFBorderColor;
#endif

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(), 
        "borderColor", 
        BorderColorFieldId, BorderColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFBorderColor),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBorderColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFBorderColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFCompareModeF)(void) const;

    GetSFCompareModeF GetSFCompareMode = &TextureObjChunkBase::getSFCompareMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "compareMode", 
        CompareModeFieldId, CompareModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFCompareMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFCompareMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFCompareMode));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFCompareFuncF)(void) const;

    GetSFCompareFuncF GetSFCompareFunc = &TextureObjChunkBase::getSFCompareFunc;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "compareFunc", 
        CompareFuncFieldId, CompareFuncFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFCompareFunc),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFCompareFunc));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFCompareFunc));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFDepthModeF)(void) const;

    GetSFDepthModeF GetSFDepthMode = &TextureObjChunkBase::getSFDepthMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "depthMode", 
        DepthModeFieldId, DepthModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDepthMode),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDepthMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDepthMode));
#endif

    oType.addInitialDesc(pDesc);
}


TextureObjChunkBase::TypeObject TextureObjChunkBase::_type(true,
    TextureObjChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &TextureObjChunkBase::createEmpty,
    TextureObjChunk::initMethod,
    (InitalInsertDescFunc) &TextureObjChunkBase::classDescInserter,
    false);

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureObjChunkBase::getType(void) 
{
    return _type; 
} 

const FieldContainerType &TextureObjChunkBase::getType(void) const 
{
    return _type;
} 

UInt32 TextureObjChunkBase::getContainerSize(void) const 
{ 
    return sizeof(TextureObjChunk); 
}

/*------------------------- decorator get ------------------------------*/


//! Get the TextureObjChunk::_sfImage field.
const SFImagePtr *TextureObjChunkBase::getSFImage(void) const
{
    return &_sfImage;
}

SFGLenum *TextureObjChunkBase::editSFInternalFormat(void)
{
    editSField(InternalFormatFieldMask);

    return &_sfInternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFInternalFormat(void) const
{
    return &_sfInternalFormat;
}

SFGLenum *TextureObjChunkBase::editSFExternalFormat(void)
{
    editSField(ExternalFormatFieldMask);

    return &_sfExternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFExternalFormat(void) const
{
    return &_sfExternalFormat;
}

SFBool *TextureObjChunkBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFBool *TextureObjChunkBase::getSFScale(void) const
{
    return &_sfScale;
}

SFUInt32 *TextureObjChunkBase::editSFFrame(void)
{
    editSField(FrameFieldMask);

    return &_sfFrame;
}

const SFUInt32 *TextureObjChunkBase::getSFFrame(void) const
{
    return &_sfFrame;
}

SFGLenum *TextureObjChunkBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}

SFGLenum *TextureObjChunkBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}

SFGLenum *TextureObjChunkBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *TextureObjChunkBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}

SFGLenum *TextureObjChunkBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *TextureObjChunkBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}

SFGLenum *TextureObjChunkBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *TextureObjChunkBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}

SFGLenum *TextureObjChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *TextureObjChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}

SFInt32 *TextureObjChunkBase::editSFIgnoreGLForAspect(void)
{
    editSField(IgnoreGLForAspectFieldMask);

    return &_sfIgnoreGLForAspect;
}

const SFInt32 *TextureObjChunkBase::getSFIgnoreGLForAspect(void) const
{
    return &_sfIgnoreGLForAspect;
}

SFReal32 *TextureObjChunkBase::editSFPriority(void)
{
    editSField(PriorityFieldMask);

    return &_sfPriority;
}

const SFReal32 *TextureObjChunkBase::getSFPriority(void) const
{
    return &_sfPriority;
}

SFInt32 *TextureObjChunkBase::editSFDirtyLeft(void)
{
    editSField(DirtyLeftFieldMask);

    return &_sfDirtyLeft;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyLeft(void) const
{
    return &_sfDirtyLeft;
}

SFInt32 *TextureObjChunkBase::editSFDirtyMinX(void)
{
    editSField(DirtyMinXFieldMask);

    return &_sfDirtyMinX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinX(void) const
{
    return &_sfDirtyMinX;
}

SFInt32 *TextureObjChunkBase::editSFDirtyMaxX(void)
{
    editSField(DirtyMaxXFieldMask);

    return &_sfDirtyMaxX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxX(void) const
{
    return &_sfDirtyMaxX;
}

SFInt32 *TextureObjChunkBase::editSFDirtyMinY(void)
{
    editSField(DirtyMinYFieldMask);

    return &_sfDirtyMinY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinY(void) const
{
    return &_sfDirtyMinY;
}

SFInt32 *TextureObjChunkBase::editSFDirtyMaxY(void)
{
    editSField(DirtyMaxYFieldMask);

    return &_sfDirtyMaxY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxY(void) const
{
    return &_sfDirtyMaxY;
}

SFInt32 *TextureObjChunkBase::editSFDirtyMinZ(void)
{
    editSField(DirtyMinZFieldMask);

    return &_sfDirtyMinZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinZ(void) const
{
    return &_sfDirtyMinZ;
}

SFInt32 *TextureObjChunkBase::editSFDirtyMaxZ(void)
{
    editSField(DirtyMaxZFieldMask);

    return &_sfDirtyMaxZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxZ(void) const
{
    return &_sfDirtyMaxZ;
}

SFReal32 *TextureObjChunkBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *TextureObjChunkBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}

SFColor4f *TextureObjChunkBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *TextureObjChunkBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}

SFGLenum *TextureObjChunkBase::editSFCompareMode(void)
{
    editSField(CompareModeFieldMask);

    return &_sfCompareMode;
}

const SFGLenum *TextureObjChunkBase::getSFCompareMode(void) const
{
    return &_sfCompareMode;
}

SFGLenum *TextureObjChunkBase::editSFCompareFunc(void)
{
    editSField(CompareFuncFieldMask);

    return &_sfCompareFunc;
}

const SFGLenum *TextureObjChunkBase::getSFCompareFunc(void) const
{
    return &_sfCompareFunc;
}

SFGLenum *TextureObjChunkBase::editSFDepthMode(void)
{
    editSField(DepthModeFieldMask);

    return &_sfDepthMode;
}

const SFGLenum *TextureObjChunkBase::getSFDepthMode(void) const
{
    return &_sfDepthMode;
}


void TextureObjChunkBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureObjChunk *>(this)->setImage(
            cast_dynamic<ImagePtr>(pNewElement));
    }
}

void TextureObjChunkBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void TextureObjChunkBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void TextureObjChunkBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void TextureObjChunkBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void TextureObjChunkBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void TextureObjChunkBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureObjChunk *>(this)->setImage(NullFC);
    }
}



/*------------------------------ access -----------------------------------*/

UInt32 TextureObjChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        returnValue += _sfImage.getBinSize();
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        returnValue += _sfFrame.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        returnValue += _sfIgnoreGLForAspect.getBinSize();
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        returnValue += _sfPriority.getBinSize();
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        returnValue += _sfDirtyLeft.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        returnValue += _sfDirtyMinX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        returnValue += _sfDirtyMinY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        returnValue += _sfDirtyMinZ.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxZ.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        returnValue += _sfCompareMode.getBinSize();
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        returnValue += _sfCompareFunc.getBinSize();
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        returnValue += _sfDepthMode.getBinSize();
    }

    return returnValue;
}

void TextureObjChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyToBin(pMem);
    }
}

void TextureObjChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
TextureObjChunkPtr TextureObjChunkBase::createEmpty(void) 
{ 
    TextureObjChunkPtr returnValue; 
    
    newPtr<TextureObjChunk>(returnValue); 

    return returnValue; 
}

FieldContainerPtr TextureObjChunkBase::shallowCopy(void) const 
{ 
    TextureObjChunkPtr returnValue; 

    newPtr(returnValue, dynamic_cast<const TextureObjChunk *>(this)); 

    return returnValue; 
}



/*------------------------- constructors ----------------------------------*/

TextureObjChunkBase::TextureObjChunkBase(void) :
    Inherited(),
    _sfImage(),
    _sfInternalFormat(GLenum(GL_NONE)),
    _sfExternalFormat(GLenum(GL_NONE)),
    _sfScale(bool(true)),
    _sfFrame(UInt32(0)),
    _sfMinFilter(GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter(GLenum(GL_LINEAR)),
    _sfWrapS(GLenum(GL_REPEAT)),
    _sfWrapT(GLenum(GL_REPEAT)),
    _sfWrapR(GLenum(GL_REPEAT)),
    _sfGLId(GLenum(0)),
    _sfIgnoreGLForAspect(Int32(-1)),
    _sfPriority(Real32(1.f)),
    _sfDirtyLeft(Int32(-1)),
    _sfDirtyMinX(Int32(-1)),
    _sfDirtyMaxX(Int32(-1)),
    _sfDirtyMinY(Int32(-1)),
    _sfDirtyMaxY(Int32(-1)),
    _sfDirtyMinZ(Int32(-1)),
    _sfDirtyMaxZ(Int32(-1)),
    _sfAnisotropy(Real32(1.0f)),
    _sfBorderColor(Color4f(0,0,0,0)),
    _sfCompareMode(GLenum(GL_NONE)),
    _sfCompareFunc(GLenum(GL_LEQUAL)),
    _sfDepthMode(GLenum(GL_LUMINANCE))
{
}

TextureObjChunkBase::TextureObjChunkBase(const TextureObjChunkBase &source) :
    Inherited(source),
    _sfImage(),
    _sfInternalFormat(source._sfInternalFormat),
    _sfExternalFormat(source._sfExternalFormat),
    _sfScale(source._sfScale),
    _sfFrame(source._sfFrame),
    _sfMinFilter(source._sfMinFilter),
    _sfMagFilter(source._sfMagFilter),
    _sfWrapS(source._sfWrapS),
    _sfWrapT(source._sfWrapT),
    _sfWrapR(source._sfWrapR),
    _sfGLId(source._sfGLId),
    _sfIgnoreGLForAspect(source._sfIgnoreGLForAspect),
    _sfPriority(source._sfPriority),
    _sfDirtyLeft(source._sfDirtyLeft),
    _sfDirtyMinX(source._sfDirtyMinX),
    _sfDirtyMaxX(source._sfDirtyMaxX),
    _sfDirtyMinY(source._sfDirtyMinY),
    _sfDirtyMaxY(source._sfDirtyMaxY),
    _sfDirtyMinZ(source._sfDirtyMinZ),
    _sfDirtyMaxZ(source._sfDirtyMaxZ),
    _sfAnisotropy(source._sfAnisotropy),
    _sfBorderColor(source._sfBorderColor),
    _sfCompareMode(source._sfCompareMode),
    _sfCompareFunc(source._sfCompareFunc),
    _sfDepthMode(source._sfDepthMode)
{
}

/*-------------------------- destructors ----------------------------------*/

TextureObjChunkBase::~TextureObjChunkBase(void)
{
}

void TextureObjChunkBase::onCreate(const TextureObjChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setImage(source->getImage());
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void TextureObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<TextureObjChunkBase *>(&oFrom),
                   whichField, 
                   syncMode, 
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void TextureObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<TextureObjChunkBase *>(&oFrom), 
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void TextureObjChunkBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr TextureObjChunkBase::createAspectCopy(void) const
{
    TextureObjChunkPtr returnValue; 

    newAspectCopy(returnValue, 
                  dynamic_cast<const TextureObjChunk *>(this)); 

    return returnValue; 
}
#endif

void TextureObjChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TextureObjChunk *>(this)->setImage(NullFC);
}


#include "OSGSField.ins"
#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGSFieldFuncs.ins"
#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<TextureObjChunkPtr>::_type("TextureObjChunkPtr", "TextureBaseChunkPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(TextureObjChunkPtr)

OSG_FIELD_DLLEXPORT_DEF1(SField, TextureObjChunkPtr);
OSG_FIELD_DLLEXPORT_DEF1(MField, TextureObjChunkPtr);

OSG_END_NAMESPACE


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id: $";
    static Char8 cvsid_hpp       [] = OSGTEXTUREOBJCHUNKBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGTEXTUREOBJCHUNKBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGTEXTUREOBJCHUNKFIELDS_HEADER_CVSID;
}
