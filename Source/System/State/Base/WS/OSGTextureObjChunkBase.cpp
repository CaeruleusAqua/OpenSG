/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureObjChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILETEXTUREOBJCHUNKINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>                        // InternalFormat default header
#include <OSGGL.h>                        // ExternalFormat default header
#include <OSGGL.h>                        // MinFilter default header
#include <OSGGL.h>                        // MagFilter default header
#include <OSGGL.h>                        // WrapS default header
#include <OSGGL.h>                        // WrapT default header
#include <OSGGL.h>                        // WrapR default header
#include <OSGGL.h>                        // CompareMode default header
#include <OSGGL.h>                        // CompareFunc default header
#include <OSGGL.h>                        // DepthMode default header

#include <OSGImage.h> // Image Class

#include "OSGTextureObjChunkBase.h"
#include "OSGTextureObjChunk.h"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::TextureObjChunk
    \ingroup GrpSystemState

    See \ref PageSystemTextureObjChunk for a description.

    This chunk wraps glTexImage[123]D (osg::TextureObjChunk::_sfImage,
    osg::TextureObjChunk::_sfInternalFormat, osg::TextureObjChunk::_sfExternalFormat),
    glTexParameter (osg::TextureObjChunk::_sfMinFilter,
    osg::TextureObjChunk::_sfMagFilter, osg::TextureObjChunk::_sfWrapS,
    osg::TextureObjChunk::_sfWrapT, osg::TextureObjChunk::_sfWrapR), glTexEnv
    (osg::TextureObjChunk::_sfEnvMode, osg::TextureObjChunk::_sfEnvColor,
    osg::TextureObjChunk::_sfPriority).

    The ARB combine extension is also supported,
    where available (osg::TextureObjChunk::_sfEnvCombineRGB,
    osg::TextureObjChunk::_sfEnvScaleRGB, osg::TextureObjChunk::_sfEnvSource0RGB,
    osg::TextureObjChunk::_sfEnvSource1RGB, osg::TextureObjChunk::_sfEnvSource2RGB,
    osg::TextureObjChunk::_sfEnvOperand0RGB, osg::TextureObjChunk::_sfEnvOperand1RGB,
    osg::TextureObjChunk::_sfEnvOperand2RGB,
    osg::TextureObjChunk::_sfEnvCombineAlpha,   osg::TextureObjChunk::_sfEnvScaleAlpha,
    osg::TextureObjChunk::_sfEnvSource0Alpha, osg::TextureObjChunk::_sfEnvSource1Alpha,
    osg::TextureObjChunk::_sfEnvSource2Alpha, osg::TextureObjChunk::_sfEnvOperand0Alpha,
    osg::TextureObjChunk::_sfEnvOperand1Alpha,
    osg::TextureObjChunk::_sfEnvOperand2Alpha).

    It is possible to enable the point
    sprite coordinate replacement  (osg::TextureObjChunk::_sfPointSprite), see \ref
    PageSystemPointChunk for details. The two parameters
    osg::TextureObjChunk::_sfScale and osg::TextureObjChunk::_sfFrame specify details
    about the texture.

    On hardware that supports it (i.e. NVidia boards) the texture shader
    extension(s) are also available.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var ImagePtr        TextureObjChunkBase::_sfImage
    The texture image.
*/

/*! \var GLenum          TextureObjChunkBase::_sfInternalFormat
    The internal texture format.
*/

/*! \var GLenum          TextureObjChunkBase::_sfExternalFormat
    The external texture format - overwrites 
    external format of image when set to a value not equal to 
    GL_NONE (which is the default).
*/

/*! \var bool            TextureObjChunkBase::_sfScale
    Specifies whether the image should be scaled to the next power of two,
    thus filling the whole texture coordinate range, or if it should be put
    in the lower left corner, leaving the rest of the texture undefined.
    This is mainly used for rapidly changing non power of two textures, to
    get around the scaling overhead.
*/

/*! \var UInt32          TextureObjChunkBase::_sfFrame
    Select the frame of the image to be used. See osg::Image about details
    concerning multi-frame images.
    @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now.
*/

/*! \var GLenum          TextureObjChunkBase::_sfMinFilter
    The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.
*/

/*! \var GLenum          TextureObjChunkBase::_sfMagFilter
    The magnification filter, default GL_LINEAR.
*/

/*! \var GLenum          TextureObjChunkBase::_sfWrapS
    Texture coordinate S wrapping, default GL_REPEAT.
*/

/*! \var GLenum          TextureObjChunkBase::_sfWrapT
    Texture coordinate T wrapping, default GL_REPEAT.
*/

/*! \var GLenum          TextureObjChunkBase::_sfWrapR
    Texture coordinate R wrapping, default GL_REPEAT.
*/

/*! \var GLenum          TextureObjChunkBase::_sfGLId
    The OpenGL texture id for this texture.
*/

/*! \var Int32           TextureObjChunkBase::_sfIgnoreGLForAspect
    Don't do any GL calls for aspect of given id.
*/

/*! \var Real32          TextureObjChunkBase::_sfPriority
    Priority of this texture, between 0 and 1, the default is 0.  (GL_TEXTURE_PRIORITY)
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyLeft
    Left coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMinX
    Minimum X coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMaxX
    Maximum X coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMinY
    Minimum Y coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMaxY
    Maximum Y coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMinZ
    Minimum Z coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMaxZ
    Maximum Z coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Real32          TextureObjChunkBase::_sfAnisotropy
    Anisotropic filtering the default 1.0f means isotropic filtering.
*/

/*! \var Color4f         TextureObjChunkBase::_sfBorderColor
    Texture border color
*/

/*! \var GLenum          TextureObjChunkBase::_sfCompareMode
    
*/

/*! \var GLenum          TextureObjChunkBase::_sfCompareFunc
    
*/

/*! \var GLenum          TextureObjChunkBase::_sfDepthMode
    
*/

/*! \var UInt32          TextureObjChunkBase::_sfBorderWidth
    Texture border width in pixels.
*/

/*! \var UInt32          TextureObjChunkBase::_sfNPOTMatrixScale
    Use the texture matrix to scale the texture coordinates for NPOT images. Only used if neither rectangular nor NPOT textures are supported. If set to false, the image is scaled to the next power of two before being used as a texture. For convenience xFlip/ yFlip can also be set. Note that this will interfere with other TextureTransform and TexGen chunks. Do not use it if you need to use those chunks!
*/


void TextureObjChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFImagePtr::Description(
        SFImagePtr::getClassType(),
        "image",
        "The texture image.\n",
        ImageFieldId, ImageFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&TextureObjChunkBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFImage));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFInternalFormatF)(void) const;

    GetSFInternalFormatF GetSFInternalFormat = &TextureObjChunkBase::getSFInternalFormat;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "internalFormat",
        "The internal texture format.\n",
        InternalFormatFieldId, InternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFInternalFormat),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFInternalFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFInternalFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFExternalFormatF)(void) const;

    GetSFExternalFormatF GetSFExternalFormat = &TextureObjChunkBase::getSFExternalFormat;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "externalFormat",
        "The external texture format - overwrites \n"
        "external format of image when set to a value not equal to \n"
        "GL_NONE (which is the default).\n",
        ExternalFormatFieldId, ExternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFExternalFormat),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFExternalFormat));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFExternalFormat));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFBool *(TextureObjChunkBase::*GetSFScaleF)(void) const;

    GetSFScaleF GetSFScale = &TextureObjChunkBase::getSFScale;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "scale",
        "Specifies whether the image should be scaled to the next power of two,\n"
        "thus filling the whole texture coordinate range, or if it should be put\n"
        "in the lower left corner, leaving the rest of the texture undefined.\n"
        "This is mainly used for rapidly changing non power of two textures, to\n"
        "get around the scaling overhead.\n",
        ScaleFieldId, ScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFScale),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFScale));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFScale));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(TextureObjChunkBase::*GetSFFrameF)(void) const;

    GetSFFrameF GetSFFrame = &TextureObjChunkBase::getSFFrame;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "frame",
        "Select the frame of the image to be used. See osg::Image about details\n"
        "concerning multi-frame images.\n"
        "@hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now.\n",
        FrameFieldId, FrameFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFFrame),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFFrame));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFFrame));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFMinFilterF)(void) const;

    GetSFMinFilterF GetSFMinFilter = &TextureObjChunkBase::getSFMinFilter;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "minFilter",
        "The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n",
        MinFilterFieldId, MinFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFMinFilter),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMinFilter));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFMinFilter));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFMagFilterF)(void) const;

    GetSFMagFilterF GetSFMagFilter = &TextureObjChunkBase::getSFMagFilter;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "magFilter",
        "The magnification filter, default GL_LINEAR.\n",
        MagFilterFieldId, MagFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFMagFilter),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFMagFilter));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFMagFilter));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFWrapSF)(void) const;

    GetSFWrapSF GetSFWrapS = &TextureObjChunkBase::getSFWrapS;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapS",
        "Texture coordinate S wrapping, default GL_REPEAT.\n",
        WrapSFieldId, WrapSFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapS),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapS));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapS));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFWrapTF)(void) const;

    GetSFWrapTF GetSFWrapT = &TextureObjChunkBase::getSFWrapT;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapT",
        "Texture coordinate T wrapping, default GL_REPEAT.\n",
        WrapTFieldId, WrapTFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapT),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapT));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapT));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFWrapRF)(void) const;

    GetSFWrapRF GetSFWrapR = &TextureObjChunkBase::getSFWrapR;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapR",
        "Texture coordinate R wrapping, default GL_REPEAT.\n",
        WrapRFieldId, WrapRFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapR),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFWrapR));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapR));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFGLIdF)(void) const;

    GetSFGLIdF GetSFGLId = &TextureObjChunkBase::getSFGLId;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "GLId",
        "The OpenGL texture id for this texture.\n",
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFGLId),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFGLId));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFGLId));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFIgnoreGLForAspectF)(void) const;

    GetSFIgnoreGLForAspectF GetSFIgnoreGLForAspect = &TextureObjChunkBase::getSFIgnoreGLForAspect;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "IgnoreGLForAspect",
        "Don't do any GL calls for aspect of given id.\n",
        IgnoreGLForAspectFieldId, IgnoreGLForAspectFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFIgnoreGLForAspect),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFIgnoreGLForAspect));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFIgnoreGLForAspect));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFReal32 *(TextureObjChunkBase::*GetSFPriorityF)(void) const;

    GetSFPriorityF GetSFPriority = &TextureObjChunkBase::getSFPriority;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "priority",
        "Priority of this texture, between 0 and 1, the default is 0.  (GL_TEXTURE_PRIORITY)\n",
        PriorityFieldId, PriorityFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFPriority),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFPriority));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFPriority));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyLeftF)(void) const;

    GetSFDirtyLeftF GetSFDirtyLeft = &TextureObjChunkBase::getSFDirtyLeft;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyLeft",
        "Left coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyLeftFieldId, DirtyLeftFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyLeft),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyLeft));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyLeft));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMinXF)(void) const;

    GetSFDirtyMinXF GetSFDirtyMinX = &TextureObjChunkBase::getSFDirtyMinX;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMinX",
        "Minimum X coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMinXFieldId, DirtyMinXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinX),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinX));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinX));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMaxXF)(void) const;

    GetSFDirtyMaxXF GetSFDirtyMaxX = &TextureObjChunkBase::getSFDirtyMaxX;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMaxX",
        "Maximum X coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMaxXFieldId, DirtyMaxXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxX),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxX));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxX));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMinYF)(void) const;

    GetSFDirtyMinYF GetSFDirtyMinY = &TextureObjChunkBase::getSFDirtyMinY;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMinY",
        "Minimum Y coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMinYFieldId, DirtyMinYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinY),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinY));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinY));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMaxYF)(void) const;

    GetSFDirtyMaxYF GetSFDirtyMaxY = &TextureObjChunkBase::getSFDirtyMaxY;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMaxY",
        "Maximum Y coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMaxYFieldId, DirtyMaxYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxY),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxY));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxY));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMinZF)(void) const;

    GetSFDirtyMinZF GetSFDirtyMinZ = &TextureObjChunkBase::getSFDirtyMinZ;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMinZ",
        "Minimum Z coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMinZFieldId, DirtyMinZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinZ),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMinZ));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinZ));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFInt32 *(TextureObjChunkBase::*GetSFDirtyMaxZF)(void) const;

    GetSFDirtyMaxZF GetSFDirtyMaxZ = &TextureObjChunkBase::getSFDirtyMaxZ;
#endif

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMaxZ",
        "Maximum Z coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMaxZFieldId, DirtyMaxZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxZ),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDirtyMaxZ));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxZ));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFReal32 *(TextureObjChunkBase::*GetSFAnisotropyF)(void) const;

    GetSFAnisotropyF GetSFAnisotropy = &TextureObjChunkBase::getSFAnisotropy;
#endif

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "anisotropy",
        "Anisotropic filtering the default 1.0f means isotropic filtering.\n",
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFAnisotropy),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFAnisotropy));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFAnisotropy));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFColor4f *(TextureObjChunkBase::*GetSFBorderColorF)(void) const;

    GetSFBorderColorF GetSFBorderColor = &TextureObjChunkBase::getSFBorderColor;
#endif

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(),
        "borderColor",
        "Texture border color\n",
        BorderColorFieldId, BorderColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFBorderColor),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBorderColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFBorderColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFCompareModeF)(void) const;

    GetSFCompareModeF GetSFCompareMode = &TextureObjChunkBase::getSFCompareMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "compareMode",
        "",
        CompareModeFieldId, CompareModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFCompareMode),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFCompareMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFCompareMode));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFCompareFuncF)(void) const;

    GetSFCompareFuncF GetSFCompareFunc = &TextureObjChunkBase::getSFCompareFunc;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "compareFunc",
        "",
        CompareFuncFieldId, CompareFuncFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFCompareFunc),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFCompareFunc));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFCompareFunc));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFGLenum *(TextureObjChunkBase::*GetSFDepthModeF)(void) const;

    GetSFDepthModeF GetSFDepthMode = &TextureObjChunkBase::getSFDepthMode;
#endif

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthMode",
        "",
        DepthModeFieldId, DepthModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDepthMode),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFDepthMode));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDepthMode));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(TextureObjChunkBase::*GetSFBorderWidthF)(void) const;

    GetSFBorderWidthF GetSFBorderWidth = &TextureObjChunkBase::getSFBorderWidth;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "borderWidth",
        "Texture border width in pixels.\n",
        BorderWidthFieldId, BorderWidthFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFBorderWidth),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBorderWidth));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFBorderWidth));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_GET_COMPAT
    typedef const SFUInt32 *(TextureObjChunkBase::*GetSFNPOTMatrixScaleF)(void) const;

    GetSFNPOTMatrixScaleF GetSFNPOTMatrixScale = &TextureObjChunkBase::getSFNPOTMatrixScale;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "NPOTMatrixScale",
        "Use the texture matrix to scale the texture coordinates for NPOT images. Only used if neither rectangular nor NPOT textures are supported. If set to false, the image is scaled to the next power of two before being used as a texture. For convenience xFlip/ yFlip can also be set. Note that this will interfere with other TextureTransform and TexGen chunks. Do not use it if you need to use those chunks!\n",
        NPOTMatrixScaleFieldId, NPOTMatrixScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFNPOTMatrixScale),
#ifdef OSG_1_GET_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFNPOTMatrixScale));
#else
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFNPOTMatrixScale));
#endif

    oType.addInitialDesc(pDesc);
}


TextureObjChunkBase::TypeObject TextureObjChunkBase::_type(
    TextureObjChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &TextureObjChunkBase::createEmpty,
    TextureObjChunk::initMethod,
    (InitalInsertDescFunc) &TextureObjChunkBase::classDescInserter,
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"TextureObjChunk\"\n"
    "\tparent=\"TextureBaseChunk\"\n"
    "\tlibrary=\"System\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    ">\n"
    "\\ingroup GrpSystemState\n"
    "\n"
    "See \\ref PageSystemTextureObjChunk for a description.\n"
    "\n"
    "This chunk wraps glTexImage[123]D (osg::TextureObjChunk::_sfImage,\n"
    "osg::TextureObjChunk::_sfInternalFormat, osg::TextureObjChunk::_sfExternalFormat),\n"
    "glTexParameter (osg::TextureObjChunk::_sfMinFilter,\n"
    "osg::TextureObjChunk::_sfMagFilter, osg::TextureObjChunk::_sfWrapS,\n"
    "osg::TextureObjChunk::_sfWrapT, osg::TextureObjChunk::_sfWrapR), glTexEnv\n"
    "(osg::TextureObjChunk::_sfEnvMode, osg::TextureObjChunk::_sfEnvColor,\n"
    "osg::TextureObjChunk::_sfPriority).\n"
    "\n"
    "The ARB combine extension is also supported,\n"
    "where available (osg::TextureObjChunk::_sfEnvCombineRGB,\n"
    "osg::TextureObjChunk::_sfEnvScaleRGB, osg::TextureObjChunk::_sfEnvSource0RGB,\n"
    "osg::TextureObjChunk::_sfEnvSource1RGB, osg::TextureObjChunk::_sfEnvSource2RGB,\n"
    "osg::TextureObjChunk::_sfEnvOperand0RGB, osg::TextureObjChunk::_sfEnvOperand1RGB,\n"
    "osg::TextureObjChunk::_sfEnvOperand2RGB,\n"
    "osg::TextureObjChunk::_sfEnvCombineAlpha,   osg::TextureObjChunk::_sfEnvScaleAlpha,\n"
    "osg::TextureObjChunk::_sfEnvSource0Alpha, osg::TextureObjChunk::_sfEnvSource1Alpha,\n"
    "osg::TextureObjChunk::_sfEnvSource2Alpha, osg::TextureObjChunk::_sfEnvOperand0Alpha,\n"
    "osg::TextureObjChunk::_sfEnvOperand1Alpha,\n"
    "osg::TextureObjChunk::_sfEnvOperand2Alpha).\n"
    "\n"
    "It is possible to enable the point\n"
    "sprite coordinate replacement  (osg::TextureObjChunk::_sfPointSprite), see \\ref\n"
    "PageSystemPointChunk for details. The two parameters\n"
    "osg::TextureObjChunk::_sfScale and osg::TextureObjChunk::_sfFrame specify details\n"
    "about the texture.\n"
    "\n"
    "On hardware that supports it (i.e. NVidia boards) the texture shader\n"
    "extension(s) are also available.\n"
    "\t<Field\n"
    "\t\tname=\"image\"\n"
    "\t\ttype=\"ImagePtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "        linkMParent=\"true\"\n"
    "\t>\n"
    "\tThe texture image.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"internalFormat\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_NONE,GL_ALPHA, GL_DEPTH_COMPONENT, GL_LUMINANCE, GL_LUMINANCE_ALPH, GL_INTENSITY, GL_RGB, GL_RGBA, COMPRESSED_ALPHA, COMPRESSED_LUMINANCE, COMPRESSED_LUMINANCE_ALPHA, COMPRESSED_RGB, COMPRESSED_RGBA\"\n"
    "\t>\n"
    "\tThe internal texture format.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"externalFormat\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_NONE,GL_DEPTH_COMPONENT, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_RGBA, GL_BGR, GL_BGRA, GL_LUMINANCE, GL_LUMINANCE_ALPHA\"\n"
    "\t>\n"
    "\t    The external texture format - overwrites \n"
    "        external format of image when set to a value not equal to \n"
    "        GL_NONE (which is the default).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"scale\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Specifies whether the image should be scaled to the next power of two,\n"
    "        thus filling the whole texture coordinate range, or if it should be put\n"
    "        in the lower left corner, leaving the rest of the texture undefined.\n"
    "        This is mainly used for rapidly changing non power of two textures, to\n"
    "        get around the scaling overhead.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frame\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Select the frame of the image to be used. See osg::Image about details\n"
    "        concerning multi-frame images.\n"
    "        @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"minFilter\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LINEAR_MIPMAP_LINEAR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_NEAREST, GL_LINEAR, GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR\"\n"
    "\t>\n"
    "        The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"magFilter\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LINEAR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_NEAREST, GL_LINEAR\"\n"
    "\t>\n"
    "        The magnification filter, default GL_LINEAR.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"wrapS\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPEAT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_CLAMP, GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP_TO_BORDER, GL_MIRRORED_REPEAT\"\n"
    "\t>\n"
    "        Texture coordinate S wrapping, default GL_REPEAT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"wrapT\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPEAT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_CLAMP, GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP_TO_BORDER, GL_MIRRORED_REPEAT\"                \n"
    "\t>\n"
    "        Texture coordinate T wrapping, default GL_REPEAT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"wrapR\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPEAT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_CLAMP, GL_CLAMP_TO_EDGE, GL_REPEAT, GL_CLAMP_TO_BORDER, GL_MIRRORED_REPEAT\"                \n"
    "\t>\n"
    "        Texture coordinate R wrapping, default GL_REPEAT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"GLId\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "        The OpenGL texture id for this texture.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"IgnoreGLForAspect\"\n"
    "\t\ttype=\"Int32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\tdefaultValue=\"-1\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t    Don't do any GL calls for aspect of given id.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"priority\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"1.f\"\n"
    "\t>\n"
    "        Priority of this texture, between 0 and 1, the default is 0.  (GL_TEXTURE_PRIORITY)\n"
    "\t</Field>\n"
    "    <Field\n"
    "        name=\"dirtyLeft\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Left coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMinX\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Minimum X coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMaxX\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Maximum X coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMinY\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Minimum Y coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMaxY\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Maximum Y coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMinZ\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Minimum Z coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMaxZ\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Maximum Z coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"anisotropy\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.0f\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Anisotropic filtering the default 1.0f means isotropic filtering.\n"
    "        </Field>\n"
    "\t<Field\n"
    "\t\tname=\"borderColor\"\n"
    "\t\ttype=\"Color4f\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0,0,0,0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture border color\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"compareMode\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_NONE, GL_COMPARE_R_TO_TEXTURE\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"compareFunc\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LEQUAL\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_LEQUAL, GL_GEQUAL, GL_LESS, GL_GREATER, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS, GL_NEVER\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"depthMode\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LUMINANCE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "                potential_values=\"GL_LUMINANCE, GL_INTENSITY, GL_ALPHA\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"borderWidth\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture border width in pixels.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"NPOTMatrixScale\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tUse the texture matrix to scale the texture coordinates for NPOT images. Only used if neither rectangular nor NPOT textures are supported. If set to false, the image is scaled to the next power of two before being used as a texture. For convenience xFlip/ yFlip can also be set. Note that this will interfere with other TextureTransform and TexGen chunks. Do not use it if you need to use those chunks!\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "\\ingroup GrpSystemState\n"
    "\n"
    "See \\ref PageSystemTextureObjChunk for a description.\n"
    "\n"
    "This chunk wraps glTexImage[123]D (osg::TextureObjChunk::_sfImage,\n"
    "osg::TextureObjChunk::_sfInternalFormat, osg::TextureObjChunk::_sfExternalFormat),\n"
    "glTexParameter (osg::TextureObjChunk::_sfMinFilter,\n"
    "osg::TextureObjChunk::_sfMagFilter, osg::TextureObjChunk::_sfWrapS,\n"
    "osg::TextureObjChunk::_sfWrapT, osg::TextureObjChunk::_sfWrapR), glTexEnv\n"
    "(osg::TextureObjChunk::_sfEnvMode, osg::TextureObjChunk::_sfEnvColor,\n"
    "osg::TextureObjChunk::_sfPriority).\n"
    "\n"
    "The ARB combine extension is also supported,\n"
    "where available (osg::TextureObjChunk::_sfEnvCombineRGB,\n"
    "osg::TextureObjChunk::_sfEnvScaleRGB, osg::TextureObjChunk::_sfEnvSource0RGB,\n"
    "osg::TextureObjChunk::_sfEnvSource1RGB, osg::TextureObjChunk::_sfEnvSource2RGB,\n"
    "osg::TextureObjChunk::_sfEnvOperand0RGB, osg::TextureObjChunk::_sfEnvOperand1RGB,\n"
    "osg::TextureObjChunk::_sfEnvOperand2RGB,\n"
    "osg::TextureObjChunk::_sfEnvCombineAlpha,   osg::TextureObjChunk::_sfEnvScaleAlpha,\n"
    "osg::TextureObjChunk::_sfEnvSource0Alpha, osg::TextureObjChunk::_sfEnvSource1Alpha,\n"
    "osg::TextureObjChunk::_sfEnvSource2Alpha, osg::TextureObjChunk::_sfEnvOperand0Alpha,\n"
    "osg::TextureObjChunk::_sfEnvOperand1Alpha,\n"
    "osg::TextureObjChunk::_sfEnvOperand2Alpha).\n"
    "\n"
    "It is possible to enable the point\n"
    "sprite coordinate replacement  (osg::TextureObjChunk::_sfPointSprite), see \\ref\n"
    "PageSystemPointChunk for details. The two parameters\n"
    "osg::TextureObjChunk::_sfScale and osg::TextureObjChunk::_sfFrame specify details\n"
    "about the texture.\n"
    "\n"
    "On hardware that supports it (i.e. NVidia boards) the texture shader\n"
    "extension(s) are also available.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureObjChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &TextureObjChunkBase::getType(void) const
{
    return _type;
}

UInt32 TextureObjChunkBase::getContainerSize(void) const
{
    return sizeof(TextureObjChunk);
}

/*------------------------- decorator get ------------------------------*/


//! Get the TextureObjChunk::_sfImage field.
const SFImagePtr *TextureObjChunkBase::getSFImage(void) const
{
    return &_sfImage;
}

SFGLenum *TextureObjChunkBase::editSFInternalFormat(void)
{
    editSField(InternalFormatFieldMask);

    return &_sfInternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFInternalFormat(void) const
{
    return &_sfInternalFormat;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFInternalFormat (void)
{
    return this->editSFInternalFormat ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFExternalFormat(void)
{
    editSField(ExternalFormatFieldMask);

    return &_sfExternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFExternalFormat(void) const
{
    return &_sfExternalFormat;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFExternalFormat (void)
{
    return this->editSFExternalFormat ();
}
#endif

SFBool *TextureObjChunkBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFBool *TextureObjChunkBase::getSFScale(void) const
{
    return &_sfScale;
}

#ifdef OSG_1_GET_COMPAT
SFBool              *TextureObjChunkBase::getSFScale          (void)
{
    return this->editSFScale          ();
}
#endif

SFUInt32 *TextureObjChunkBase::editSFFrame(void)
{
    editSField(FrameFieldMask);

    return &_sfFrame;
}

const SFUInt32 *TextureObjChunkBase::getSFFrame(void) const
{
    return &_sfFrame;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *TextureObjChunkBase::getSFFrame          (void)
{
    return this->editSFFrame          ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFMinFilter      (void)
{
    return this->editSFMinFilter      ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFMagFilter      (void)
{
    return this->editSFMagFilter      ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *TextureObjChunkBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFWrapS          (void)
{
    return this->editSFWrapS          ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *TextureObjChunkBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFWrapT          (void)
{
    return this->editSFWrapT          ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *TextureObjChunkBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFWrapR          (void)
{
    return this->editSFWrapR          ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *TextureObjChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFGLId           (void)
{
    return this->editSFGLId           ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFIgnoreGLForAspect(void)
{
    editSField(IgnoreGLForAspectFieldMask);

    return &_sfIgnoreGLForAspect;
}

const SFInt32 *TextureObjChunkBase::getSFIgnoreGLForAspect(void) const
{
    return &_sfIgnoreGLForAspect;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFIgnoreGLForAspect(void)
{
    return this->editSFIgnoreGLForAspect();
}
#endif

SFReal32 *TextureObjChunkBase::editSFPriority(void)
{
    editSField(PriorityFieldMask);

    return &_sfPriority;
}

const SFReal32 *TextureObjChunkBase::getSFPriority(void) const
{
    return &_sfPriority;
}

#ifdef OSG_1_GET_COMPAT
SFReal32            *TextureObjChunkBase::getSFPriority       (void)
{
    return this->editSFPriority       ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyLeft(void)
{
    editSField(DirtyLeftFieldMask);

    return &_sfDirtyLeft;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyLeft(void) const
{
    return &_sfDirtyLeft;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyLeft      (void)
{
    return this->editSFDirtyLeft      ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyMinX(void)
{
    editSField(DirtyMinXFieldMask);

    return &_sfDirtyMinX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinX(void) const
{
    return &_sfDirtyMinX;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyMinX      (void)
{
    return this->editSFDirtyMinX      ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyMaxX(void)
{
    editSField(DirtyMaxXFieldMask);

    return &_sfDirtyMaxX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxX(void) const
{
    return &_sfDirtyMaxX;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyMaxX      (void)
{
    return this->editSFDirtyMaxX      ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyMinY(void)
{
    editSField(DirtyMinYFieldMask);

    return &_sfDirtyMinY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinY(void) const
{
    return &_sfDirtyMinY;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyMinY      (void)
{
    return this->editSFDirtyMinY      ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyMaxY(void)
{
    editSField(DirtyMaxYFieldMask);

    return &_sfDirtyMaxY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxY(void) const
{
    return &_sfDirtyMaxY;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyMaxY      (void)
{
    return this->editSFDirtyMaxY      ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyMinZ(void)
{
    editSField(DirtyMinZFieldMask);

    return &_sfDirtyMinZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinZ(void) const
{
    return &_sfDirtyMinZ;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyMinZ      (void)
{
    return this->editSFDirtyMinZ      ();
}
#endif

SFInt32 *TextureObjChunkBase::editSFDirtyMaxZ(void)
{
    editSField(DirtyMaxZFieldMask);

    return &_sfDirtyMaxZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxZ(void) const
{
    return &_sfDirtyMaxZ;
}

#ifdef OSG_1_GET_COMPAT
SFInt32             *TextureObjChunkBase::getSFDirtyMaxZ      (void)
{
    return this->editSFDirtyMaxZ      ();
}
#endif

SFReal32 *TextureObjChunkBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *TextureObjChunkBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}

#ifdef OSG_1_GET_COMPAT
SFReal32            *TextureObjChunkBase::getSFAnisotropy     (void)
{
    return this->editSFAnisotropy     ();
}
#endif

SFColor4f *TextureObjChunkBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *TextureObjChunkBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}

#ifdef OSG_1_GET_COMPAT
SFColor4f           *TextureObjChunkBase::getSFBorderColor    (void)
{
    return this->editSFBorderColor    ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFCompareMode(void)
{
    editSField(CompareModeFieldMask);

    return &_sfCompareMode;
}

const SFGLenum *TextureObjChunkBase::getSFCompareMode(void) const
{
    return &_sfCompareMode;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFCompareMode    (void)
{
    return this->editSFCompareMode    ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFCompareFunc(void)
{
    editSField(CompareFuncFieldMask);

    return &_sfCompareFunc;
}

const SFGLenum *TextureObjChunkBase::getSFCompareFunc(void) const
{
    return &_sfCompareFunc;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFCompareFunc    (void)
{
    return this->editSFCompareFunc    ();
}
#endif

SFGLenum *TextureObjChunkBase::editSFDepthMode(void)
{
    editSField(DepthModeFieldMask);

    return &_sfDepthMode;
}

const SFGLenum *TextureObjChunkBase::getSFDepthMode(void) const
{
    return &_sfDepthMode;
}

#ifdef OSG_1_GET_COMPAT
SFGLenum            *TextureObjChunkBase::getSFDepthMode      (void)
{
    return this->editSFDepthMode      ();
}
#endif

SFUInt32 *TextureObjChunkBase::editSFBorderWidth(void)
{
    editSField(BorderWidthFieldMask);

    return &_sfBorderWidth;
}

const SFUInt32 *TextureObjChunkBase::getSFBorderWidth(void) const
{
    return &_sfBorderWidth;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *TextureObjChunkBase::getSFBorderWidth    (void)
{
    return this->editSFBorderWidth    ();
}
#endif

SFUInt32 *TextureObjChunkBase::editSFNPOTMatrixScale(void)
{
    editSField(NPOTMatrixScaleFieldMask);

    return &_sfNPOTMatrixScale;
}

const SFUInt32 *TextureObjChunkBase::getSFNPOTMatrixScale(void) const
{
    return &_sfNPOTMatrixScale;
}

#ifdef OSG_1_GET_COMPAT
SFUInt32            *TextureObjChunkBase::getSFNPOTMatrixScale(void)
{
    return this->editSFNPOTMatrixScale();
}
#endif


void TextureObjChunkBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureObjChunk *>(this)->setImage(
            dynamic_cast<ImagePtr>(pNewElement));
    }
}

void TextureObjChunkBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void TextureObjChunkBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void TextureObjChunkBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void TextureObjChunkBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void TextureObjChunkBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void TextureObjChunkBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureObjChunk *>(this)->setImage(NullFC);
    }
}



/*------------------------------ access -----------------------------------*/

UInt32 TextureObjChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        returnValue += _sfImage.getBinSize();
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        returnValue += _sfFrame.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        returnValue += _sfIgnoreGLForAspect.getBinSize();
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        returnValue += _sfPriority.getBinSize();
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        returnValue += _sfDirtyLeft.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        returnValue += _sfDirtyMinX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        returnValue += _sfDirtyMinY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        returnValue += _sfDirtyMinZ.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxZ.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        returnValue += _sfCompareMode.getBinSize();
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        returnValue += _sfCompareFunc.getBinSize();
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        returnValue += _sfDepthMode.getBinSize();
    }
    if(FieldBits::NoField != (BorderWidthFieldMask & whichField))
    {
        returnValue += _sfBorderWidth.getBinSize();
    }
    if(FieldBits::NoField != (NPOTMatrixScaleFieldMask & whichField))
    {
        returnValue += _sfNPOTMatrixScale.getBinSize();
    }

    return returnValue;
}

void TextureObjChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderWidthFieldMask & whichField))
    {
        _sfBorderWidth.copyToBin(pMem);
    }
    if(FieldBits::NoField != (NPOTMatrixScaleFieldMask & whichField))
    {
        _sfNPOTMatrixScale.copyToBin(pMem);
    }
}

void TextureObjChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderWidthFieldMask & whichField))
    {
        _sfBorderWidth.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (NPOTMatrixScaleFieldMask & whichField))
    {
        _sfNPOTMatrixScale.copyFromBin(pMem);
    }
}

//! create a new instance of the class
TextureObjChunkPtr TextureObjChunkBase::create(void)
{
    TextureObjChunkPtr fc;

    if(getClassType().getPrototype() != NullFC)
    {
        fc = dynamic_cast<TextureObjChunk::ObjPtr>(
            getClassType().getPrototype()-> shallowCopy());
    }

    return fc;
}

//! create an empty new instance of the class, do not copy the prototype
TextureObjChunkPtr TextureObjChunkBase::createEmpty(void)
{
    TextureObjChunkPtr returnValue;

    newPtr<TextureObjChunk>(returnValue);

    return returnValue;
}

FieldContainerPtr TextureObjChunkBase::shallowCopy(void) const
{
    TextureObjChunkPtr returnValue;

    newPtr(returnValue, dynamic_cast<const TextureObjChunk *>(this));

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

TextureObjChunkBase::TextureObjChunkBase(void) :
    Inherited(),
    _sfImage                  (NullFC),
    _sfInternalFormat         (GLenum(GL_NONE)),
    _sfExternalFormat         (GLenum(GL_NONE)),
    _sfScale                  (bool(true)),
    _sfFrame                  (UInt32(0)),
    _sfMinFilter              (GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter              (GLenum(GL_LINEAR)),
    _sfWrapS                  (GLenum(GL_REPEAT)),
    _sfWrapT                  (GLenum(GL_REPEAT)),
    _sfWrapR                  (GLenum(GL_REPEAT)),
    _sfGLId                   (GLenum(0)),
    _sfIgnoreGLForAspect      (Int32(-1)),
    _sfPriority               (Real32(1.f)),
    _sfDirtyLeft              (Int32(-1)),
    _sfDirtyMinX              (Int32(-1)),
    _sfDirtyMaxX              (Int32(-1)),
    _sfDirtyMinY              (Int32(-1)),
    _sfDirtyMaxY              (Int32(-1)),
    _sfDirtyMinZ              (Int32(-1)),
    _sfDirtyMaxZ              (Int32(-1)),
    _sfAnisotropy             (Real32(1.0f)),
    _sfBorderColor            (Color4f(0,0,0,0)),
    _sfCompareMode            (GLenum(GL_NONE)),
    _sfCompareFunc            (GLenum(GL_LEQUAL)),
    _sfDepthMode              (GLenum(GL_LUMINANCE)),
    _sfBorderWidth            (UInt32(0)),
    _sfNPOTMatrixScale        (UInt32(0))
{
}

TextureObjChunkBase::TextureObjChunkBase(const TextureObjChunkBase &source) :
    Inherited(source),
    _sfImage                  (NullFC),
    _sfInternalFormat         (source._sfInternalFormat         ),
    _sfExternalFormat         (source._sfExternalFormat         ),
    _sfScale                  (source._sfScale                  ),
    _sfFrame                  (source._sfFrame                  ),
    _sfMinFilter              (source._sfMinFilter              ),
    _sfMagFilter              (source._sfMagFilter              ),
    _sfWrapS                  (source._sfWrapS                  ),
    _sfWrapT                  (source._sfWrapT                  ),
    _sfWrapR                  (source._sfWrapR                  ),
    _sfGLId                   (source._sfGLId                   ),
    _sfIgnoreGLForAspect      (source._sfIgnoreGLForAspect      ),
    _sfPriority               (source._sfPriority               ),
    _sfDirtyLeft              (source._sfDirtyLeft              ),
    _sfDirtyMinX              (source._sfDirtyMinX              ),
    _sfDirtyMaxX              (source._sfDirtyMaxX              ),
    _sfDirtyMinY              (source._sfDirtyMinY              ),
    _sfDirtyMaxY              (source._sfDirtyMaxY              ),
    _sfDirtyMinZ              (source._sfDirtyMinZ              ),
    _sfDirtyMaxZ              (source._sfDirtyMaxZ              ),
    _sfAnisotropy             (source._sfAnisotropy             ),
    _sfBorderColor            (source._sfBorderColor            ),
    _sfCompareMode            (source._sfCompareMode            ),
    _sfCompareFunc            (source._sfCompareFunc            ),
    _sfDepthMode              (source._sfDepthMode              ),
    _sfBorderWidth            (source._sfBorderWidth            ),
    _sfNPOTMatrixScale        (source._sfNPOTMatrixScale        )
{
}


/*-------------------------- destructors ----------------------------------*/

TextureObjChunkBase::~TextureObjChunkBase(void)
{
}

void TextureObjChunkBase::onCreate(const TextureObjChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setImage(source->getImage());
    }
}

#ifdef OSG_MT_CPTR_ASPECT
void TextureObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<TextureObjChunkBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr TextureObjChunkBase::createAspectCopy(void) const
{
    TextureObjChunkPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const TextureObjChunk *>(this));

    return returnValue;
}
#endif

void TextureObjChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TextureObjChunk *>(this)->setImage(NullFC);


}


OSG_END_NAMESPACE

#include "OSGSFieldAdaptor.ins"
#include "OSGMFieldAdaptor.ins"

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<TextureObjChunkPtr>::_type("TextureObjChunkPtr", "TextureBaseChunkPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(TextureObjChunkPtr)

OSG_FIELD_DLLEXPORT_DEF2(SFieldAdaptor, TextureObjChunkPtr, SFFieldContainerPtr);
OSG_FIELD_DLLEXPORT_DEF2(MFieldAdaptor, TextureObjChunkPtr, MFFieldContainerPtr);

OSG_END_NAMESPACE
