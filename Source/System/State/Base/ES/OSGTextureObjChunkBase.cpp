/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureObjChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include "OSGConfig.h"


#include <OSGGL.h>                        // InternalFormat default header
#include <OSGGL.h>                        // ExternalFormat default header
#include <OSGGL.h>                        // MinFilter default header
#include <OSGGL.h>                        // MagFilter default header
#include <OSGGL.h>                        // WrapS default header
#include <OSGGL.h>                        // WrapT default header
#include <OSGGL.h>                        // WrapR default header
#include <OSGGL.h>                        // EnvMode default header
#include <OSGGL.h>                        // EnvCombineRGB default header
#include <OSGGL.h>                        // EnvCombineAlpha default header
#include <OSGGL.h>                        // EnvSource0RGB default header
#include <OSGGLEXT.h>                     // EnvSource1RGB default header
#include <OSGGLEXT.h>                     // EnvSource2RGB default header
#include <OSGGL.h>                        // EnvSource0Alpha default header
#include <OSGGLEXT.h>                     // EnvSource1Alpha default header
#include <OSGGLEXT.h>                     // EnvSource2Alpha default header
#include <OSGGL.h>                        // EnvOperand0RGB default header
#include <OSGGL.h>                        // EnvOperand1RGB default header
#include <OSGGL.h>                        // EnvOperand2RGB default header
#include <OSGGL.h>                        // EnvOperand0Alpha default header
#include <OSGGL.h>                        // EnvOperand1Alpha default header
#include <OSGGL.h>                        // EnvOperand2Alpha default header
#include <OSGGL.h>                        // PointSprite default header
#include <OSGGL.h>                        // ShaderOperation default header
#include <OSGGL.h>                        // ShaderInput default header
#include <OSGGL.h>                        // ShaderRGBADotProduct default header
#include <OSGGL.h>                        // CompareMode default header
#include <OSGGL.h>                        // CompareFunc default header
#include <OSGGL.h>                        // DepthMode default header

#include "OSGImage.h"                   // Image Class

#include "OSGTextureObjChunkBase.h"
#include "OSGTextureObjChunk.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::TextureObjChunk
    See \ref PageSystemTextureObjChunk for a description.

    This chunk wraps glTexImage[123]D (OSG::TextureChunk::_sfImage,
    OSG::TextureChunk::_sfInternalFormat, OSG::TextureChunk::_sfExternalFormat),
    glTexParameter (OSG::TextureChunk::_sfMinFilter,
    OSG::TextureChunk::_sfMagFilter, OSG::TextureChunk::_sfWrapS,
    OSG::TextureChunk::_sfWrapT, OSG::TextureChunk::_sfWrapR), glTexEnv
    (OSG::TextureChunk::_sfEnvMode, OSG::TextureChunk::_sfEnvColor,
    OSG::TextureChunk::_sfPriority).

    The ARB combine extension is also supported,
    where available (OSG::TextureChunk::_sfEnvCombineRGB,
    OSG::TextureChunk::_sfEnvScaleRGB, OSG::TextureChunk::_sfEnvSource0RGB,
    OSG::TextureChunk::_sfEnvSource1RGB, OSG::TextureChunk::_sfEnvSource2RGB,
    OSG::TextureChunk::_sfEnvOperand0RGB, OSG::TextureChunk::_sfEnvOperand1RGB,
    OSG::TextureChunk::_sfEnvOperand2RGB,
    OSG::TextureChunk::_sfEnvCombineAlpha,   OSG::TextureChunk::_sfEnvScaleAlpha,
    OSG::TextureChunk::_sfEnvSource0Alpha, OSG::TextureChunk::_sfEnvSource1Alpha,
    OSG::TextureChunk::_sfEnvSource2Alpha, OSG::TextureChunk::_sfEnvOperand0Alpha,
    OSG::TextureChunk::_sfEnvOperand1Alpha,
    OSG::TextureChunk::_sfEnvOperand2Alpha).

    It is possible to enable the point
    sprite coordinate replacement  (OSG::TextureChunk::_sfPointSprite), see \ref
    PageSystemPointChunk for details. The two parameters
    OSG::TextureChunk::_sfScale and OSG::TextureChunk::_sfFrame specify details
    about the texture.

    On hardware that supports it (i.e. NVidia boards) the texture shader
    extension(s) are also available.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var Image *         TextureObjChunkBase::_sfImage
    
*/

/*! \var GLenum          TextureObjChunkBase::_sfInternalFormat
    The internal texture format.
*/

/*! \var GLenum          TextureObjChunkBase::_sfExternalFormat
    The external texture format - overwrites 
    external format of image when set to a value not equal to 
    GL_NONE (which is the default).
*/

/*! \var bool            TextureObjChunkBase::_sfScale
    Specifies whether the image should be scaled to the next power of two,
    thus filling the whole texture coordinate range, or if it should be put
    in the lower left corner, leaving the rest of the texture undefined.
    This is mainly used for rapidly changing non power of two textures, to
    get around the scaling overhead.
*/

/*! \var UInt32          TextureObjChunkBase::_sfFrame
    Select the frame of the image to be used. See OSG::Image about details
    concerning multi-frame images.
    @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now. \endhint
*/

/*! \var GLenum          TextureObjChunkBase::_sfMinFilter
    The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.
*/

/*! \var GLenum          TextureObjChunkBase::_sfMagFilter
    The magnification filter, default GL_LINEAR.
*/

/*! \var GLenum          TextureObjChunkBase::_sfWrapS
    Texture coordinate S wrapping, default GL_REPEAT.
*/

/*! \var GLenum          TextureObjChunkBase::_sfWrapT
    Texture coordinate T wrapping, default GL_REPEAT.
*/

/*! \var GLenum          TextureObjChunkBase::_sfWrapR
    Texture coordinate R wrapping, default GL_REPEAT.
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvMode
    Texture environment mode, default GL_REPLACE
*/

/*! \var Color4f         TextureObjChunkBase::_sfEnvColor
    Texture environment color default transparent black.
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvCombineRGB
    Texture environment rgb combine mode, default GL_MODULATE
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvCombineAlpha
    Texture environment alpha combine mode, default GL_MODULATE
*/

/*! \var Real32          TextureObjChunkBase::_sfEnvScaleRGB
    Texture environment combine rgb scale factor, default 1.f
*/

/*! \var Real32          TextureObjChunkBase::_sfEnvScaleAlpha
    Texture environment combine alpha scale factor, default 1.f
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvSource0RGB
    Texture environment combine source 0 rgb, default GL_TEXTURE
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvSource1RGB
    Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvSource2RGB
    Texture environment combine source 2 rgb, default GL_CONSTANT_EXT
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvSource0Alpha
    Texture environment combine source 0 alpha, default GL_TEXTURE
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvSource1Alpha
    Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvSource2Alpha
    Texture environment combine source 2 alpha, default GL_CONSTANT_EXT
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvOperand0RGB
    Texture environment combine operand 0 rgb, default GL_SRC_COLOR
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvOperand1RGB
    Texture environment combine operand 1 rgb, default GL_SRC_COLOR
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvOperand2RGB
    Texture environment combine operand 2 rgb, default GL_SRC_ALPHA
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvOperand0Alpha
    Texture environment combine operand 0 alpha, default GL_SRC_ALPHA
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvOperand1Alpha
    Texture environment combine operand 1 alpha, default GL_SRC_ALPHA
*/

/*! \var GLenum          TextureObjChunkBase::_sfEnvOperand2Alpha
    Texture environment combine operand 2 alpha, default GL_SRC_ALPHA
*/

/*! \var GLenum          TextureObjChunkBase::_sfGLId
    The OpenGL texture id for this texture.
*/

/*! \var bool            TextureObjChunkBase::_sfPointSprite
    Flag to use this texture for Point Sprites.
*/

/*! \var Real32          TextureObjChunkBase::_sfPriority
    Priority of this texture, between 0 and 1, the default is 0.
*/

/*! \var GLenum          TextureObjChunkBase::_sfShaderOperation
    Shader operation of this texture unit, default GL_NONE. If unit 0 uses
    GL_NONE, shading is switched off.
*/

/*! \var GLenum          TextureObjChunkBase::_sfShaderInput
    Input texture unit for this shader's operation.
*/

/*! \var Real32          TextureObjChunkBase::_mfShaderOffsetMatrix
    The 2x2 transformation matrix for offset textures.
*/

/*! \var Real32          TextureObjChunkBase::_sfShaderOffsetScale
    The scaling factor for scaled offset textures.
*/

/*! \var Real32          TextureObjChunkBase::_sfShaderOffsetBias
    The bias factor for scaled offset textures.
*/

/*! \var GLenum          TextureObjChunkBase::_sfShaderRGBADotProduct
    The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.
*/

/*! \var UInt8           TextureObjChunkBase::_sfShaderCullModes
    The CULL_MODES_NV value, coded into a single byte. The first 4 bits of
    the byte are used to indicate the wnated cull modes, a value of 0 
    signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for 
    the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 
    (mask 8) for Q.
*/

/*! \var Vec3f           TextureObjChunkBase::_sfShaderConstEye
    The CONST_EYE_NV value, i.e. the constant eye position used by the 
    DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.
*/

/*! \var Real32          TextureObjChunkBase::_sfLodBias
    Bias of LOD calculation for texture access.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyLeft
    Left coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMinX
    Minimum X coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMaxX
    Maximum X coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMinY
    Minimum Y coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMaxY
    Maximum Y coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMinZ
    Minimum Z coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Int32           TextureObjChunkBase::_sfDirtyMaxZ
    Maximum Z coordinate of the dirty rectangle to use for 
    imageContentChanged(). This doesn't make sense to be stored in files, 
    it does make sense on a cluster, though, that's why it's external.
*/

/*! \var Real32          TextureObjChunkBase::_sfAnisotropy
    Anisotropic filtering the default 1.0f means isotropic filtering.
*/

/*! \var Color4f         TextureObjChunkBase::_sfBorderColor
    Texture border color
*/

/*! \var GLenum          TextureObjChunkBase::_sfCompareMode
    
*/

/*! \var GLenum          TextureObjChunkBase::_sfCompareFunc
    
*/

/*! \var GLenum          TextureObjChunkBase::_sfDepthMode
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<TextureObjChunk *>::_type("TextureObjChunkPtr", "TextureBaseChunkPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(TextureObjChunk *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           TextureObjChunk *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           TextureObjChunk *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void TextureObjChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFUnrecImagePtr::Description(
        SFUnrecImagePtr::getClassType(),
        "image",
        "",
        ImageFieldId, ImageFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleImage),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleImage));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "internalFormat",
        "The internal texture format.\n",
        InternalFormatFieldId, InternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleInternalFormat),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "externalFormat",
        "The external texture format - overwrites \n"
        "external format of image when set to a value not equal to \n"
        "GL_NONE (which is the default).\n",
        ExternalFormatFieldId, ExternalFormatFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleExternalFormat),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleExternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "scale",
        "Specifies whether the image should be scaled to the next power of two,\n"
        "thus filling the whole texture coordinate range, or if it should be put\n"
        "in the lower left corner, leaving the rest of the texture undefined.\n"
        "This is mainly used for rapidly changing non power of two textures, to\n"
        "get around the scaling overhead.\n",
        ScaleFieldId, ScaleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleScale),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "frame",
        "Select the frame of the image to be used. See OSG::Image about details\n"
        "concerning multi-frame images.\n"
        "@hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now. \\endhint\n",
        FrameFieldId, FrameFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleFrame),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleFrame));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "minFilter",
        "The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n",
        MinFilterFieldId, MinFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleMinFilter),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleMinFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "magFilter",
        "The magnification filter, default GL_LINEAR.\n",
        MagFilterFieldId, MagFilterFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleMagFilter),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleMagFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapS",
        "Texture coordinate S wrapping, default GL_REPEAT.\n",
        WrapSFieldId, WrapSFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleWrapS),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleWrapS));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapT",
        "Texture coordinate T wrapping, default GL_REPEAT.\n",
        WrapTFieldId, WrapTFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleWrapT),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleWrapT));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "wrapR",
        "Texture coordinate R wrapping, default GL_REPEAT.\n",
        WrapRFieldId, WrapRFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleWrapR),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleWrapR));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envMode",
        "Texture environment mode, default GL_REPLACE\n",
        EnvModeFieldId, EnvModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvMode),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(),
        "envColor",
        "Texture environment color default transparent black.\n",
        EnvColorFieldId, EnvColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvColor),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envCombineRGB",
        "Texture environment rgb combine mode, default GL_MODULATE\n",
        EnvCombineRGBFieldId, EnvCombineRGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvCombineRGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvCombineRGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envCombineAlpha",
        "Texture environment alpha combine mode, default GL_MODULATE\n",
        EnvCombineAlphaFieldId, EnvCombineAlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvCombineAlpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvCombineAlpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "envScaleRGB",
        "Texture environment combine rgb scale factor, default 1.f\n",
        EnvScaleRGBFieldId, EnvScaleRGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvScaleRGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvScaleRGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "envScaleAlpha",
        "Texture environment combine alpha scale factor, default 1.f\n",
        EnvScaleAlphaFieldId, EnvScaleAlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvScaleAlpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvScaleAlpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource0RGB",
        "Texture environment combine source 0 rgb, default GL_TEXTURE\n",
        EnvSource0RGBFieldId, EnvSource0RGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvSource0RGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvSource0RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource1RGB",
        "Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT\n",
        EnvSource1RGBFieldId, EnvSource1RGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvSource1RGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvSource1RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource2RGB",
        "Texture environment combine source 2 rgb, default GL_CONSTANT_EXT\n",
        EnvSource2RGBFieldId, EnvSource2RGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvSource2RGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvSource2RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource0Alpha",
        "Texture environment combine source 0 alpha, default GL_TEXTURE\n",
        EnvSource0AlphaFieldId, EnvSource0AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvSource0Alpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvSource0Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource1Alpha",
        "Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT\n",
        EnvSource1AlphaFieldId, EnvSource1AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvSource1Alpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvSource1Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envSource2Alpha",
        "Texture environment combine source 2 alpha, default GL_CONSTANT_EXT\n",
        EnvSource2AlphaFieldId, EnvSource2AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvSource2Alpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvSource2Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand0RGB",
        "Texture environment combine operand 0 rgb, default GL_SRC_COLOR\n",
        EnvOperand0RGBFieldId, EnvOperand0RGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvOperand0RGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvOperand0RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand1RGB",
        "Texture environment combine operand 1 rgb, default GL_SRC_COLOR\n",
        EnvOperand1RGBFieldId, EnvOperand1RGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvOperand1RGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvOperand1RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand2RGB",
        "Texture environment combine operand 2 rgb, default GL_SRC_ALPHA\n",
        EnvOperand2RGBFieldId, EnvOperand2RGBFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvOperand2RGB),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvOperand2RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand0Alpha",
        "Texture environment combine operand 0 alpha, default GL_SRC_ALPHA\n",
        EnvOperand0AlphaFieldId, EnvOperand0AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvOperand0Alpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvOperand0Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand1Alpha",
        "Texture environment combine operand 1 alpha, default GL_SRC_ALPHA\n",
        EnvOperand1AlphaFieldId, EnvOperand1AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvOperand1Alpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvOperand1Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "envOperand2Alpha",
        "Texture environment combine operand 2 alpha, default GL_SRC_ALPHA\n",
        EnvOperand2AlphaFieldId, EnvOperand2AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleEnvOperand2Alpha),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleEnvOperand2Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "GLId",
        "The OpenGL texture id for this texture.\n",
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleGLId),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "pointSprite",
        "Flag to use this texture for Point Sprites.\n",
        PointSpriteFieldId, PointSpriteFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandlePointSprite),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandlePointSprite));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "priority",
        "Priority of this texture, between 0 and 1, the default is 0.\n",
        PriorityFieldId, PriorityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandlePriority),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandlePriority));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "shaderOperation",
        "Shader operation of this texture unit, default GL_NONE. If unit 0 uses\n"
        "GL_NONE, shading is switched off.\n",
        ShaderOperationFieldId, ShaderOperationFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderOperation),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderOperation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "shaderInput",
        "Input texture unit for this shader's operation.\n",
        ShaderInputFieldId, ShaderInputFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderInput),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderInput));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "shaderOffsetMatrix",
        "The 2x2 transformation matrix for offset textures.\n",
        ShaderOffsetMatrixFieldId, ShaderOffsetMatrixFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderOffsetMatrix),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderOffsetMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shaderOffsetScale",
        "The scaling factor for scaled offset textures.\n",
        ShaderOffsetScaleFieldId, ShaderOffsetScaleFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderOffsetScale),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderOffsetScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shaderOffsetBias",
        "The bias factor for scaled offset textures.\n",
        ShaderOffsetBiasFieldId, ShaderOffsetBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderOffsetBias),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderOffsetBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "shaderRGBADotProduct",
        "The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.\n",
        ShaderRGBADotProductFieldId, ShaderRGBADotProductFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderRGBADotProduct),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderRGBADotProduct));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt8::Description(
        SFUInt8::getClassType(),
        "shaderCullModes",
        "The CULL_MODES_NV value, coded into a single byte. The first 4 bits of\n"
        "the byte are used to indicate the wnated cull modes, a value of 0 \n"
        "signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for \n"
        "the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 \n"
        "(mask 8) for Q.\n",
        ShaderCullModesFieldId, ShaderCullModesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderCullModes),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderCullModes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(),
        "shaderConstEye",
        "The CONST_EYE_NV value, i.e. the constant eye position used by the \n"
        "DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.\n",
        ShaderConstEyeFieldId, ShaderConstEyeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleShaderConstEye),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleShaderConstEye));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "lodBias",
        "Bias of LOD calculation for texture access.\n",
        LodBiasFieldId, LodBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleLodBias),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleLodBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyLeft",
        "Left coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyLeftFieldId, DirtyLeftFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyLeft),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyLeft));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMinX",
        "Minimum X coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMinXFieldId, DirtyMinXFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyMinX),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyMinX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMaxX",
        "Maximum X coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMaxXFieldId, DirtyMaxXFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyMaxX),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyMaxX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMinY",
        "Minimum Y coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMinYFieldId, DirtyMinYFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyMinY),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyMinY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMaxY",
        "Maximum Y coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMaxYFieldId, DirtyMaxYFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyMaxY),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyMaxY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMinZ",
        "Minimum Z coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMinZFieldId, DirtyMinZFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyMinZ),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyMinZ));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(),
        "dirtyMaxZ",
        "Maximum Z coordinate of the dirty rectangle to use for \n"
        "imageContentChanged(). This doesn't make sense to be stored in files, \n"
        "it does make sense on a cluster, though, that's why it's external.\n",
        DirtyMaxZFieldId, DirtyMaxZFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDirtyMaxZ),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDirtyMaxZ));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "anisotropy",
        "Anisotropic filtering the default 1.0f means isotropic filtering.\n",
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleAnisotropy),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleAnisotropy));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(),
        "borderColor",
        "Texture border color\n",
        BorderColorFieldId, BorderColorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleBorderColor),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleBorderColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "compareMode",
        "",
        CompareModeFieldId, CompareModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleCompareMode),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleCompareMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "compareFunc",
        "",
        CompareFuncFieldId, CompareFuncFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleCompareFunc),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleCompareFunc));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(),
        "depthMode",
        "",
        DepthModeFieldId, DepthModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&TextureObjChunk::editHandleDepthMode),
        static_cast<FieldGetMethodSig >(&TextureObjChunk::getHandleDepthMode));

    oType.addInitialDesc(pDesc);
}


TextureObjChunkBase::TypeObject TextureObjChunkBase::_type(
    TextureObjChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&TextureObjChunkBase::createEmptyLocal),
    TextureObjChunk::initMethod,
    TextureObjChunk::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&TextureObjChunk::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"TextureObjChunk\"\n"
    "   parent=\"TextureBaseChunk\"\n"
    "   library=\"System\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   useLocalIncludes=\"false\"\n"
    "   docGroupBase=\"GrpSystemState\"\n"
    ">\n"
    "\n"
    "See \\ref PageSystemTextureObjChunk for a description.\n"
    "\n"
    "This chunk wraps glTexImage[123]D (OSG::TextureChunk::_sfImage,\n"
    "OSG::TextureChunk::_sfInternalFormat, OSG::TextureChunk::_sfExternalFormat),\n"
    "glTexParameter (OSG::TextureChunk::_sfMinFilter,\n"
    "OSG::TextureChunk::_sfMagFilter, OSG::TextureChunk::_sfWrapS,\n"
    "OSG::TextureChunk::_sfWrapT, OSG::TextureChunk::_sfWrapR), glTexEnv\n"
    "(OSG::TextureChunk::_sfEnvMode, OSG::TextureChunk::_sfEnvColor,\n"
    "OSG::TextureChunk::_sfPriority).\n"
    "\n"
    "The ARB combine extension is also supported,\n"
    "where available (OSG::TextureChunk::_sfEnvCombineRGB,\n"
    "OSG::TextureChunk::_sfEnvScaleRGB, OSG::TextureChunk::_sfEnvSource0RGB,\n"
    "OSG::TextureChunk::_sfEnvSource1RGB, OSG::TextureChunk::_sfEnvSource2RGB,\n"
    "OSG::TextureChunk::_sfEnvOperand0RGB, OSG::TextureChunk::_sfEnvOperand1RGB,\n"
    "OSG::TextureChunk::_sfEnvOperand2RGB,\n"
    "OSG::TextureChunk::_sfEnvCombineAlpha,   OSG::TextureChunk::_sfEnvScaleAlpha,\n"
    "OSG::TextureChunk::_sfEnvSource0Alpha, OSG::TextureChunk::_sfEnvSource1Alpha,\n"
    "OSG::TextureChunk::_sfEnvSource2Alpha, OSG::TextureChunk::_sfEnvOperand0Alpha,\n"
    "OSG::TextureChunk::_sfEnvOperand1Alpha,\n"
    "OSG::TextureChunk::_sfEnvOperand2Alpha).\n"
    "\n"
    "It is possible to enable the point\n"
    "sprite coordinate replacement  (OSG::TextureChunk::_sfPointSprite), see \\ref\n"
    "PageSystemPointChunk for details. The two parameters\n"
    "OSG::TextureChunk::_sfScale and OSG::TextureChunk::_sfFrame specify details\n"
    "about the texture.\n"
    "\n"
    "On hardware that supports it (i.e. NVidia boards) the texture shader\n"
    "extension(s) are also available.\n"
    "\t<Field\n"
    "\t\tname=\"image\"\n"
    "\t\ttype=\"ImagePtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"internalFormat\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe internal texture format.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"externalFormat\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t    The external texture format - overwrites \n"
    "        external format of image when set to a value not equal to \n"
    "        GL_NONE (which is the default).\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"scale\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Specifies whether the image should be scaled to the next power of two,\n"
    "        thus filling the whole texture coordinate range, or if it should be put\n"
    "        in the lower left corner, leaving the rest of the texture undefined.\n"
    "        This is mainly used for rapidly changing non power of two textures, to\n"
    "        get around the scaling overhead.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frame\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Select the frame of the image to be used. See OSG::Image about details\n"
    "        concerning multi-frame images.\n"
    "        @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now. \\endhint\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"minFilter\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LINEAR_MIPMAP_LINEAR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"magFilter\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LINEAR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The magnification filter, default GL_LINEAR.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"wrapS\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPEAT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture coordinate S wrapping, default GL_REPEAT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"wrapT\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPEAT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture coordinate T wrapping, default GL_REPEAT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"wrapR\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPEAT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture coordinate R wrapping, default GL_REPEAT.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envMode\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_REPLACE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment mode, default GL_REPLACE\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envColor\"\n"
    "\t\ttype=\"Color4f\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0,0,0,0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment color default transparent black.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envCombineRGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_MODULATE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment rgb combine mode, default GL_MODULATE\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envCombineAlpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_MODULATE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment alpha combine mode, default GL_MODULATE\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envScaleRGB\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine rgb scale factor, default 1.f\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envScaleAlpha\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"1.0f\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine alpha scale factor, default 1.f\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource0RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TEXTURE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 0 rgb, default GL_TEXTURE\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource1RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_PREVIOUS_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource2RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_CONSTANT_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 2 rgb, default GL_CONSTANT_EXT\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource0Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TEXTURE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 0 alpha, default GL_TEXTURE\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource1Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_PREVIOUS_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envSource2Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_CONSTANT_EXT\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine source 2 alpha, default GL_CONSTANT_EXT\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand0RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_COLOR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 0 rgb, default GL_SRC_COLOR\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand1RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_COLOR\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 1 rgb, default GL_SRC_COLOR\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand2RGB\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 2 rgb, default GL_SRC_ALPHA\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand0Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 0 alpha, default GL_SRC_ALPHA\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand1Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 1 alpha, default GL_SRC_ALPHA\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"envOperand2Alpha\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_SRC_ALPHA\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        Texture environment combine operand 2 alpha, default GL_SRC_ALPHA\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"GLId\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"internal\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "        fieldFlags=\"FClusterLocal\"\n"
    "\t>\n"
    "        The OpenGL texture id for this texture.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"pointSprite\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_FALSE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        Flag to use this texture for Point Sprites.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"priority\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"1.f\"\n"
    "\t>\n"
    "        Priority of this texture, between 0 and 1, the default is 0.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOperation\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        Shader operation of this texture unit, default GL_NONE. If unit 0 uses\n"
    "        GL_NONE, shading is switched off.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderInput\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        Input texture unit for this shader's operation.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOffsetMatrix\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The 2x2 transformation matrix for offset textures.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOffsetScale\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"1.f\"\n"
    "\t>\n"
    "        The scaling factor for scaled offset textures.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderOffsetBias\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0.f\"\n"
    "\t>\n"
    "        The bias factor for scaled offset textures.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderRGBADotProduct\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t>\n"
    "        The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderCullModes\"\n"
    "\t\ttype=\"UInt8\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t>\n"
    "        The CULL_MODES_NV value, coded into a single byte. The first 4 bits of\n"
    "        the byte are used to indicate the wnated cull modes, a value of 0 \n"
    "        signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for \n"
    "        the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 \n"
    "        (mask 8) for Q.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shaderConstEye\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "        The CONST_EYE_NV value, i.e. the constant eye position used by the \n"
    "        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"lodBias\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t\tdefaultValue=\"0.f\"\n"
    "\t\tdefaultHeader=\"\"\n"
    "\t>\n"
    "        Bias of LOD calculation for texture access.\n"
    "\t</Field>\n"
    "    <Field\n"
    "        name=\"dirtyLeft\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Left coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMinX\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Minimum X coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMaxX\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Maximum X coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMinY\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Minimum Y coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMaxY\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Maximum Y coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMinZ\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Minimum Z coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"dirtyMaxZ\"\n"
    "        type=\"Int32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"-1\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Maximum Z coordinate of the dirty rectangle to use for \n"
    "        imageContentChanged(). This doesn't make sense to be stored in files, \n"
    "        it does make sense on a cluster, though, that's why it's external.\n"
    "    </Field>\n"
    "    <Field\n"
    "        name=\"anisotropy\"\n"
    "        type=\"Real32\"\n"
    "        cardinality=\"single\"\n"
    "        visibility=\"external\"\n"
    "        defaultValue=\"1.0f\"\n"
    "        access=\"public\"\n"
    "    >\n"
    "        Anisotropic filtering the default 1.0f means isotropic filtering.\n"
    "        </Field>\n"
    "\t<Field\n"
    "\t\tname=\"borderColor\"\n"
    "\t\ttype=\"Color4f\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0,0,0,0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture border color\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"compareMode\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_NONE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"compareFunc\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LEQUAL\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"depthMode\"\n"
    "\t\ttype=\"GLenum\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_LUMINANCE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "See \\ref PageSystemTextureObjChunk for a description.\n"
    "\n"
    "This chunk wraps glTexImage[123]D (OSG::TextureChunk::_sfImage,\n"
    "OSG::TextureChunk::_sfInternalFormat, OSG::TextureChunk::_sfExternalFormat),\n"
    "glTexParameter (OSG::TextureChunk::_sfMinFilter,\n"
    "OSG::TextureChunk::_sfMagFilter, OSG::TextureChunk::_sfWrapS,\n"
    "OSG::TextureChunk::_sfWrapT, OSG::TextureChunk::_sfWrapR), glTexEnv\n"
    "(OSG::TextureChunk::_sfEnvMode, OSG::TextureChunk::_sfEnvColor,\n"
    "OSG::TextureChunk::_sfPriority).\n"
    "\n"
    "The ARB combine extension is also supported,\n"
    "where available (OSG::TextureChunk::_sfEnvCombineRGB,\n"
    "OSG::TextureChunk::_sfEnvScaleRGB, OSG::TextureChunk::_sfEnvSource0RGB,\n"
    "OSG::TextureChunk::_sfEnvSource1RGB, OSG::TextureChunk::_sfEnvSource2RGB,\n"
    "OSG::TextureChunk::_sfEnvOperand0RGB, OSG::TextureChunk::_sfEnvOperand1RGB,\n"
    "OSG::TextureChunk::_sfEnvOperand2RGB,\n"
    "OSG::TextureChunk::_sfEnvCombineAlpha,   OSG::TextureChunk::_sfEnvScaleAlpha,\n"
    "OSG::TextureChunk::_sfEnvSource0Alpha, OSG::TextureChunk::_sfEnvSource1Alpha,\n"
    "OSG::TextureChunk::_sfEnvSource2Alpha, OSG::TextureChunk::_sfEnvOperand0Alpha,\n"
    "OSG::TextureChunk::_sfEnvOperand1Alpha,\n"
    "OSG::TextureChunk::_sfEnvOperand2Alpha).\n"
    "\n"
    "It is possible to enable the point\n"
    "sprite coordinate replacement  (OSG::TextureChunk::_sfPointSprite), see \\ref\n"
    "PageSystemPointChunk for details. The two parameters\n"
    "OSG::TextureChunk::_sfScale and OSG::TextureChunk::_sfFrame specify details\n"
    "about the texture.\n"
    "\n"
    "On hardware that supports it (i.e. NVidia boards) the texture shader\n"
    "extension(s) are also available.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureObjChunkBase::getType(void)
{
    return _type;
}

const FieldContainerType &TextureObjChunkBase::getType(void) const
{
    return _type;
}

UInt32 TextureObjChunkBase::getContainerSize(void) const
{
    return sizeof(TextureObjChunk);
}

/*------------------------- decorator get ------------------------------*/


//! Get the TextureObjChunk::_sfImage field.
const SFUnrecImagePtr *TextureObjChunkBase::getSFImage(void) const
{
    return &_sfImage;
}

SFUnrecImagePtr     *TextureObjChunkBase::editSFImage          (void)
{
    editSField(ImageFieldMask);

    return &_sfImage;
}

SFGLenum *TextureObjChunkBase::editSFInternalFormat(void)
{
    editSField(InternalFormatFieldMask);

    return &_sfInternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFInternalFormat(void) const
{
    return &_sfInternalFormat;
}


SFGLenum *TextureObjChunkBase::editSFExternalFormat(void)
{
    editSField(ExternalFormatFieldMask);

    return &_sfExternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFExternalFormat(void) const
{
    return &_sfExternalFormat;
}


SFBool *TextureObjChunkBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFBool *TextureObjChunkBase::getSFScale(void) const
{
    return &_sfScale;
}


SFUInt32 *TextureObjChunkBase::editSFFrame(void)
{
    editSField(FrameFieldMask);

    return &_sfFrame;
}

const SFUInt32 *TextureObjChunkBase::getSFFrame(void) const
{
    return &_sfFrame;
}


SFGLenum *TextureObjChunkBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}


SFGLenum *TextureObjChunkBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}


SFGLenum *TextureObjChunkBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *TextureObjChunkBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}


SFGLenum *TextureObjChunkBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *TextureObjChunkBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}


SFGLenum *TextureObjChunkBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *TextureObjChunkBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}


SFGLenum *TextureObjChunkBase::editSFEnvMode(void)
{
    editSField(EnvModeFieldMask);

    return &_sfEnvMode;
}

const SFGLenum *TextureObjChunkBase::getSFEnvMode(void) const
{
    return &_sfEnvMode;
}


SFColor4f *TextureObjChunkBase::editSFEnvColor(void)
{
    editSField(EnvColorFieldMask);

    return &_sfEnvColor;
}

const SFColor4f *TextureObjChunkBase::getSFEnvColor(void) const
{
    return &_sfEnvColor;
}


SFGLenum *TextureObjChunkBase::editSFEnvCombineRGB(void)
{
    editSField(EnvCombineRGBFieldMask);

    return &_sfEnvCombineRGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvCombineRGB(void) const
{
    return &_sfEnvCombineRGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvCombineAlpha(void)
{
    editSField(EnvCombineAlphaFieldMask);

    return &_sfEnvCombineAlpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvCombineAlpha(void) const
{
    return &_sfEnvCombineAlpha;
}


SFReal32 *TextureObjChunkBase::editSFEnvScaleRGB(void)
{
    editSField(EnvScaleRGBFieldMask);

    return &_sfEnvScaleRGB;
}

const SFReal32 *TextureObjChunkBase::getSFEnvScaleRGB(void) const
{
    return &_sfEnvScaleRGB;
}


SFReal32 *TextureObjChunkBase::editSFEnvScaleAlpha(void)
{
    editSField(EnvScaleAlphaFieldMask);

    return &_sfEnvScaleAlpha;
}

const SFReal32 *TextureObjChunkBase::getSFEnvScaleAlpha(void) const
{
    return &_sfEnvScaleAlpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource0RGB(void)
{
    editSField(EnvSource0RGBFieldMask);

    return &_sfEnvSource0RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource0RGB(void) const
{
    return &_sfEnvSource0RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource1RGB(void)
{
    editSField(EnvSource1RGBFieldMask);

    return &_sfEnvSource1RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource1RGB(void) const
{
    return &_sfEnvSource1RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource2RGB(void)
{
    editSField(EnvSource2RGBFieldMask);

    return &_sfEnvSource2RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource2RGB(void) const
{
    return &_sfEnvSource2RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource0Alpha(void)
{
    editSField(EnvSource0AlphaFieldMask);

    return &_sfEnvSource0Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource0Alpha(void) const
{
    return &_sfEnvSource0Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource1Alpha(void)
{
    editSField(EnvSource1AlphaFieldMask);

    return &_sfEnvSource1Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource1Alpha(void) const
{
    return &_sfEnvSource1Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource2Alpha(void)
{
    editSField(EnvSource2AlphaFieldMask);

    return &_sfEnvSource2Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource2Alpha(void) const
{
    return &_sfEnvSource2Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand0RGB(void)
{
    editSField(EnvOperand0RGBFieldMask);

    return &_sfEnvOperand0RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand0RGB(void) const
{
    return &_sfEnvOperand0RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand1RGB(void)
{
    editSField(EnvOperand1RGBFieldMask);

    return &_sfEnvOperand1RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand1RGB(void) const
{
    return &_sfEnvOperand1RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand2RGB(void)
{
    editSField(EnvOperand2RGBFieldMask);

    return &_sfEnvOperand2RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand2RGB(void) const
{
    return &_sfEnvOperand2RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand0Alpha(void)
{
    editSField(EnvOperand0AlphaFieldMask);

    return &_sfEnvOperand0Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand0Alpha(void) const
{
    return &_sfEnvOperand0Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand1Alpha(void)
{
    editSField(EnvOperand1AlphaFieldMask);

    return &_sfEnvOperand1Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand1Alpha(void) const
{
    return &_sfEnvOperand1Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand2Alpha(void)
{
    editSField(EnvOperand2AlphaFieldMask);

    return &_sfEnvOperand2Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand2Alpha(void) const
{
    return &_sfEnvOperand2Alpha;
}


SFGLenum *TextureObjChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *TextureObjChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}


SFBool *TextureObjChunkBase::editSFPointSprite(void)
{
    editSField(PointSpriteFieldMask);

    return &_sfPointSprite;
}

const SFBool *TextureObjChunkBase::getSFPointSprite(void) const
{
    return &_sfPointSprite;
}


SFReal32 *TextureObjChunkBase::editSFPriority(void)
{
    editSField(PriorityFieldMask);

    return &_sfPriority;
}

const SFReal32 *TextureObjChunkBase::getSFPriority(void) const
{
    return &_sfPriority;
}


SFGLenum *TextureObjChunkBase::editSFShaderOperation(void)
{
    editSField(ShaderOperationFieldMask);

    return &_sfShaderOperation;
}

const SFGLenum *TextureObjChunkBase::getSFShaderOperation(void) const
{
    return &_sfShaderOperation;
}


SFGLenum *TextureObjChunkBase::editSFShaderInput(void)
{
    editSField(ShaderInputFieldMask);

    return &_sfShaderInput;
}

const SFGLenum *TextureObjChunkBase::getSFShaderInput(void) const
{
    return &_sfShaderInput;
}


MFReal32 *TextureObjChunkBase::editMFShaderOffsetMatrix(void)
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    return &_mfShaderOffsetMatrix;
}

const MFReal32 *TextureObjChunkBase::getMFShaderOffsetMatrix(void) const
{
    return &_mfShaderOffsetMatrix;
}


SFReal32 *TextureObjChunkBase::editSFShaderOffsetScale(void)
{
    editSField(ShaderOffsetScaleFieldMask);

    return &_sfShaderOffsetScale;
}

const SFReal32 *TextureObjChunkBase::getSFShaderOffsetScale(void) const
{
    return &_sfShaderOffsetScale;
}


SFReal32 *TextureObjChunkBase::editSFShaderOffsetBias(void)
{
    editSField(ShaderOffsetBiasFieldMask);

    return &_sfShaderOffsetBias;
}

const SFReal32 *TextureObjChunkBase::getSFShaderOffsetBias(void) const
{
    return &_sfShaderOffsetBias;
}


SFGLenum *TextureObjChunkBase::editSFShaderRGBADotProduct(void)
{
    editSField(ShaderRGBADotProductFieldMask);

    return &_sfShaderRGBADotProduct;
}

const SFGLenum *TextureObjChunkBase::getSFShaderRGBADotProduct(void) const
{
    return &_sfShaderRGBADotProduct;
}


SFUInt8 *TextureObjChunkBase::editSFShaderCullModes(void)
{
    editSField(ShaderCullModesFieldMask);

    return &_sfShaderCullModes;
}

const SFUInt8 *TextureObjChunkBase::getSFShaderCullModes(void) const
{
    return &_sfShaderCullModes;
}


SFVec3f *TextureObjChunkBase::editSFShaderConstEye(void)
{
    editSField(ShaderConstEyeFieldMask);

    return &_sfShaderConstEye;
}

const SFVec3f *TextureObjChunkBase::getSFShaderConstEye(void) const
{
    return &_sfShaderConstEye;
}


SFReal32 *TextureObjChunkBase::editSFLodBias(void)
{
    editSField(LodBiasFieldMask);

    return &_sfLodBias;
}

const SFReal32 *TextureObjChunkBase::getSFLodBias(void) const
{
    return &_sfLodBias;
}


SFInt32 *TextureObjChunkBase::editSFDirtyLeft(void)
{
    editSField(DirtyLeftFieldMask);

    return &_sfDirtyLeft;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyLeft(void) const
{
    return &_sfDirtyLeft;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMinX(void)
{
    editSField(DirtyMinXFieldMask);

    return &_sfDirtyMinX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinX(void) const
{
    return &_sfDirtyMinX;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMaxX(void)
{
    editSField(DirtyMaxXFieldMask);

    return &_sfDirtyMaxX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxX(void) const
{
    return &_sfDirtyMaxX;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMinY(void)
{
    editSField(DirtyMinYFieldMask);

    return &_sfDirtyMinY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinY(void) const
{
    return &_sfDirtyMinY;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMaxY(void)
{
    editSField(DirtyMaxYFieldMask);

    return &_sfDirtyMaxY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxY(void) const
{
    return &_sfDirtyMaxY;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMinZ(void)
{
    editSField(DirtyMinZFieldMask);

    return &_sfDirtyMinZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinZ(void) const
{
    return &_sfDirtyMinZ;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMaxZ(void)
{
    editSField(DirtyMaxZFieldMask);

    return &_sfDirtyMaxZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxZ(void) const
{
    return &_sfDirtyMaxZ;
}


SFReal32 *TextureObjChunkBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *TextureObjChunkBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}


SFColor4f *TextureObjChunkBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *TextureObjChunkBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}


SFGLenum *TextureObjChunkBase::editSFCompareMode(void)
{
    editSField(CompareModeFieldMask);

    return &_sfCompareMode;
}

const SFGLenum *TextureObjChunkBase::getSFCompareMode(void) const
{
    return &_sfCompareMode;
}


SFGLenum *TextureObjChunkBase::editSFCompareFunc(void)
{
    editSField(CompareFuncFieldMask);

    return &_sfCompareFunc;
}

const SFGLenum *TextureObjChunkBase::getSFCompareFunc(void) const
{
    return &_sfCompareFunc;
}


SFGLenum *TextureObjChunkBase::editSFDepthMode(void)
{
    editSField(DepthModeFieldMask);

    return &_sfDepthMode;
}

const SFGLenum *TextureObjChunkBase::getSFDepthMode(void) const
{
    return &_sfDepthMode;
}






/*------------------------------ access -----------------------------------*/

UInt32 TextureObjChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        returnValue += _sfImage.getBinSize();
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        returnValue += _sfFrame.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        returnValue += _sfEnvMode.getBinSize();
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        returnValue += _sfEnvColor.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        returnValue += _sfEnvCombineRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvCombineAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        returnValue += _sfEnvScaleRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvScaleAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        returnValue += _sfPointSprite.getBinSize();
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        returnValue += _sfPriority.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        returnValue += _sfShaderOperation.getBinSize();
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        returnValue += _sfShaderInput.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        returnValue += _mfShaderOffsetMatrix.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetScale.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetBias.getBinSize();
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        returnValue += _sfShaderRGBADotProduct.getBinSize();
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        returnValue += _sfShaderCullModes.getBinSize();
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        returnValue += _sfShaderConstEye.getBinSize();
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        returnValue += _sfLodBias.getBinSize();
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        returnValue += _sfDirtyLeft.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        returnValue += _sfDirtyMinX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        returnValue += _sfDirtyMinY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        returnValue += _sfDirtyMinZ.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxZ.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        returnValue += _sfCompareMode.getBinSize();
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        returnValue += _sfCompareFunc.getBinSize();
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        returnValue += _sfDepthMode.getBinSize();
    }

    return returnValue;
}

void TextureObjChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyToBin(pMem);
    }
}

void TextureObjChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyFromBin(pMem);
    }
}

//! create a new instance of the class
TextureObjChunkTransitPtr TextureObjChunkBase::createLocal(BitVector bFlags)
{
    TextureObjChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<TextureObjChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
TextureObjChunkTransitPtr TextureObjChunkBase::createDependent(BitVector bFlags)
{
    TextureObjChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<TextureObjChunk>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
TextureObjChunkTransitPtr TextureObjChunkBase::create(void)
{
    TextureObjChunkTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<TextureObjChunk>(tmpPtr);
    }

    return fc;
}

TextureObjChunk *TextureObjChunkBase::createEmptyLocal(BitVector bFlags)
{
    TextureObjChunk *returnValue;

    newPtr<TextureObjChunk>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
TextureObjChunk *TextureObjChunkBase::createEmpty(void)
{
    TextureObjChunk *returnValue;

    newPtr<TextureObjChunk>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr TextureObjChunkBase::shallowCopyLocal(
    BitVector bFlags) const
{
    TextureObjChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const TextureObjChunk *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr TextureObjChunkBase::shallowCopyDependent(
    BitVector bFlags) const
{
    TextureObjChunk *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const TextureObjChunk *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr TextureObjChunkBase::shallowCopy(void) const
{
    TextureObjChunk *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const TextureObjChunk *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

TextureObjChunkBase::TextureObjChunkBase(void) :
    Inherited(),
    _sfImage                  (NULL),
    _sfInternalFormat         (GLenum(GL_NONE)),
    _sfExternalFormat         (GLenum(GL_NONE)),
    _sfScale                  (bool(true)),
    _sfFrame                  (UInt32(0)),
    _sfMinFilter              (GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter              (GLenum(GL_LINEAR)),
    _sfWrapS                  (GLenum(GL_REPEAT)),
    _sfWrapT                  (GLenum(GL_REPEAT)),
    _sfWrapR                  (GLenum(GL_REPEAT)),
    _sfEnvMode                (GLenum(GL_REPLACE)),
    _sfEnvColor               (Color4f(0,0,0,0)),
    _sfEnvCombineRGB          (GLenum(GL_MODULATE)),
    _sfEnvCombineAlpha        (GLenum(GL_MODULATE)),
    _sfEnvScaleRGB            (Real32(1.0f)),
    _sfEnvScaleAlpha          (Real32(1.0f)),
    _sfEnvSource0RGB          (GLenum(GL_TEXTURE)),
    _sfEnvSource1RGB          (GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2RGB          (GLenum(GL_CONSTANT_EXT)),
    _sfEnvSource0Alpha        (GLenum(GL_TEXTURE)),
    _sfEnvSource1Alpha        (GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2Alpha        (GLenum(GL_CONSTANT_EXT)),
    _sfEnvOperand0RGB         (GLenum(GL_SRC_COLOR)),
    _sfEnvOperand1RGB         (GLenum(GL_SRC_COLOR)),
    _sfEnvOperand2RGB         (GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand0Alpha       (GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand1Alpha       (GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand2Alpha       (GLenum(GL_SRC_ALPHA)),
    _sfGLId                   (GLenum(0)),
    _sfPointSprite            (bool(GL_FALSE)),
    _sfPriority               (Real32(1.f)),
    _sfShaderOperation        (GLenum(GL_NONE)),
    _sfShaderInput            (GLenum(GL_NONE)),
    _mfShaderOffsetMatrix     (),
    _sfShaderOffsetScale      (Real32(1.f)),
    _sfShaderOffsetBias       (Real32(0.f)),
    _sfShaderRGBADotProduct   (GLenum(GL_NONE)),
    _sfShaderCullModes        (UInt8(0)),
    _sfShaderConstEye         (),
    _sfLodBias                (Real32(0.f)),
    _sfDirtyLeft              (Int32(-1)),
    _sfDirtyMinX              (Int32(-1)),
    _sfDirtyMaxX              (Int32(-1)),
    _sfDirtyMinY              (Int32(-1)),
    _sfDirtyMaxY              (Int32(-1)),
    _sfDirtyMinZ              (Int32(-1)),
    _sfDirtyMaxZ              (Int32(-1)),
    _sfAnisotropy             (Real32(1.0f)),
    _sfBorderColor            (Color4f(0,0,0,0)),
    _sfCompareMode            (GLenum(GL_NONE)),
    _sfCompareFunc            (GLenum(GL_LEQUAL)),
    _sfDepthMode              (GLenum(GL_LUMINANCE))
{
}

TextureObjChunkBase::TextureObjChunkBase(const TextureObjChunkBase &source) :
    Inherited(source),
    _sfImage                  (NULL),
    _sfInternalFormat         (source._sfInternalFormat         ),
    _sfExternalFormat         (source._sfExternalFormat         ),
    _sfScale                  (source._sfScale                  ),
    _sfFrame                  (source._sfFrame                  ),
    _sfMinFilter              (source._sfMinFilter              ),
    _sfMagFilter              (source._sfMagFilter              ),
    _sfWrapS                  (source._sfWrapS                  ),
    _sfWrapT                  (source._sfWrapT                  ),
    _sfWrapR                  (source._sfWrapR                  ),
    _sfEnvMode                (source._sfEnvMode                ),
    _sfEnvColor               (source._sfEnvColor               ),
    _sfEnvCombineRGB          (source._sfEnvCombineRGB          ),
    _sfEnvCombineAlpha        (source._sfEnvCombineAlpha        ),
    _sfEnvScaleRGB            (source._sfEnvScaleRGB            ),
    _sfEnvScaleAlpha          (source._sfEnvScaleAlpha          ),
    _sfEnvSource0RGB          (source._sfEnvSource0RGB          ),
    _sfEnvSource1RGB          (source._sfEnvSource1RGB          ),
    _sfEnvSource2RGB          (source._sfEnvSource2RGB          ),
    _sfEnvSource0Alpha        (source._sfEnvSource0Alpha        ),
    _sfEnvSource1Alpha        (source._sfEnvSource1Alpha        ),
    _sfEnvSource2Alpha        (source._sfEnvSource2Alpha        ),
    _sfEnvOperand0RGB         (source._sfEnvOperand0RGB         ),
    _sfEnvOperand1RGB         (source._sfEnvOperand1RGB         ),
    _sfEnvOperand2RGB         (source._sfEnvOperand2RGB         ),
    _sfEnvOperand0Alpha       (source._sfEnvOperand0Alpha       ),
    _sfEnvOperand1Alpha       (source._sfEnvOperand1Alpha       ),
    _sfEnvOperand2Alpha       (source._sfEnvOperand2Alpha       ),
    _sfGLId                   (source._sfGLId                   ),
    _sfPointSprite            (source._sfPointSprite            ),
    _sfPriority               (source._sfPriority               ),
    _sfShaderOperation        (source._sfShaderOperation        ),
    _sfShaderInput            (source._sfShaderInput            ),
    _mfShaderOffsetMatrix     (source._mfShaderOffsetMatrix     ),
    _sfShaderOffsetScale      (source._sfShaderOffsetScale      ),
    _sfShaderOffsetBias       (source._sfShaderOffsetBias       ),
    _sfShaderRGBADotProduct   (source._sfShaderRGBADotProduct   ),
    _sfShaderCullModes        (source._sfShaderCullModes        ),
    _sfShaderConstEye         (source._sfShaderConstEye         ),
    _sfLodBias                (source._sfLodBias                ),
    _sfDirtyLeft              (source._sfDirtyLeft              ),
    _sfDirtyMinX              (source._sfDirtyMinX              ),
    _sfDirtyMaxX              (source._sfDirtyMaxX              ),
    _sfDirtyMinY              (source._sfDirtyMinY              ),
    _sfDirtyMaxY              (source._sfDirtyMaxY              ),
    _sfDirtyMinZ              (source._sfDirtyMinZ              ),
    _sfDirtyMaxZ              (source._sfDirtyMaxZ              ),
    _sfAnisotropy             (source._sfAnisotropy             ),
    _sfBorderColor            (source._sfBorderColor            ),
    _sfCompareMode            (source._sfCompareMode            ),
    _sfCompareFunc            (source._sfCompareFunc            ),
    _sfDepthMode              (source._sfDepthMode              )
{
}


/*-------------------------- destructors ----------------------------------*/

TextureObjChunkBase::~TextureObjChunkBase(void)
{
}

void TextureObjChunkBase::onCreate(const TextureObjChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        TextureObjChunk *pThis = static_cast<TextureObjChunk *>(this);

        pThis->setImage(source->getImage());
    }
}

GetFieldHandlePtr TextureObjChunkBase::getHandleImage           (void) const
{
    SFUnrecImagePtr::GetHandlePtr returnValue(
        new  SFUnrecImagePtr::GetHandle(
             &_sfImage,
             this->getType().getFieldDesc(ImageFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleImage          (void)
{
    SFUnrecImagePtr::EditHandlePtr returnValue(
        new  SFUnrecImagePtr::EditHandle(
             &_sfImage,
             this->getType().getFieldDesc(ImageFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&TextureObjChunk::setImage,
                    static_cast<TextureObjChunk *>(this), _1));

    editSField(ImageFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleInternalFormat  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfInternalFormat,
             this->getType().getFieldDesc(InternalFormatFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleInternalFormat (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfInternalFormat,
             this->getType().getFieldDesc(InternalFormatFieldId),
             this));


    editSField(InternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleExternalFormat  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfExternalFormat,
             this->getType().getFieldDesc(ExternalFormatFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleExternalFormat (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfExternalFormat,
             this->getType().getFieldDesc(ExternalFormatFieldId),
             this));


    editSField(ExternalFormatFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleScale           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleScale          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfScale,
             this->getType().getFieldDesc(ScaleFieldId),
             this));


    editSField(ScaleFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleFrame           (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfFrame,
             this->getType().getFieldDesc(FrameFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleFrame          (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfFrame,
             this->getType().getFieldDesc(FrameFieldId),
             this));


    editSField(FrameFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleMinFilter       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMinFilter,
             this->getType().getFieldDesc(MinFilterFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleMinFilter      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMinFilter,
             this->getType().getFieldDesc(MinFilterFieldId),
             this));


    editSField(MinFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleMagFilter       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfMagFilter,
             this->getType().getFieldDesc(MagFilterFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleMagFilter      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfMagFilter,
             this->getType().getFieldDesc(MagFilterFieldId),
             this));


    editSField(MagFilterFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleWrapS           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapS,
             this->getType().getFieldDesc(WrapSFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleWrapS          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapS,
             this->getType().getFieldDesc(WrapSFieldId),
             this));


    editSField(WrapSFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleWrapT           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapT,
             this->getType().getFieldDesc(WrapTFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleWrapT          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapT,
             this->getType().getFieldDesc(WrapTFieldId),
             this));


    editSField(WrapTFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleWrapR           (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfWrapR,
             this->getType().getFieldDesc(WrapRFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleWrapR          (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfWrapR,
             this->getType().getFieldDesc(WrapRFieldId),
             this));


    editSField(WrapRFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvMode         (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvMode,
             this->getType().getFieldDesc(EnvModeFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvMode        (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvMode,
             this->getType().getFieldDesc(EnvModeFieldId),
             this));


    editSField(EnvModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvColor        (void) const
{
    SFColor4f::GetHandlePtr returnValue(
        new  SFColor4f::GetHandle(
             &_sfEnvColor,
             this->getType().getFieldDesc(EnvColorFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvColor       (void)
{
    SFColor4f::EditHandlePtr returnValue(
        new  SFColor4f::EditHandle(
             &_sfEnvColor,
             this->getType().getFieldDesc(EnvColorFieldId),
             this));


    editSField(EnvColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvCombineRGB   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvCombineRGB,
             this->getType().getFieldDesc(EnvCombineRGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvCombineRGB  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvCombineRGB,
             this->getType().getFieldDesc(EnvCombineRGBFieldId),
             this));


    editSField(EnvCombineRGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvCombineAlpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvCombineAlpha,
             this->getType().getFieldDesc(EnvCombineAlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvCombineAlpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvCombineAlpha,
             this->getType().getFieldDesc(EnvCombineAlphaFieldId),
             this));


    editSField(EnvCombineAlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvScaleRGB     (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfEnvScaleRGB,
             this->getType().getFieldDesc(EnvScaleRGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvScaleRGB    (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfEnvScaleRGB,
             this->getType().getFieldDesc(EnvScaleRGBFieldId),
             this));


    editSField(EnvScaleRGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvScaleAlpha   (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfEnvScaleAlpha,
             this->getType().getFieldDesc(EnvScaleAlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvScaleAlpha  (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfEnvScaleAlpha,
             this->getType().getFieldDesc(EnvScaleAlphaFieldId),
             this));


    editSField(EnvScaleAlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvSource0RGB   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvSource0RGB,
             this->getType().getFieldDesc(EnvSource0RGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvSource0RGB  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvSource0RGB,
             this->getType().getFieldDesc(EnvSource0RGBFieldId),
             this));


    editSField(EnvSource0RGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvSource1RGB   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvSource1RGB,
             this->getType().getFieldDesc(EnvSource1RGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvSource1RGB  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvSource1RGB,
             this->getType().getFieldDesc(EnvSource1RGBFieldId),
             this));


    editSField(EnvSource1RGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvSource2RGB   (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvSource2RGB,
             this->getType().getFieldDesc(EnvSource2RGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvSource2RGB  (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvSource2RGB,
             this->getType().getFieldDesc(EnvSource2RGBFieldId),
             this));


    editSField(EnvSource2RGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvSource0Alpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvSource0Alpha,
             this->getType().getFieldDesc(EnvSource0AlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvSource0Alpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvSource0Alpha,
             this->getType().getFieldDesc(EnvSource0AlphaFieldId),
             this));


    editSField(EnvSource0AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvSource1Alpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvSource1Alpha,
             this->getType().getFieldDesc(EnvSource1AlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvSource1Alpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvSource1Alpha,
             this->getType().getFieldDesc(EnvSource1AlphaFieldId),
             this));


    editSField(EnvSource1AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvSource2Alpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvSource2Alpha,
             this->getType().getFieldDesc(EnvSource2AlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvSource2Alpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvSource2Alpha,
             this->getType().getFieldDesc(EnvSource2AlphaFieldId),
             this));


    editSField(EnvSource2AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvOperand0RGB  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvOperand0RGB,
             this->getType().getFieldDesc(EnvOperand0RGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvOperand0RGB (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvOperand0RGB,
             this->getType().getFieldDesc(EnvOperand0RGBFieldId),
             this));


    editSField(EnvOperand0RGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvOperand1RGB  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvOperand1RGB,
             this->getType().getFieldDesc(EnvOperand1RGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvOperand1RGB (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvOperand1RGB,
             this->getType().getFieldDesc(EnvOperand1RGBFieldId),
             this));


    editSField(EnvOperand1RGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvOperand2RGB  (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvOperand2RGB,
             this->getType().getFieldDesc(EnvOperand2RGBFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvOperand2RGB (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvOperand2RGB,
             this->getType().getFieldDesc(EnvOperand2RGBFieldId),
             this));


    editSField(EnvOperand2RGBFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvOperand0Alpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvOperand0Alpha,
             this->getType().getFieldDesc(EnvOperand0AlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvOperand0Alpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvOperand0Alpha,
             this->getType().getFieldDesc(EnvOperand0AlphaFieldId),
             this));


    editSField(EnvOperand0AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvOperand1Alpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvOperand1Alpha,
             this->getType().getFieldDesc(EnvOperand1AlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvOperand1Alpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvOperand1Alpha,
             this->getType().getFieldDesc(EnvOperand1AlphaFieldId),
             this));


    editSField(EnvOperand1AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleEnvOperand2Alpha (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfEnvOperand2Alpha,
             this->getType().getFieldDesc(EnvOperand2AlphaFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleEnvOperand2Alpha(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfEnvOperand2Alpha,
             this->getType().getFieldDesc(EnvOperand2AlphaFieldId),
             this));


    editSField(EnvOperand2AlphaFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleGLId            (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleGLId           (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfGLId,
             this->getType().getFieldDesc(GLIdFieldId),
             this));


    editSField(GLIdFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandlePointSprite     (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfPointSprite,
             this->getType().getFieldDesc(PointSpriteFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandlePointSprite    (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfPointSprite,
             this->getType().getFieldDesc(PointSpriteFieldId),
             this));


    editSField(PointSpriteFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandlePriority        (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfPriority,
             this->getType().getFieldDesc(PriorityFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandlePriority       (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfPriority,
             this->getType().getFieldDesc(PriorityFieldId),
             this));


    editSField(PriorityFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderOperation (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfShaderOperation,
             this->getType().getFieldDesc(ShaderOperationFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderOperation(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfShaderOperation,
             this->getType().getFieldDesc(ShaderOperationFieldId),
             this));


    editSField(ShaderOperationFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderInput     (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfShaderInput,
             this->getType().getFieldDesc(ShaderInputFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderInput    (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfShaderInput,
             this->getType().getFieldDesc(ShaderInputFieldId),
             this));


    editSField(ShaderInputFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderOffsetMatrix (void) const
{
    MFReal32::GetHandlePtr returnValue(
        new  MFReal32::GetHandle(
             &_mfShaderOffsetMatrix,
             this->getType().getFieldDesc(ShaderOffsetMatrixFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderOffsetMatrix(void)
{
    MFReal32::EditHandlePtr returnValue(
        new  MFReal32::EditHandle(
             &_mfShaderOffsetMatrix,
             this->getType().getFieldDesc(ShaderOffsetMatrixFieldId),
             this));


    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderOffsetScale (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfShaderOffsetScale,
             this->getType().getFieldDesc(ShaderOffsetScaleFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderOffsetScale(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfShaderOffsetScale,
             this->getType().getFieldDesc(ShaderOffsetScaleFieldId),
             this));


    editSField(ShaderOffsetScaleFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderOffsetBias (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfShaderOffsetBias,
             this->getType().getFieldDesc(ShaderOffsetBiasFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderOffsetBias(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfShaderOffsetBias,
             this->getType().getFieldDesc(ShaderOffsetBiasFieldId),
             this));


    editSField(ShaderOffsetBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderRGBADotProduct (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfShaderRGBADotProduct,
             this->getType().getFieldDesc(ShaderRGBADotProductFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderRGBADotProduct(void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfShaderRGBADotProduct,
             this->getType().getFieldDesc(ShaderRGBADotProductFieldId),
             this));


    editSField(ShaderRGBADotProductFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderCullModes (void) const
{
    SFUInt8::GetHandlePtr returnValue(
        new  SFUInt8::GetHandle(
             &_sfShaderCullModes,
             this->getType().getFieldDesc(ShaderCullModesFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderCullModes(void)
{
    SFUInt8::EditHandlePtr returnValue(
        new  SFUInt8::EditHandle(
             &_sfShaderCullModes,
             this->getType().getFieldDesc(ShaderCullModesFieldId),
             this));


    editSField(ShaderCullModesFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleShaderConstEye  (void) const
{
    SFVec3f::GetHandlePtr returnValue(
        new  SFVec3f::GetHandle(
             &_sfShaderConstEye,
             this->getType().getFieldDesc(ShaderConstEyeFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleShaderConstEye (void)
{
    SFVec3f::EditHandlePtr returnValue(
        new  SFVec3f::EditHandle(
             &_sfShaderConstEye,
             this->getType().getFieldDesc(ShaderConstEyeFieldId),
             this));


    editSField(ShaderConstEyeFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleLodBias         (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfLodBias,
             this->getType().getFieldDesc(LodBiasFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleLodBias        (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfLodBias,
             this->getType().getFieldDesc(LodBiasFieldId),
             this));


    editSField(LodBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyLeft       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyLeft,
             this->getType().getFieldDesc(DirtyLeftFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyLeft      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyLeft,
             this->getType().getFieldDesc(DirtyLeftFieldId),
             this));


    editSField(DirtyLeftFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyMinX       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyMinX,
             this->getType().getFieldDesc(DirtyMinXFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyMinX      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyMinX,
             this->getType().getFieldDesc(DirtyMinXFieldId),
             this));


    editSField(DirtyMinXFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyMaxX       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyMaxX,
             this->getType().getFieldDesc(DirtyMaxXFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyMaxX      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyMaxX,
             this->getType().getFieldDesc(DirtyMaxXFieldId),
             this));


    editSField(DirtyMaxXFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyMinY       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyMinY,
             this->getType().getFieldDesc(DirtyMinYFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyMinY      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyMinY,
             this->getType().getFieldDesc(DirtyMinYFieldId),
             this));


    editSField(DirtyMinYFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyMaxY       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyMaxY,
             this->getType().getFieldDesc(DirtyMaxYFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyMaxY      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyMaxY,
             this->getType().getFieldDesc(DirtyMaxYFieldId),
             this));


    editSField(DirtyMaxYFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyMinZ       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyMinZ,
             this->getType().getFieldDesc(DirtyMinZFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyMinZ      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyMinZ,
             this->getType().getFieldDesc(DirtyMinZFieldId),
             this));


    editSField(DirtyMinZFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDirtyMaxZ       (void) const
{
    SFInt32::GetHandlePtr returnValue(
        new  SFInt32::GetHandle(
             &_sfDirtyMaxZ,
             this->getType().getFieldDesc(DirtyMaxZFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDirtyMaxZ      (void)
{
    SFInt32::EditHandlePtr returnValue(
        new  SFInt32::EditHandle(
             &_sfDirtyMaxZ,
             this->getType().getFieldDesc(DirtyMaxZFieldId),
             this));


    editSField(DirtyMaxZFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleAnisotropy      (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfAnisotropy,
             this->getType().getFieldDesc(AnisotropyFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleAnisotropy     (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfAnisotropy,
             this->getType().getFieldDesc(AnisotropyFieldId),
             this));


    editSField(AnisotropyFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleBorderColor     (void) const
{
    SFColor4f::GetHandlePtr returnValue(
        new  SFColor4f::GetHandle(
             &_sfBorderColor,
             this->getType().getFieldDesc(BorderColorFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleBorderColor    (void)
{
    SFColor4f::EditHandlePtr returnValue(
        new  SFColor4f::EditHandle(
             &_sfBorderColor,
             this->getType().getFieldDesc(BorderColorFieldId),
             this));


    editSField(BorderColorFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleCompareMode     (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfCompareMode,
             this->getType().getFieldDesc(CompareModeFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleCompareMode    (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfCompareMode,
             this->getType().getFieldDesc(CompareModeFieldId),
             this));


    editSField(CompareModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleCompareFunc     (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfCompareFunc,
             this->getType().getFieldDesc(CompareFuncFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleCompareFunc    (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfCompareFunc,
             this->getType().getFieldDesc(CompareFuncFieldId),
             this));


    editSField(CompareFuncFieldMask);

    return returnValue;
}

GetFieldHandlePtr TextureObjChunkBase::getHandleDepthMode       (void) const
{
    SFGLenum::GetHandlePtr returnValue(
        new  SFGLenum::GetHandle(
             &_sfDepthMode,
             this->getType().getFieldDesc(DepthModeFieldId),
             const_cast<TextureObjChunkBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr TextureObjChunkBase::editHandleDepthMode      (void)
{
    SFGLenum::EditHandlePtr returnValue(
        new  SFGLenum::EditHandle(
             &_sfDepthMode,
             this->getType().getFieldDesc(DepthModeFieldId),
             this));


    editSField(DepthModeFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void TextureObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    TextureObjChunk *pThis = static_cast<TextureObjChunk *>(this);

    pThis->execSync(static_cast<TextureObjChunk *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *TextureObjChunkBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    TextureObjChunk *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const TextureObjChunk *>(pRefAspect),
                  dynamic_cast<const TextureObjChunk *>(this));

    return returnValue;
}
#endif

void TextureObjChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TextureObjChunk *>(this)->setImage(NULL);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfShaderOffsetMatrix.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
