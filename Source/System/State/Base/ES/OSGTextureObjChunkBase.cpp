/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class TextureObjChunk!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILETEXTUREOBJCHUNKINST

#include <stdlib.h>
#include <stdio.h>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>   // InternalFormat default header
#include <OSGGL.h>   // ExternalFormat default header
#include <OSGGL.h>   // MinFilter default header
#include <OSGGL.h>   // MagFilter default header
#include <OSGGL.h>   // WrapS default header
#include <OSGGL.h>   // WrapT default header
#include <OSGGL.h>   // WrapR default header
#include <OSGGL.h>   // EnvMode default header
#include <OSGGL.h>   // EnvCombineRGB default header
#include <OSGGL.h>   // EnvCombineAlpha default header
#include <OSGGL.h>   // EnvSource0RGB default header
#include <OSGGLEXT.h>   // EnvSource1RGB default header
#include <OSGGLEXT.h>   // EnvSource2RGB default header
#include <OSGGL.h>   // EnvSource0Alpha default header
#include <OSGGLEXT.h>   // EnvSource1Alpha default header
#include <OSGGLEXT.h>   // EnvSource2Alpha default header
#include <OSGGL.h>   // EnvOperand0RGB default header
#include <OSGGL.h>   // EnvOperand1RGB default header
#include <OSGGL.h>   // EnvOperand2RGB default header
#include <OSGGL.h>   // EnvOperand0Alpha default header
#include <OSGGL.h>   // EnvOperand1Alpha default header
#include <OSGGL.h>   // EnvOperand2Alpha default header
#include <OSGGL.h>   // PointSprite default header
#include <OSGGL.h>   // ShaderOperation default header
#include <OSGGL.h>   // ShaderInput default header
#include <OSGGL.h>   // ShaderRGBADotProduct default header
#include <OSGGL.h>   // Target default header
#include <OSGGL.h>   // CompareMode default header
#include <OSGGL.h>   // CompareFunc default header
#include <OSGGL.h>   // DepthMode default header

#include <OSGImage.h> // Image Class

#include "OSGTextureObjChunkBase.h"
#include "OSGTextureObjChunk.h"

OSG_USING_NAMESPACE

// Field descriptions

/*! \var ImagePtr TextureObjChunkBase::_sfImage
    
*/
/*! \var GLenum TextureObjChunkBase::_sfInternalFormat
    	The internal texture format.

*/
/*! \var GLenum TextureObjChunkBase::_sfExternalFormat
    	    The external texture format - overwrites 
        external format of image when set to a value not equal to 
        GL_NONE (which is the default).

*/
/*! \var bool TextureObjChunkBase::_sfScale
            Specifies whether the image should be scaled to the next power of two,
        thus filling the whole texture coordinate range, or if it should be put
        in the lower left corner, leaving the rest of the texture undefined.
        This is mainly used for rapidly changing non power of two textures, to
        get around the scaling overhead.

*/
/*! \var UInt32 TextureObjChunkBase::_sfFrame
            Select the frame of the image to be used. See OSG::Image about details
        concerning multi-frame images.
        @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now. \endhint

*/
/*! \var GLenum TextureObjChunkBase::_sfMinFilter
            The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.

*/
/*! \var GLenum TextureObjChunkBase::_sfMagFilter
            The magnification filter, default GL_LINEAR.

*/
/*! \var GLenum TextureObjChunkBase::_sfWrapS
            Texture coordinate S wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureObjChunkBase::_sfWrapT
            Texture coordinate T wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureObjChunkBase::_sfWrapR
            Texture coordinate R wrapping, default GL_REPEAT.

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvMode
            Texture environment mode, default GL_REPLACE

*/
/*! \var Color4f TextureObjChunkBase::_sfEnvColor
            Texture environment color default transparent black.

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvCombineRGB
            Texture environment rgb combine mode, default GL_MODULATE

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvCombineAlpha
            Texture environment alpha combine mode, default GL_MODULATE

*/
/*! \var Real32 TextureObjChunkBase::_sfEnvScaleRGB
            Texture environment combine rgb scale factor, default 1.f

*/
/*! \var Real32 TextureObjChunkBase::_sfEnvScaleAlpha
            Texture environment combine alpha scale factor, default 1.f

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvSource0RGB
            Texture environment combine source 0 rgb, default GL_TEXTURE

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvSource1RGB
            Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvSource2RGB
            Texture environment combine source 2 rgb, default GL_CONSTANT_EXT

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvSource0Alpha
            Texture environment combine source 0 alpha, default GL_TEXTURE

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvSource1Alpha
            Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvSource2Alpha
            Texture environment combine source 2 alpha, default GL_CONSTANT_EXT

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvOperand0RGB
            Texture environment combine operand 0 rgb, default GL_SRC_COLOR

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvOperand1RGB
            Texture environment combine operand 1 rgb, default GL_SRC_COLOR

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvOperand2RGB
            Texture environment combine operand 2 rgb, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvOperand0Alpha
            Texture environment combine operand 0 alpha, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvOperand1Alpha
            Texture environment combine operand 1 alpha, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureObjChunkBase::_sfEnvOperand2Alpha
            Texture environment combine operand 2 alpha, default GL_SRC_ALPHA

*/
/*! \var GLenum TextureObjChunkBase::_sfGLId
            The OpenGL texture id for this texture.

*/
/*! \var Int32 TextureObjChunkBase::_sfIgnoreGLForAspect
    	    Don't do any GL calls for aspect of given id.

*/
/*! \var bool TextureObjChunkBase::_sfPointSprite
            Flag to use this texture for Point Sprites.

*/
/*! \var Real32 TextureObjChunkBase::_sfPriority
            Priority of this texture, between 0 and 1, the default is 0.

*/
/*! \var GLenum TextureObjChunkBase::_sfShaderOperation
            Shader operation of this texture unit, default GL_NONE. If unit 0 uses
        GL_NONE, shading is switched off.

*/
/*! \var GLenum TextureObjChunkBase::_sfShaderInput
            Input texture unit for this shader's operation.

*/
/*! \var Real32 TextureObjChunkBase::_mfShaderOffsetMatrix
            The 2x2 transformation matrix for offset textures.

*/
/*! \var Real32 TextureObjChunkBase::_sfShaderOffsetScale
            The scaling factor for scaled offset textures.

*/
/*! \var Real32 TextureObjChunkBase::_sfShaderOffsetBias
            The bias factor for scaled offset textures.

*/
/*! \var GLenum TextureObjChunkBase::_sfShaderRGBADotProduct
            The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.

*/
/*! \var UInt8 TextureObjChunkBase::_sfShaderCullModes
            The CULL_MODES_NV value, coded into a single byte. The first 4 bits of
        the byte are used to indicate the wnated cull modes, a value of 0 
        signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for 
        the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 
        (mask 8) for Q.

*/
/*! \var Vec3f TextureObjChunkBase::_sfShaderConstEye
            The CONST_EYE_NV value, i.e. the constant eye position used by the 
        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.

*/
/*! \var Real32 TextureObjChunkBase::_sfLodBias
            Bias of LOD calculation for texture access.
    

*/
/*! \var GLenum TextureObjChunkBase::_sfTarget
            Texture target. Overwrite automatically determined texture target
        based on the parameters of the assigned image if set to anything 
        else than GL_NONE. Used for nVidia's rectangle textures. Be careful
        when using it!
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyLeft
            Left coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMinX
            Minimum X coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMaxX
            Maximum X coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMinY
            Minimum Y coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMaxY
            Maximum Y coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMinZ
            Minimum Z coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Int32 TextureObjChunkBase::_sfDirtyMaxZ
            Maximum Z coordinate of the dirty rectangle to use for 
        imageContentChanged(). This doesn't make sense to be stored in files, 
        it does make sense on a cluster, though, that's why it's external.
    
    

*/
/*! \var Real32 TextureObjChunkBase::_sfAnisotropy
            Anisotropic filtering the default 1.0f means isotropic filtering.
        

*/
/*! \var Color4f TextureObjChunkBase::_sfBorderColor
    	Texture border color

*/
/*! \var GLenum TextureObjChunkBase::_sfCompareMode
    
*/
/*! \var GLenum TextureObjChunkBase::_sfCompareFunc
    
*/
/*! \var GLenum TextureObjChunkBase::_sfDepthMode
    
*/

void TextureObjChunkBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL; 


    pDesc = new SFImagePtr::Description(
        SFImagePtr::getClassType(), 
        "image", 
        "",
        ImageFieldId, ImageFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&TextureObjChunkBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFImage));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "internalFormat", 
        "	The internal texture format.\n",
        InternalFormatFieldId, InternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFInternalFormat),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFInternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "externalFormat", 
        "	    The external texture format - overwrites \n        external format of image when set to a value not equal to \n        GL_NONE (which is the default).\n",
        ExternalFormatFieldId, ExternalFormatFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFExternalFormat),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFExternalFormat));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "scale", 
        "        Specifies whether the image should be scaled to the next power of two,\n        thus filling the whole texture coordinate range, or if it should be put\n        in the lower left corner, leaving the rest of the texture undefined.\n        This is mainly used for rapidly changing non power of two textures, to\n        get around the scaling overhead.\n",
        ScaleFieldId, ScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFScale),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(), 
        "frame", 
        "        Select the frame of the image to be used. See OSG::Image about details\n        concerning multi-frame images.\n        @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now. \endhint\n",
        FrameFieldId, FrameFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFFrame),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFFrame));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "minFilter", 
        "        The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n",
        MinFilterFieldId, MinFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFMinFilter),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFMinFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "magFilter", 
        "        The magnification filter, default GL_LINEAR.\n",
        MagFilterFieldId, MagFilterFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFMagFilter),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFMagFilter));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapS", 
        "        Texture coordinate S wrapping, default GL_REPEAT.\n",
        WrapSFieldId, WrapSFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapS),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapS));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapT", 
        "        Texture coordinate T wrapping, default GL_REPEAT.\n",
        WrapTFieldId, WrapTFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapT),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapT));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "wrapR", 
        "        Texture coordinate R wrapping, default GL_REPEAT.\n",
        WrapRFieldId, WrapRFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFWrapR),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFWrapR));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envMode", 
        "        Texture environment mode, default GL_REPLACE\n",
        EnvModeFieldId, EnvModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvMode),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(), 
        "envColor", 
        "        Texture environment color default transparent black.\n",
        EnvColorFieldId, EnvColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvColor),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envCombineRGB", 
        "        Texture environment rgb combine mode, default GL_MODULATE\n",
        EnvCombineRGBFieldId, EnvCombineRGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvCombineRGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvCombineRGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envCombineAlpha", 
        "        Texture environment alpha combine mode, default GL_MODULATE\n",
        EnvCombineAlphaFieldId, EnvCombineAlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvCombineAlpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvCombineAlpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "envScaleRGB", 
        "        Texture environment combine rgb scale factor, default 1.f\n",
        EnvScaleRGBFieldId, EnvScaleRGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvScaleRGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvScaleRGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "envScaleAlpha", 
        "        Texture environment combine alpha scale factor, default 1.f\n",
        EnvScaleAlphaFieldId, EnvScaleAlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvScaleAlpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvScaleAlpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource0RGB", 
        "        Texture environment combine source 0 rgb, default GL_TEXTURE\n",
        EnvSource0RGBFieldId, EnvSource0RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvSource0RGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvSource0RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource1RGB", 
        "        Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT\n",
        EnvSource1RGBFieldId, EnvSource1RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvSource1RGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvSource1RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource2RGB", 
        "        Texture environment combine source 2 rgb, default GL_CONSTANT_EXT\n",
        EnvSource2RGBFieldId, EnvSource2RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvSource2RGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvSource2RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource0Alpha", 
        "        Texture environment combine source 0 alpha, default GL_TEXTURE\n",
        EnvSource0AlphaFieldId, EnvSource0AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvSource0Alpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvSource0Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource1Alpha", 
        "        Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT\n",
        EnvSource1AlphaFieldId, EnvSource1AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvSource1Alpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvSource1Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envSource2Alpha", 
        "        Texture environment combine source 2 alpha, default GL_CONSTANT_EXT\n",
        EnvSource2AlphaFieldId, EnvSource2AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvSource2Alpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvSource2Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand0RGB", 
        "        Texture environment combine operand 0 rgb, default GL_SRC_COLOR\n",
        EnvOperand0RGBFieldId, EnvOperand0RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvOperand0RGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvOperand0RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand1RGB", 
        "        Texture environment combine operand 1 rgb, default GL_SRC_COLOR\n",
        EnvOperand1RGBFieldId, EnvOperand1RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvOperand1RGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvOperand1RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand2RGB", 
        "        Texture environment combine operand 2 rgb, default GL_SRC_ALPHA\n",
        EnvOperand2RGBFieldId, EnvOperand2RGBFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvOperand2RGB),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvOperand2RGB));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand0Alpha", 
        "        Texture environment combine operand 0 alpha, default GL_SRC_ALPHA\n",
        EnvOperand0AlphaFieldId, EnvOperand0AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvOperand0Alpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvOperand0Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand1Alpha", 
        "        Texture environment combine operand 1 alpha, default GL_SRC_ALPHA\n",
        EnvOperand1AlphaFieldId, EnvOperand1AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvOperand1Alpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvOperand1Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "envOperand2Alpha", 
        "        Texture environment combine operand 2 alpha, default GL_SRC_ALPHA\n",
        EnvOperand2AlphaFieldId, EnvOperand2AlphaFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFEnvOperand2Alpha),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFEnvOperand2Alpha));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "GLId", 
        "        The OpenGL texture id for this texture.\n",
        GLIdFieldId, GLIdFieldMask,
        true,
        (Field::FClusterLocal),
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFGLId),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFGLId));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "IgnoreGLForAspect", 
        "	    Don't do any GL calls for aspect of given id.\n",
        IgnoreGLForAspectFieldId, IgnoreGLForAspectFieldMask,
        true,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFIgnoreGLForAspect),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFIgnoreGLForAspect));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(), 
        "pointSprite", 
        "        Flag to use this texture for Point Sprites.\n",
        PointSpriteFieldId, PointSpriteFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFPointSprite),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFPointSprite));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "priority", 
        "        Priority of this texture, between 0 and 1, the default is 0.\n",
        PriorityFieldId, PriorityFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFPriority),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFPriority));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "shaderOperation", 
        "        Shader operation of this texture unit, default GL_NONE. If unit 0 uses\n        GL_NONE, shading is switched off.\n",
        ShaderOperationFieldId, ShaderOperationFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderOperation),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderOperation));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "shaderInput", 
        "        Input texture unit for this shader's operation.\n",
        ShaderInputFieldId, ShaderInputFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderInput),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderInput));

    oType.addInitialDesc(pDesc);

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(), 
        "shaderOffsetMatrix", 
        "        The 2x2 transformation matrix for offset textures.\n",
        ShaderOffsetMatrixFieldId, ShaderOffsetMatrixFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editMFShaderOffsetMatrix),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getMFShaderOffsetMatrix));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "shaderOffsetScale", 
        "        The scaling factor for scaled offset textures.\n",
        ShaderOffsetScaleFieldId, ShaderOffsetScaleFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderOffsetScale),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderOffsetScale));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "shaderOffsetBias", 
        "        The bias factor for scaled offset textures.\n",
        ShaderOffsetBiasFieldId, ShaderOffsetBiasFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderOffsetBias),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderOffsetBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "shaderRGBADotProduct", 
        "        The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.\n",
        ShaderRGBADotProductFieldId, ShaderRGBADotProductFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderRGBADotProduct),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderRGBADotProduct));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt8::Description(
        SFUInt8::getClassType(), 
        "shaderCullModes", 
        "        The CULL_MODES_NV value, coded into a single byte. The first 4 bits of\n        the byte are used to indicate the wnated cull modes, a value of 0 \n        signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for \n        the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 \n        (mask 8) for Q.\n",
        ShaderCullModesFieldId, ShaderCullModesFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderCullModes),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderCullModes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFVec3f::Description(
        SFVec3f::getClassType(), 
        "shaderConstEye", 
        "        The CONST_EYE_NV value, i.e. the constant eye position used by the \n        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.\n",
        ShaderConstEyeFieldId, ShaderConstEyeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFShaderConstEye),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFShaderConstEye));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "lodBias", 
        "        Bias of LOD calculation for texture access.\n    \n",
        LodBiasFieldId, LodBiasFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFLodBias),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFLodBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "target", 
        "        Texture target. Overwrite automatically determined texture target\n        based on the parameters of the assigned image if set to anything \n        else than GL_NONE. Used for nVidia's rectangle textures. Be careful\n        when using it!\n    \n    \n",
        TargetFieldId, TargetFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFTarget),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFTarget));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyLeft", 
        "        Left coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyLeftFieldId, DirtyLeftFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyLeft),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyLeft));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinX", 
        "        Minimum X coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyMinXFieldId, DirtyMinXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinX),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxX", 
        "        Maximum X coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyMaxXFieldId, DirtyMaxXFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxX),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxX));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinY", 
        "        Minimum Y coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyMinYFieldId, DirtyMinYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinY),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxY", 
        "        Maximum Y coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyMaxYFieldId, DirtyMaxYFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxY),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxY));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMinZ", 
        "        Minimum Z coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyMinZFieldId, DirtyMinZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMinZ),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMinZ));

    oType.addInitialDesc(pDesc);

    pDesc = new SFInt32::Description(
        SFInt32::getClassType(), 
        "dirtyMaxZ", 
        "        Maximum Z coordinate of the dirty rectangle to use for \n        imageContentChanged(). This doesn't make sense to be stored in files, \n        it does make sense on a cluster, though, that's why it's external.\n    \n    \n",
        DirtyMaxZFieldId, DirtyMaxZFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDirtyMaxZ),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDirtyMaxZ));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(), 
        "anisotropy", 
        "        Anisotropic filtering the default 1.0f means isotropic filtering.\n        \n",
        AnisotropyFieldId, AnisotropyFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFAnisotropy),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFAnisotropy));

    oType.addInitialDesc(pDesc);

    pDesc = new SFColor4f::Description(
        SFColor4f::getClassType(), 
        "borderColor", 
        "	Texture border color\n",
        BorderColorFieldId, BorderColorFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFBorderColor),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFBorderColor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "compareMode", 
        "",
        CompareModeFieldId, CompareModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFCompareMode),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFCompareMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "compareFunc", 
        "",
        CompareFuncFieldId, CompareFuncFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFCompareFunc),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFCompareFunc));

    oType.addInitialDesc(pDesc);

    pDesc = new SFGLenum::Description(
        SFGLenum::getClassType(), 
        "depthMode", 
        "",
        DepthModeFieldId, DepthModeFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&TextureObjChunkBase::editSFDepthMode),
        reinterpret_cast<FieldGetMethodSig >(&TextureObjChunkBase::getSFDepthMode));

    oType.addInitialDesc(pDesc);
}


TextureObjChunkBase::TypeObject TextureObjChunkBase::_type(true,
    TextureObjChunkBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &TextureObjChunkBase::createEmpty,
    TextureObjChunk::initMethod,
    (InitalInsertDescFunc) &TextureObjChunkBase::classDescInserter,
    false,
    "<?xml version=\"1.0\"?>\n"
"\n"
"<FieldContainer\n"
"	name=\"TextureObjChunk\"\n"
"	parent=\"TextureBaseChunk\"\n"
"	library=\"System\"\n"
"	pointerfieldtypes=\"both\"\n"
"	structure=\"concrete\"\n"
"	systemcomponent=\"true\"\n"
"	parentsystemcomponent=\"true\"\n"
"	decoratable=\"false\"\n"
"	useLocalIncludes=\"false\"\n"
">\n"
"	<Field\n"
"		name=\"image\"\n"
"		type=\"ImagePtr\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"internalFormat\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_NONE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"	The internal texture format.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"externalFormat\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_NONE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"	    The external texture format - overwrites \n"
"        external format of image when set to a value not equal to \n"
"        GL_NONE (which is the default).\n"
"	</Field>\n"
"	<Field\n"
"		name=\"scale\"\n"
"		type=\"bool\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"true\"\n"
"		access=\"public\"\n"
"	>\n"
"        Specifies whether the image should be scaled to the next power of two,\n"
"        thus filling the whole texture coordinate range, or if it should be put\n"
"        in the lower left corner, leaving the rest of the texture undefined.\n"
"        This is mainly used for rapidly changing non power of two textures, to\n"
"        get around the scaling overhead.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"frame\"\n"
"		type=\"UInt32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"0\"\n"
"		access=\"public\"\n"
"	>\n"
"        Select the frame of the image to be used. See OSG::Image about details\n"
"        concerning multi-frame images.\n"
"        @hint For fast update use GL_LINEAR or GL_NEAREST filters, as mipmap creation is slow right now. \endhint\n"
"	</Field>\n"
"	<Field\n"
"		name=\"minFilter\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_LINEAR_MIPMAP_LINEAR\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        The minimisation filter, default GL_LINEAR_MIPMAP_LINEAR.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"magFilter\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_LINEAR\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        The magnification filter, default GL_LINEAR.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"wrapS\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_REPEAT\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture coordinate S wrapping, default GL_REPEAT.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"wrapT\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_REPEAT\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture coordinate T wrapping, default GL_REPEAT.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"wrapR\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_REPEAT\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture coordinate R wrapping, default GL_REPEAT.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envMode\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_REPLACE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment mode, default GL_REPLACE\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envColor\"\n"
"		type=\"Color4f\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"0,0,0,0\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment color default transparent black.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envCombineRGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_MODULATE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment rgb combine mode, default GL_MODULATE\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envCombineAlpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_MODULATE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment alpha combine mode, default GL_MODULATE\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envScaleRGB\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1.0f\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine rgb scale factor, default 1.f\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envScaleAlpha\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"1.0f\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine alpha scale factor, default 1.f\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envSource0RGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_TEXTURE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine source 0 rgb, default GL_TEXTURE\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envSource1RGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_PREVIOUS_EXT\"\n"
"		defaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine source 1 rgb, default GL_PREVIOUS_EXT\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envSource2RGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_CONSTANT_EXT\"\n"
"		defaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine source 2 rgb, default GL_CONSTANT_EXT\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envSource0Alpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_TEXTURE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine source 0 alpha, default GL_TEXTURE\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envSource1Alpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_PREVIOUS_EXT\"\n"
"		defaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine source 1 alpha, default GL_PREVIOUS_EXT\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envSource2Alpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_CONSTANT_EXT\"\n"
"		defaultHeader=\"&lt;OSGGLEXT.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine source 2 alpha, default GL_CONSTANT_EXT\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envOperand0RGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_SRC_COLOR\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine operand 0 rgb, default GL_SRC_COLOR\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envOperand1RGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_SRC_COLOR\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine operand 1 rgb, default GL_SRC_COLOR\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envOperand2RGB\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_SRC_ALPHA\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine operand 2 rgb, default GL_SRC_ALPHA\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envOperand0Alpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_SRC_ALPHA\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine operand 0 alpha, default GL_SRC_ALPHA\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envOperand1Alpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_SRC_ALPHA\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine operand 1 alpha, default GL_SRC_ALPHA\n"
"	</Field>\n"
"	<Field\n"
"		name=\"envOperand2Alpha\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_SRC_ALPHA\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"        Texture environment combine operand 2 alpha, default GL_SRC_ALPHA\n"
"	</Field>\n"
"	<Field\n"
"		name=\"GLId\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"internal\"\n"
"		access=\"public\"\n"
"		defaultValue=\"0\"\n"
"        fieldFlags=\"FClusterLocal\"\n"
"	>\n"
"        The OpenGL texture id for this texture.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"IgnoreGLForAspect\"\n"
"		type=\"Int32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"internal\"\n"
"		defaultValue=\"-1\"\n"
"		access=\"public\"\n"
"	>\n"
"	    Don't do any GL calls for aspect of given id.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"pointSprite\"\n"
"		type=\"bool\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"GL_FALSE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"	>\n"
"        Flag to use this texture for Point Sprites.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"priority\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"1.f\"\n"
"	>\n"
"        Priority of this texture, between 0 and 1, the default is 0.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderOperation\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"GL_NONE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"	>\n"
"        Shader operation of this texture unit, default GL_NONE. If unit 0 uses\n"
"        GL_NONE, shading is switched off.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderInput\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"GL_NONE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"	>\n"
"        Input texture unit for this shader's operation.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderOffsetMatrix\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"multi\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"	>\n"
"        The 2x2 transformation matrix for offset textures.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderOffsetScale\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"1.f\"\n"
"	>\n"
"        The scaling factor for scaled offset textures.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderOffsetBias\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"0.f\"\n"
"	>\n"
"        The bias factor for scaled offset textures.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderRGBADotProduct\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"GL_NONE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"	>\n"
"        The RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV value.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderCullModes\"\n"
"		type=\"UInt8\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"0\"\n"
"	>\n"
"        The CULL_MODES_NV value, coded into a single byte. The first 4 bits of\n"
"        the byte are used to indicate the wnated cull modes, a value of 0 \n"
"        signifies GL_LESS, a value of 1 GL_GEQUAL. Bit 0 (mask 1) is used for \n"
"        the S coordinate, bit 1 (mask 2) for T, bit 2 (mask 4) for R and bit 4 \n"
"        (mask 8) for Q.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"shaderConstEye\"\n"
"		type=\"Vec3f\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"	>\n"
"        The CONST_EYE_NV value, i.e. the constant eye position used by the \n"
"        DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV shader.\n"
"	</Field>\n"
"	<Field\n"
"		name=\"lodBias\"\n"
"		type=\"Real32\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		access=\"public\"\n"
"		defaultValue=\"0.f\"\n"
"		defaultHeader=\"\"\n"
"	>\n"
"        Bias of LOD calculation for texture access.\n"
"	</Field>\n"
"    <Field\n"
"        name=\"target\"\n"
"        type=\"GLenum\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"GL_NONE\"\n"
"        defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"        access=\"public\"\n"
"    >\n"
"        Texture target. Overwrite automatically determined texture target\n"
"        based on the parameters of the assigned image if set to anything \n"
"        else than GL_NONE. Used for nVidia's rectangle textures. Be careful\n"
"        when using it!\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyLeft\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Left coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyMinX\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Minimum X coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyMaxX\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Maximum X coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyMinY\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Minimum Y coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyMaxY\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Maximum Y coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyMinZ\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Minimum Z coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"dirtyMaxZ\"\n"
"        type=\"Int32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"-1\"\n"
"        access=\"public\"\n"
"    >\n"
"        Maximum Z coordinate of the dirty rectangle to use for \n"
"        imageContentChanged(). This doesn't make sense to be stored in files, \n"
"        it does make sense on a cluster, though, that's why it's external.\n"
"    </Field>\n"
"    <Field\n"
"        name=\"anisotropy\"\n"
"        type=\"Real32\"\n"
"        cardinality=\"single\"\n"
"        visibility=\"external\"\n"
"        defaultValue=\"1.0f\"\n"
"        access=\"public\"\n"
"    >\n"
"        Anisotropic filtering the default 1.0f means isotropic filtering.\n"
"        </Field>\n"
"	<Field\n"
"		name=\"borderColor\"\n"
"		type=\"Color4f\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"0,0,0,0\"\n"
"		access=\"public\"\n"
"	>\n"
"	Texture border color\n"
"	</Field>\n"
"	<Field\n"
"		name=\"compareMode\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_NONE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"compareFunc\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_LEQUAL\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"	<Field\n"
"		name=\"depthMode\"\n"
"		type=\"GLenum\"\n"
"		cardinality=\"single\"\n"
"		visibility=\"external\"\n"
"		defaultValue=\"GL_LUMINANCE\"\n"
"		defaultHeader=\"&lt;OSGGL.h&gt;\"\n"
"		access=\"public\"\n"
"	>\n"
"	</Field>\n"
"</FieldContainer>\n"
,
    "" 
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &TextureObjChunkBase::getType(void) 
{
    return _type; 
} 

const FieldContainerType &TextureObjChunkBase::getType(void) const 
{
    return _type;
} 

UInt32 TextureObjChunkBase::getContainerSize(void) const 
{ 
    return sizeof(TextureObjChunk); 
}

/*------------------------- decorator get ------------------------------*/


//! Get the TextureObjChunk::_sfImage field.
const SFImagePtr *TextureObjChunkBase::getSFImage(void) const
{
    return &_sfImage;
}

SFGLenum *TextureObjChunkBase::editSFInternalFormat(void)
{
    editSField(InternalFormatFieldMask);

    return &_sfInternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFInternalFormat(void) const
{
    return &_sfInternalFormat;
}


SFGLenum *TextureObjChunkBase::editSFExternalFormat(void)
{
    editSField(ExternalFormatFieldMask);

    return &_sfExternalFormat;
}

const SFGLenum *TextureObjChunkBase::getSFExternalFormat(void) const
{
    return &_sfExternalFormat;
}


SFBool *TextureObjChunkBase::editSFScale(void)
{
    editSField(ScaleFieldMask);

    return &_sfScale;
}

const SFBool *TextureObjChunkBase::getSFScale(void) const
{
    return &_sfScale;
}


SFUInt32 *TextureObjChunkBase::editSFFrame(void)
{
    editSField(FrameFieldMask);

    return &_sfFrame;
}

const SFUInt32 *TextureObjChunkBase::getSFFrame(void) const
{
    return &_sfFrame;
}


SFGLenum *TextureObjChunkBase::editSFMinFilter(void)
{
    editSField(MinFilterFieldMask);

    return &_sfMinFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMinFilter(void) const
{
    return &_sfMinFilter;
}


SFGLenum *TextureObjChunkBase::editSFMagFilter(void)
{
    editSField(MagFilterFieldMask);

    return &_sfMagFilter;
}

const SFGLenum *TextureObjChunkBase::getSFMagFilter(void) const
{
    return &_sfMagFilter;
}


SFGLenum *TextureObjChunkBase::editSFWrapS(void)
{
    editSField(WrapSFieldMask);

    return &_sfWrapS;
}

const SFGLenum *TextureObjChunkBase::getSFWrapS(void) const
{
    return &_sfWrapS;
}


SFGLenum *TextureObjChunkBase::editSFWrapT(void)
{
    editSField(WrapTFieldMask);

    return &_sfWrapT;
}

const SFGLenum *TextureObjChunkBase::getSFWrapT(void) const
{
    return &_sfWrapT;
}


SFGLenum *TextureObjChunkBase::editSFWrapR(void)
{
    editSField(WrapRFieldMask);

    return &_sfWrapR;
}

const SFGLenum *TextureObjChunkBase::getSFWrapR(void) const
{
    return &_sfWrapR;
}


SFGLenum *TextureObjChunkBase::editSFEnvMode(void)
{
    editSField(EnvModeFieldMask);

    return &_sfEnvMode;
}

const SFGLenum *TextureObjChunkBase::getSFEnvMode(void) const
{
    return &_sfEnvMode;
}


SFColor4f *TextureObjChunkBase::editSFEnvColor(void)
{
    editSField(EnvColorFieldMask);

    return &_sfEnvColor;
}

const SFColor4f *TextureObjChunkBase::getSFEnvColor(void) const
{
    return &_sfEnvColor;
}


SFGLenum *TextureObjChunkBase::editSFEnvCombineRGB(void)
{
    editSField(EnvCombineRGBFieldMask);

    return &_sfEnvCombineRGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvCombineRGB(void) const
{
    return &_sfEnvCombineRGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvCombineAlpha(void)
{
    editSField(EnvCombineAlphaFieldMask);

    return &_sfEnvCombineAlpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvCombineAlpha(void) const
{
    return &_sfEnvCombineAlpha;
}


SFReal32 *TextureObjChunkBase::editSFEnvScaleRGB(void)
{
    editSField(EnvScaleRGBFieldMask);

    return &_sfEnvScaleRGB;
}

const SFReal32 *TextureObjChunkBase::getSFEnvScaleRGB(void) const
{
    return &_sfEnvScaleRGB;
}


SFReal32 *TextureObjChunkBase::editSFEnvScaleAlpha(void)
{
    editSField(EnvScaleAlphaFieldMask);

    return &_sfEnvScaleAlpha;
}

const SFReal32 *TextureObjChunkBase::getSFEnvScaleAlpha(void) const
{
    return &_sfEnvScaleAlpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource0RGB(void)
{
    editSField(EnvSource0RGBFieldMask);

    return &_sfEnvSource0RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource0RGB(void) const
{
    return &_sfEnvSource0RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource1RGB(void)
{
    editSField(EnvSource1RGBFieldMask);

    return &_sfEnvSource1RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource1RGB(void) const
{
    return &_sfEnvSource1RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource2RGB(void)
{
    editSField(EnvSource2RGBFieldMask);

    return &_sfEnvSource2RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource2RGB(void) const
{
    return &_sfEnvSource2RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource0Alpha(void)
{
    editSField(EnvSource0AlphaFieldMask);

    return &_sfEnvSource0Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource0Alpha(void) const
{
    return &_sfEnvSource0Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource1Alpha(void)
{
    editSField(EnvSource1AlphaFieldMask);

    return &_sfEnvSource1Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource1Alpha(void) const
{
    return &_sfEnvSource1Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvSource2Alpha(void)
{
    editSField(EnvSource2AlphaFieldMask);

    return &_sfEnvSource2Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvSource2Alpha(void) const
{
    return &_sfEnvSource2Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand0RGB(void)
{
    editSField(EnvOperand0RGBFieldMask);

    return &_sfEnvOperand0RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand0RGB(void) const
{
    return &_sfEnvOperand0RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand1RGB(void)
{
    editSField(EnvOperand1RGBFieldMask);

    return &_sfEnvOperand1RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand1RGB(void) const
{
    return &_sfEnvOperand1RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand2RGB(void)
{
    editSField(EnvOperand2RGBFieldMask);

    return &_sfEnvOperand2RGB;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand2RGB(void) const
{
    return &_sfEnvOperand2RGB;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand0Alpha(void)
{
    editSField(EnvOperand0AlphaFieldMask);

    return &_sfEnvOperand0Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand0Alpha(void) const
{
    return &_sfEnvOperand0Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand1Alpha(void)
{
    editSField(EnvOperand1AlphaFieldMask);

    return &_sfEnvOperand1Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand1Alpha(void) const
{
    return &_sfEnvOperand1Alpha;
}


SFGLenum *TextureObjChunkBase::editSFEnvOperand2Alpha(void)
{
    editSField(EnvOperand2AlphaFieldMask);

    return &_sfEnvOperand2Alpha;
}

const SFGLenum *TextureObjChunkBase::getSFEnvOperand2Alpha(void) const
{
    return &_sfEnvOperand2Alpha;
}


SFGLenum *TextureObjChunkBase::editSFGLId(void)
{
    editSField(GLIdFieldMask);

    return &_sfGLId;
}

const SFGLenum *TextureObjChunkBase::getSFGLId(void) const
{
    return &_sfGLId;
}


SFInt32 *TextureObjChunkBase::editSFIgnoreGLForAspect(void)
{
    editSField(IgnoreGLForAspectFieldMask);

    return &_sfIgnoreGLForAspect;
}

const SFInt32 *TextureObjChunkBase::getSFIgnoreGLForAspect(void) const
{
    return &_sfIgnoreGLForAspect;
}


SFBool *TextureObjChunkBase::editSFPointSprite(void)
{
    editSField(PointSpriteFieldMask);

    return &_sfPointSprite;
}

const SFBool *TextureObjChunkBase::getSFPointSprite(void) const
{
    return &_sfPointSprite;
}


SFReal32 *TextureObjChunkBase::editSFPriority(void)
{
    editSField(PriorityFieldMask);

    return &_sfPriority;
}

const SFReal32 *TextureObjChunkBase::getSFPriority(void) const
{
    return &_sfPriority;
}


SFGLenum *TextureObjChunkBase::editSFShaderOperation(void)
{
    editSField(ShaderOperationFieldMask);

    return &_sfShaderOperation;
}

const SFGLenum *TextureObjChunkBase::getSFShaderOperation(void) const
{
    return &_sfShaderOperation;
}


SFGLenum *TextureObjChunkBase::editSFShaderInput(void)
{
    editSField(ShaderInputFieldMask);

    return &_sfShaderInput;
}

const SFGLenum *TextureObjChunkBase::getSFShaderInput(void) const
{
    return &_sfShaderInput;
}


MFReal32 *TextureObjChunkBase::editMFShaderOffsetMatrix(void)
{
    editMField(ShaderOffsetMatrixFieldMask, _mfShaderOffsetMatrix);

    return &_mfShaderOffsetMatrix;
}

const MFReal32 *TextureObjChunkBase::getMFShaderOffsetMatrix(void) const
{
    return &_mfShaderOffsetMatrix;
}


SFReal32 *TextureObjChunkBase::editSFShaderOffsetScale(void)
{
    editSField(ShaderOffsetScaleFieldMask);

    return &_sfShaderOffsetScale;
}

const SFReal32 *TextureObjChunkBase::getSFShaderOffsetScale(void) const
{
    return &_sfShaderOffsetScale;
}


SFReal32 *TextureObjChunkBase::editSFShaderOffsetBias(void)
{
    editSField(ShaderOffsetBiasFieldMask);

    return &_sfShaderOffsetBias;
}

const SFReal32 *TextureObjChunkBase::getSFShaderOffsetBias(void) const
{
    return &_sfShaderOffsetBias;
}


SFGLenum *TextureObjChunkBase::editSFShaderRGBADotProduct(void)
{
    editSField(ShaderRGBADotProductFieldMask);

    return &_sfShaderRGBADotProduct;
}

const SFGLenum *TextureObjChunkBase::getSFShaderRGBADotProduct(void) const
{
    return &_sfShaderRGBADotProduct;
}


SFUInt8 *TextureObjChunkBase::editSFShaderCullModes(void)
{
    editSField(ShaderCullModesFieldMask);

    return &_sfShaderCullModes;
}

const SFUInt8 *TextureObjChunkBase::getSFShaderCullModes(void) const
{
    return &_sfShaderCullModes;
}


SFVec3f *TextureObjChunkBase::editSFShaderConstEye(void)
{
    editSField(ShaderConstEyeFieldMask);

    return &_sfShaderConstEye;
}

const SFVec3f *TextureObjChunkBase::getSFShaderConstEye(void) const
{
    return &_sfShaderConstEye;
}


SFReal32 *TextureObjChunkBase::editSFLodBias(void)
{
    editSField(LodBiasFieldMask);

    return &_sfLodBias;
}

const SFReal32 *TextureObjChunkBase::getSFLodBias(void) const
{
    return &_sfLodBias;
}


SFGLenum *TextureObjChunkBase::editSFTarget(void)
{
    editSField(TargetFieldMask);

    return &_sfTarget;
}

const SFGLenum *TextureObjChunkBase::getSFTarget(void) const
{
    return &_sfTarget;
}


SFInt32 *TextureObjChunkBase::editSFDirtyLeft(void)
{
    editSField(DirtyLeftFieldMask);

    return &_sfDirtyLeft;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyLeft(void) const
{
    return &_sfDirtyLeft;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMinX(void)
{
    editSField(DirtyMinXFieldMask);

    return &_sfDirtyMinX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinX(void) const
{
    return &_sfDirtyMinX;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMaxX(void)
{
    editSField(DirtyMaxXFieldMask);

    return &_sfDirtyMaxX;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxX(void) const
{
    return &_sfDirtyMaxX;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMinY(void)
{
    editSField(DirtyMinYFieldMask);

    return &_sfDirtyMinY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinY(void) const
{
    return &_sfDirtyMinY;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMaxY(void)
{
    editSField(DirtyMaxYFieldMask);

    return &_sfDirtyMaxY;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxY(void) const
{
    return &_sfDirtyMaxY;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMinZ(void)
{
    editSField(DirtyMinZFieldMask);

    return &_sfDirtyMinZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMinZ(void) const
{
    return &_sfDirtyMinZ;
}


SFInt32 *TextureObjChunkBase::editSFDirtyMaxZ(void)
{
    editSField(DirtyMaxZFieldMask);

    return &_sfDirtyMaxZ;
}

const SFInt32 *TextureObjChunkBase::getSFDirtyMaxZ(void) const
{
    return &_sfDirtyMaxZ;
}


SFReal32 *TextureObjChunkBase::editSFAnisotropy(void)
{
    editSField(AnisotropyFieldMask);

    return &_sfAnisotropy;
}

const SFReal32 *TextureObjChunkBase::getSFAnisotropy(void) const
{
    return &_sfAnisotropy;
}


SFColor4f *TextureObjChunkBase::editSFBorderColor(void)
{
    editSField(BorderColorFieldMask);

    return &_sfBorderColor;
}

const SFColor4f *TextureObjChunkBase::getSFBorderColor(void) const
{
    return &_sfBorderColor;
}


SFGLenum *TextureObjChunkBase::editSFCompareMode(void)
{
    editSField(CompareModeFieldMask);

    return &_sfCompareMode;
}

const SFGLenum *TextureObjChunkBase::getSFCompareMode(void) const
{
    return &_sfCompareMode;
}


SFGLenum *TextureObjChunkBase::editSFCompareFunc(void)
{
    editSField(CompareFuncFieldMask);

    return &_sfCompareFunc;
}

const SFGLenum *TextureObjChunkBase::getSFCompareFunc(void) const
{
    return &_sfCompareFunc;
}


SFGLenum *TextureObjChunkBase::editSFDepthMode(void)
{
    editSField(DepthModeFieldMask);

    return &_sfDepthMode;
}

const SFGLenum *TextureObjChunkBase::getSFDepthMode(void) const
{
    return &_sfDepthMode;
}



void TextureObjChunkBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureObjChunk *>(this)->setImage(
            cast_dynamic<ImagePtr>(pNewElement));
    }
}

void TextureObjChunkBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void TextureObjChunkBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void TextureObjChunkBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void TextureObjChunkBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void TextureObjChunkBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void TextureObjChunkBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == ImageFieldId)
    {
        static_cast<TextureObjChunk *>(this)->setImage(NullFC);
    }
}




/*------------------------------ access -----------------------------------*/

UInt32 TextureObjChunkBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        returnValue += _sfImage.getBinSize();
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        returnValue += _sfInternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        returnValue += _sfExternalFormat.getBinSize();
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        returnValue += _sfScale.getBinSize();
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        returnValue += _sfFrame.getBinSize();
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        returnValue += _sfMinFilter.getBinSize();
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        returnValue += _sfMagFilter.getBinSize();
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        returnValue += _sfWrapS.getBinSize();
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        returnValue += _sfWrapT.getBinSize();
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        returnValue += _sfWrapR.getBinSize();
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        returnValue += _sfEnvMode.getBinSize();
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        returnValue += _sfEnvColor.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        returnValue += _sfEnvCombineRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvCombineAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        returnValue += _sfEnvScaleRGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        returnValue += _sfEnvScaleAlpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvSource2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvSource2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2RGB.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand0Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand1Alpha.getBinSize();
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        returnValue += _sfEnvOperand2Alpha.getBinSize();
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        returnValue += _sfGLId.getBinSize();
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        returnValue += _sfIgnoreGLForAspect.getBinSize();
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        returnValue += _sfPointSprite.getBinSize();
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        returnValue += _sfPriority.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        returnValue += _sfShaderOperation.getBinSize();
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        returnValue += _sfShaderInput.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        returnValue += _mfShaderOffsetMatrix.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetScale.getBinSize();
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        returnValue += _sfShaderOffsetBias.getBinSize();
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        returnValue += _sfShaderRGBADotProduct.getBinSize();
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        returnValue += _sfShaderCullModes.getBinSize();
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        returnValue += _sfShaderConstEye.getBinSize();
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        returnValue += _sfLodBias.getBinSize();
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        returnValue += _sfTarget.getBinSize();
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        returnValue += _sfDirtyLeft.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        returnValue += _sfDirtyMinX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxX.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        returnValue += _sfDirtyMinY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxY.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        returnValue += _sfDirtyMinZ.getBinSize();
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        returnValue += _sfDirtyMaxZ.getBinSize();
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        returnValue += _sfAnisotropy.getBinSize();
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        returnValue += _sfBorderColor.getBinSize();
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        returnValue += _sfCompareMode.getBinSize();
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        returnValue += _sfCompareFunc.getBinSize();
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        returnValue += _sfDepthMode.getBinSize();
    }

    return returnValue;
}

void TextureObjChunkBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyToBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyToBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyToBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyToBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyToBin(pMem);
    }
}

void TextureObjChunkBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (ImageFieldMask & whichField))
    {
        _sfImage.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (InternalFormatFieldMask & whichField))
    {
        _sfInternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExternalFormatFieldMask & whichField))
    {
        _sfExternalFormat.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ScaleFieldMask & whichField))
    {
        _sfScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrameFieldMask & whichField))
    {
        _sfFrame.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MinFilterFieldMask & whichField))
    {
        _sfMinFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MagFilterFieldMask & whichField))
    {
        _sfMagFilter.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapSFieldMask & whichField))
    {
        _sfWrapS.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapTFieldMask & whichField))
    {
        _sfWrapT.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (WrapRFieldMask & whichField))
    {
        _sfWrapR.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvModeFieldMask & whichField))
    {
        _sfEnvMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvColorFieldMask & whichField))
    {
        _sfEnvColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineRGBFieldMask & whichField))
    {
        _sfEnvCombineRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvCombineAlphaFieldMask & whichField))
    {
        _sfEnvCombineAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleRGBFieldMask & whichField))
    {
        _sfEnvScaleRGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvScaleAlphaFieldMask & whichField))
    {
        _sfEnvScaleAlpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0RGBFieldMask & whichField))
    {
        _sfEnvSource0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1RGBFieldMask & whichField))
    {
        _sfEnvSource1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2RGBFieldMask & whichField))
    {
        _sfEnvSource2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource0AlphaFieldMask & whichField))
    {
        _sfEnvSource0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource1AlphaFieldMask & whichField))
    {
        _sfEnvSource1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvSource2AlphaFieldMask & whichField))
    {
        _sfEnvSource2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0RGBFieldMask & whichField))
    {
        _sfEnvOperand0RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1RGBFieldMask & whichField))
    {
        _sfEnvOperand1RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2RGBFieldMask & whichField))
    {
        _sfEnvOperand2RGB.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand0AlphaFieldMask & whichField))
    {
        _sfEnvOperand0Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand1AlphaFieldMask & whichField))
    {
        _sfEnvOperand1Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnvOperand2AlphaFieldMask & whichField))
    {
        _sfEnvOperand2Alpha.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GLIdFieldMask & whichField))
    {
        _sfGLId.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (IgnoreGLForAspectFieldMask & whichField))
    {
        _sfIgnoreGLForAspect.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PointSpriteFieldMask & whichField))
    {
        _sfPointSprite.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (PriorityFieldMask & whichField))
    {
        _sfPriority.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOperationFieldMask & whichField))
    {
        _sfShaderOperation.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderInputFieldMask & whichField))
    {
        _sfShaderInput.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetMatrixFieldMask & whichField))
    {
        _mfShaderOffsetMatrix.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetScaleFieldMask & whichField))
    {
        _sfShaderOffsetScale.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderOffsetBiasFieldMask & whichField))
    {
        _sfShaderOffsetBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderRGBADotProductFieldMask & whichField))
    {
        _sfShaderRGBADotProduct.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCullModesFieldMask & whichField))
    {
        _sfShaderCullModes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderConstEyeFieldMask & whichField))
    {
        _sfShaderConstEye.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LodBiasFieldMask & whichField))
    {
        _sfLodBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TargetFieldMask & whichField))
    {
        _sfTarget.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyLeftFieldMask & whichField))
    {
        _sfDirtyLeft.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinXFieldMask & whichField))
    {
        _sfDirtyMinX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxXFieldMask & whichField))
    {
        _sfDirtyMaxX.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinYFieldMask & whichField))
    {
        _sfDirtyMinY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxYFieldMask & whichField))
    {
        _sfDirtyMaxY.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMinZFieldMask & whichField))
    {
        _sfDirtyMinZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DirtyMaxZFieldMask & whichField))
    {
        _sfDirtyMaxZ.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AnisotropyFieldMask & whichField))
    {
        _sfAnisotropy.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BorderColorFieldMask & whichField))
    {
        _sfBorderColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareModeFieldMask & whichField))
    {
        _sfCompareMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (CompareFuncFieldMask & whichField))
    {
        _sfCompareFunc.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DepthModeFieldMask & whichField))
    {
        _sfDepthMode.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
TextureObjChunkPtr TextureObjChunkBase::createEmpty(void) 
{ 
    TextureObjChunkPtr returnValue; 
    
    newPtr<TextureObjChunk>(returnValue); 

    return returnValue; 
}

FieldContainerPtr TextureObjChunkBase::shallowCopy(void) const 
{ 
    TextureObjChunkPtr returnValue; 

    newPtr(returnValue, dynamic_cast<const TextureObjChunk *>(this)); 

    return returnValue; 
}



/*------------------------- constructors ----------------------------------*/

TextureObjChunkBase::TextureObjChunkBase(void) :
    Inherited(),
    _sfImage(),
    _sfInternalFormat(GLenum(GL_NONE)),
    _sfExternalFormat(GLenum(GL_NONE)),
    _sfScale(bool(true)),
    _sfFrame(UInt32(0)),
    _sfMinFilter(GLenum(GL_LINEAR_MIPMAP_LINEAR)),
    _sfMagFilter(GLenum(GL_LINEAR)),
    _sfWrapS(GLenum(GL_REPEAT)),
    _sfWrapT(GLenum(GL_REPEAT)),
    _sfWrapR(GLenum(GL_REPEAT)),
    _sfEnvMode(GLenum(GL_REPLACE)),
    _sfEnvColor(Color4f(0,0,0,0)),
    _sfEnvCombineRGB(GLenum(GL_MODULATE)),
    _sfEnvCombineAlpha(GLenum(GL_MODULATE)),
    _sfEnvScaleRGB(Real32(1.0f)),
    _sfEnvScaleAlpha(Real32(1.0f)),
    _sfEnvSource0RGB(GLenum(GL_TEXTURE)),
    _sfEnvSource1RGB(GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2RGB(GLenum(GL_CONSTANT_EXT)),
    _sfEnvSource0Alpha(GLenum(GL_TEXTURE)),
    _sfEnvSource1Alpha(GLenum(GL_PREVIOUS_EXT)),
    _sfEnvSource2Alpha(GLenum(GL_CONSTANT_EXT)),
    _sfEnvOperand0RGB(GLenum(GL_SRC_COLOR)),
    _sfEnvOperand1RGB(GLenum(GL_SRC_COLOR)),
    _sfEnvOperand2RGB(GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand0Alpha(GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand1Alpha(GLenum(GL_SRC_ALPHA)),
    _sfEnvOperand2Alpha(GLenum(GL_SRC_ALPHA)),
    _sfGLId(GLenum(0)),
    _sfIgnoreGLForAspect(Int32(-1)),
    _sfPointSprite(bool(GL_FALSE)),
    _sfPriority(Real32(1.f)),
    _sfShaderOperation(GLenum(GL_NONE)),
    _sfShaderInput(GLenum(GL_NONE)),
    _mfShaderOffsetMatrix(),
    _sfShaderOffsetScale(Real32(1.f)),
    _sfShaderOffsetBias(Real32(0.f)),
    _sfShaderRGBADotProduct(GLenum(GL_NONE)),
    _sfShaderCullModes(UInt8(0)),
    _sfShaderConstEye(),
    _sfLodBias(Real32(0.f)),
    _sfTarget(GLenum(GL_NONE)),
    _sfDirtyLeft(Int32(-1)),
    _sfDirtyMinX(Int32(-1)),
    _sfDirtyMaxX(Int32(-1)),
    _sfDirtyMinY(Int32(-1)),
    _sfDirtyMaxY(Int32(-1)),
    _sfDirtyMinZ(Int32(-1)),
    _sfDirtyMaxZ(Int32(-1)),
    _sfAnisotropy(Real32(1.0f)),
    _sfBorderColor(Color4f(0,0,0,0)),
    _sfCompareMode(GLenum(GL_NONE)),
    _sfCompareFunc(GLenum(GL_LEQUAL)),
    _sfDepthMode(GLenum(GL_LUMINANCE))
{
}

TextureObjChunkBase::TextureObjChunkBase(const TextureObjChunkBase &source) :
    Inherited(source),
    _sfImage(),
    _sfInternalFormat(source._sfInternalFormat),
    _sfExternalFormat(source._sfExternalFormat),
    _sfScale(source._sfScale),
    _sfFrame(source._sfFrame),
    _sfMinFilter(source._sfMinFilter),
    _sfMagFilter(source._sfMagFilter),
    _sfWrapS(source._sfWrapS),
    _sfWrapT(source._sfWrapT),
    _sfWrapR(source._sfWrapR),
    _sfEnvMode(source._sfEnvMode),
    _sfEnvColor(source._sfEnvColor),
    _sfEnvCombineRGB(source._sfEnvCombineRGB),
    _sfEnvCombineAlpha(source._sfEnvCombineAlpha),
    _sfEnvScaleRGB(source._sfEnvScaleRGB),
    _sfEnvScaleAlpha(source._sfEnvScaleAlpha),
    _sfEnvSource0RGB(source._sfEnvSource0RGB),
    _sfEnvSource1RGB(source._sfEnvSource1RGB),
    _sfEnvSource2RGB(source._sfEnvSource2RGB),
    _sfEnvSource0Alpha(source._sfEnvSource0Alpha),
    _sfEnvSource1Alpha(source._sfEnvSource1Alpha),
    _sfEnvSource2Alpha(source._sfEnvSource2Alpha),
    _sfEnvOperand0RGB(source._sfEnvOperand0RGB),
    _sfEnvOperand1RGB(source._sfEnvOperand1RGB),
    _sfEnvOperand2RGB(source._sfEnvOperand2RGB),
    _sfEnvOperand0Alpha(source._sfEnvOperand0Alpha),
    _sfEnvOperand1Alpha(source._sfEnvOperand1Alpha),
    _sfEnvOperand2Alpha(source._sfEnvOperand2Alpha),
    _sfGLId(source._sfGLId),
    _sfIgnoreGLForAspect(source._sfIgnoreGLForAspect),
    _sfPointSprite(source._sfPointSprite),
    _sfPriority(source._sfPriority),
    _sfShaderOperation(source._sfShaderOperation),
    _sfShaderInput(source._sfShaderInput),
    _mfShaderOffsetMatrix(source._mfShaderOffsetMatrix),
    _sfShaderOffsetScale(source._sfShaderOffsetScale),
    _sfShaderOffsetBias(source._sfShaderOffsetBias),
    _sfShaderRGBADotProduct(source._sfShaderRGBADotProduct),
    _sfShaderCullModes(source._sfShaderCullModes),
    _sfShaderConstEye(source._sfShaderConstEye),
    _sfLodBias(source._sfLodBias),
    _sfTarget(source._sfTarget),
    _sfDirtyLeft(source._sfDirtyLeft),
    _sfDirtyMinX(source._sfDirtyMinX),
    _sfDirtyMaxX(source._sfDirtyMaxX),
    _sfDirtyMinY(source._sfDirtyMinY),
    _sfDirtyMaxY(source._sfDirtyMaxY),
    _sfDirtyMinZ(source._sfDirtyMinZ),
    _sfDirtyMaxZ(source._sfDirtyMaxZ),
    _sfAnisotropy(source._sfAnisotropy),
    _sfBorderColor(source._sfBorderColor),
    _sfCompareMode(source._sfCompareMode),
    _sfCompareFunc(source._sfCompareFunc),
    _sfDepthMode(source._sfDepthMode)
{
}

/*-------------------------- destructors ----------------------------------*/

TextureObjChunkBase::~TextureObjChunkBase(void)
{
}

void TextureObjChunkBase::onCreate(const TextureObjChunk *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setImage(source->getImage());
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void TextureObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<TextureObjChunkBase *>(&oFrom),
                   whichField, 
                   syncMode, 
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void TextureObjChunkBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode  ,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<TextureObjChunkBase *>(&oFrom), 
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void TextureObjChunkBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr TextureObjChunkBase::createAspectCopy(void) const
{
    TextureObjChunkPtr returnValue; 

    newAspectCopy(returnValue, 
                  dynamic_cast<const TextureObjChunk *>(this)); 

    return returnValue; 
}
#endif

void TextureObjChunkBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<TextureObjChunk *>(this)->setImage(NullFC);
}


#include "OSGSField.ins"
#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGSFieldFuncs.ins"
#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<TextureObjChunkPtr>::_type("TextureObjChunkPtr", "TextureBaseChunkPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(TextureObjChunkPtr)

OSG_FIELD_DLLEXPORT_DEF1(SField, TextureObjChunkPtr);
OSG_FIELD_DLLEXPORT_DEF1(MField, TextureObjChunkPtr);

OSG_END_NAMESPACE


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id$";
    static Char8 cvsid_hpp       [] = OSGTEXTUREOBJCHUNKBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGTEXTUREOBJCHUNKBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGTEXTUREOBJCHUNKFIELDS_HEADER_CVSID;
}
