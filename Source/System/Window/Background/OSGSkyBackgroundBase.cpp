/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class SkyBackground!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/


#define OSG_COMPILESKYBACKGROUNDINST

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include <OSGTextureObjChunk.h> // BackTexture Class
#include <OSGTextureObjChunk.h> // BottomTexture Class
#include <OSGTextureObjChunk.h> // FrontTexture Class
#include <OSGTextureObjChunk.h> // LeftTexture Class
#include <OSGTextureObjChunk.h> // RightTexture Class
#include <OSGTextureObjChunk.h> // TopTexture Class
#include <OSGNode.h> // Beacon Class

#include "OSGSkyBackgroundBase.h"
#include "OSGSkyBackground.h"

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::SkyBackground
    \ingroup GrpSystemWindowBackgrounds

    A Sky/Ground/Skybox background, inspired by VRML, see \ref
    PageSystemWindowBackgroundSky for a description.

    The sky is defined by the _mfSkyAngle and _mfSkyColor fields, the ground by the
    _mfGroundAngle and _mfGround Color fields. The resolution of the sky sphere can
    be influenced by the _sfSphereRes field. The sky box is defined by the
    _sfBackTexture, _sfFrontTexture, _sfLeftTexture, _sfRightTexture, _sfTopTexture
    and _sfBottomTexture fields.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var Color4f         SkyBackgroundBase::_mfSkyColor
    The colors for the sky gradient bands. Corresponds to the skyAngle
    angles.  The first value is for the apex (i.e. straight up), which
    doesn't need an angle, thus there  should be one more color than
    angles. If no angles are given color[0] is used, or black if none are
    given.
*/

/*! \var Real32          SkyBackgroundBase::_mfSkyAngle
    The angles for the sky gradient bands. Corresponds to the skyColor colors,
    with the exception of the apex. Values should be between 0 and PI.
*/

/*! \var Color4f         SkyBackgroundBase::_mfGroundColor
    The colors of the ground sphere-part. Interpretation is similar to the sky.
*/

/*! \var Real32          SkyBackgroundBase::_mfGroundAngle
    The angles of the ground sphere-part. Interpretation is similar to the sky, with
    0 being straight down.
*/

/*! \var UInt32          SkyBackgroundBase::_sfSphereRes
    The polygonal resolution of the sky/ground sphere.
*/

/*! \var TextureObjChunkPtr SkyBackgroundBase::_sfBackTexture
    Texture for the back (+Z) side of the sky cube.
*/

/*! \var TextureObjChunkPtr SkyBackgroundBase::_sfBottomTexture
    Texture for the bottom (-Y) side of the sky cube.
*/

/*! \var TextureObjChunkPtr SkyBackgroundBase::_sfFrontTexture
    Texture for the front (-Z) side of the sky cube.
*/

/*! \var TextureObjChunkPtr SkyBackgroundBase::_sfLeftTexture
    Texture for the left (-X) side of the sky cube.
*/

/*! \var TextureObjChunkPtr SkyBackgroundBase::_sfRightTexture
    Texture for the right (+X) side of the sky cube.
*/

/*! \var TextureObjChunkPtr SkyBackgroundBase::_sfTopTexture
    Texture for the top (+Y) side of the sky cube.
*/

/*! \var bool            SkyBackgroundBase::_sfBoxInside
    Flag to draw the box inside or outside of the sphere
*/

/*! \var Vec3f           SkyBackgroundBase::_mfTopTexCoord
    Texture coordinates for the top face
*/

/*! \var Vec3f           SkyBackgroundBase::_mfBottomTexCoord
    Bottom texture coordinates.
*/

/*! \var Vec3f           SkyBackgroundBase::_mfRightTexCoord
    Right texture coordinates.
*/

/*! \var Vec3f           SkyBackgroundBase::_mfLeftTexCoord
    Left texture coordinates.
*/

/*! \var Vec3f           SkyBackgroundBase::_mfFrontTexCoord
    Front texture coordinates.
*/

/*! \var Vec3f           SkyBackgroundBase::_mfBackTexCoord
    Back texture coordinates.
*/

/*! \var NodePtr         SkyBackgroundBase::_sfBeacon
    The object that defines the orientation of the background, i.e. the
    local coordinate system it is drawn in.
*/


void SkyBackgroundBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


#ifdef OSG_1_COMPAT
    typedef const MFColor4f *(SkyBackgroundBase::*GetMFSkyColorF)(void) const;

    GetMFSkyColorF GetMFSkyColor = &SkyBackgroundBase::getMFSkyColor;
#endif

    pDesc = new MFColor4f::Description(
        MFColor4f::getClassType(),
        "skyColor",
        "The colors for the sky gradient bands. Corresponds to the skyAngle\n"
        "angles.  The first value is for the apex (i.e. straight up), which\n"
        "doesn't need an angle, thus there  should be one more color than\n"
        "angles. If no angles are given color[0] is used, or black if none are\n"
        "given.\n",
        SkyColorFieldId, SkyColorFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFSkyColor),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFSkyColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFSkyColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFReal32 *(SkyBackgroundBase::*GetMFSkyAngleF)(void) const;

    GetMFSkyAngleF GetMFSkyAngle = &SkyBackgroundBase::getMFSkyAngle;
#endif

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "skyAngle",
        "The angles for the sky gradient bands. Corresponds to the skyColor colors,\n"
        "with the exception of the apex. Values should be between 0 and PI.\n",
        SkyAngleFieldId, SkyAngleFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFSkyAngle),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFSkyAngle));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFSkyAngle));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFColor4f *(SkyBackgroundBase::*GetMFGroundColorF)(void) const;

    GetMFGroundColorF GetMFGroundColor = &SkyBackgroundBase::getMFGroundColor;
#endif

    pDesc = new MFColor4f::Description(
        MFColor4f::getClassType(),
        "groundColor",
        "The colors of the ground sphere-part. Interpretation is similar to the sky.\n",
        GroundColorFieldId, GroundColorFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFGroundColor),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFGroundColor));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFGroundColor));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFReal32 *(SkyBackgroundBase::*GetMFGroundAngleF)(void) const;

    GetMFGroundAngleF GetMFGroundAngle = &SkyBackgroundBase::getMFGroundAngle;
#endif

    pDesc = new MFReal32::Description(
        MFReal32::getClassType(),
        "groundAngle",
        "The angles of the ground sphere-part. Interpretation is similar to the sky, with\n"
        "0 being straight down.\n",
        GroundAngleFieldId, GroundAngleFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFGroundAngle),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFGroundAngle));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFGroundAngle));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFUInt32 *(SkyBackgroundBase::*GetSFSphereResF)(void) const;

    GetSFSphereResF GetSFSphereRes = &SkyBackgroundBase::getSFSphereRes;
#endif

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "sphereRes",
        "The polygonal resolution of the sky/ground sphere.\n",
        SphereResFieldId, SphereResFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editSFSphereRes),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFSphereRes));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFSphereRes));
#endif

    oType.addInitialDesc(pDesc);

    pDesc = new SFTextureObjChunkPtr::Description(
        SFTextureObjChunkPtr::getClassType(),
        "backTexture",
        "Texture for the back (+Z) side of the sky cube.\n",
        BackTextureFieldId, BackTextureFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFBackTexture));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTextureObjChunkPtr::Description(
        SFTextureObjChunkPtr::getClassType(),
        "bottomTexture",
        "Texture for the bottom (-Y) side of the sky cube.\n",
        BottomTextureFieldId, BottomTextureFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFBottomTexture));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTextureObjChunkPtr::Description(
        SFTextureObjChunkPtr::getClassType(),
        "frontTexture",
        "Texture for the front (-Z) side of the sky cube.\n",
        FrontTextureFieldId, FrontTextureFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFFrontTexture));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTextureObjChunkPtr::Description(
        SFTextureObjChunkPtr::getClassType(),
        "leftTexture",
        "Texture for the left (-X) side of the sky cube.\n",
        LeftTextureFieldId, LeftTextureFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFLeftTexture));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTextureObjChunkPtr::Description(
        SFTextureObjChunkPtr::getClassType(),
        "rightTexture",
        "Texture for the right (+X) side of the sky cube.\n",
        RightTextureFieldId, RightTextureFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFRightTexture));

    oType.addInitialDesc(pDesc);

    pDesc = new SFTextureObjChunkPtr::Description(
        SFTextureObjChunkPtr::getClassType(),
        "topTexture",
        "Texture for the top (+Y) side of the sky cube.\n",
        TopTextureFieldId, TopTextureFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFTopTexture));

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const SFBool *(SkyBackgroundBase::*GetSFBoxInsideF)(void) const;

    GetSFBoxInsideF GetSFBoxInside = &SkyBackgroundBase::getSFBoxInside;
#endif

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "boxInside",
        "Flag to draw the box inside or outside of the sphere\n",
        BoxInsideFieldId, BoxInsideFieldMask,
        false,
        Field::SFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editSFBoxInside),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetSFBoxInside));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFBoxInside));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(SkyBackgroundBase::*GetMFTopTexCoordF)(void) const;

    GetMFTopTexCoordF GetMFTopTexCoord = &SkyBackgroundBase::getMFTopTexCoord;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "topTexCoord",
        "Texture coordinates for the top face\n",
        TopTexCoordFieldId, TopTexCoordFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFTopTexCoord),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFTopTexCoord));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFTopTexCoord));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(SkyBackgroundBase::*GetMFBottomTexCoordF)(void) const;

    GetMFBottomTexCoordF GetMFBottomTexCoord = &SkyBackgroundBase::getMFBottomTexCoord;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "bottomTexCoord",
        "Bottom texture coordinates.\n",
        BottomTexCoordFieldId, BottomTexCoordFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFBottomTexCoord),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFBottomTexCoord));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFBottomTexCoord));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(SkyBackgroundBase::*GetMFRightTexCoordF)(void) const;

    GetMFRightTexCoordF GetMFRightTexCoord = &SkyBackgroundBase::getMFRightTexCoord;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "rightTexCoord",
        "Right texture coordinates.\n",
        RightTexCoordFieldId, RightTexCoordFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFRightTexCoord),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFRightTexCoord));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFRightTexCoord));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(SkyBackgroundBase::*GetMFLeftTexCoordF)(void) const;

    GetMFLeftTexCoordF GetMFLeftTexCoord = &SkyBackgroundBase::getMFLeftTexCoord;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "leftTexCoord",
        "Left texture coordinates.\n",
        LeftTexCoordFieldId, LeftTexCoordFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFLeftTexCoord),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFLeftTexCoord));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFLeftTexCoord));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(SkyBackgroundBase::*GetMFFrontTexCoordF)(void) const;

    GetMFFrontTexCoordF GetMFFrontTexCoord = &SkyBackgroundBase::getMFFrontTexCoord;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "frontTexCoord",
        "Front texture coordinates.\n",
        FrontTexCoordFieldId, FrontTexCoordFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFFrontTexCoord),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFFrontTexCoord));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFFrontTexCoord));
#endif

    oType.addInitialDesc(pDesc);

#ifdef OSG_1_COMPAT
    typedef const MFVec3f *(SkyBackgroundBase::*GetMFBackTexCoordF)(void) const;

    GetMFBackTexCoordF GetMFBackTexCoord = &SkyBackgroundBase::getMFBackTexCoord;
#endif

    pDesc = new MFVec3f::Description(
        MFVec3f::getClassType(),
        "backTexCoord",
        "Back texture coordinates.\n",
        BackTexCoordFieldId, BackTexCoordFieldMask,
        false,
        Field::MFDefaultFlags,
        reinterpret_cast<FieldEditMethodSig>(&SkyBackgroundBase::editMFBackTexCoord),
#ifdef OSG_1_COMPAT
        reinterpret_cast<FieldGetMethodSig >(GetMFBackTexCoord));
#else
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getMFBackTexCoord));
#endif

    oType.addInitialDesc(pDesc);

    pDesc = new SFNodePtr::Description(
        SFNodePtr::getClassType(),
        "beacon",
        "The object that defines the orientation of the background, i.e. the\n"
        "local coordinate system it is drawn in.\n",
        BeaconFieldId, BeaconFieldMask,
        false,
        Field::SFDefaultFlags,
        static_cast     <FieldEditMethodSig>(&SkyBackgroundBase::invalidEditField),
        reinterpret_cast<FieldGetMethodSig >(&SkyBackgroundBase::getSFBeacon));

    oType.addInitialDesc(pDesc);
}


SkyBackgroundBase::TypeObject SkyBackgroundBase::_type(true,
    SkyBackgroundBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    (PrototypeCreateF) &SkyBackgroundBase::createEmpty,
    SkyBackground::initMethod,
    (InitalInsertDescFunc) &SkyBackgroundBase::classDescInserter,
    false,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"SkyBackground\"\n"
    "\tparent=\"Background\"\n"
    "\tlibrary=\"Window\"\n"
    "\tpointerfieldtypes=\"multi\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    ">\n"
    "\\ingroup GrpSystemWindowBackgrounds\n"
    "\n"
    "A Sky/Ground/Skybox background, inspired by VRML, see \\ref\n"
    "PageSystemWindowBackgroundSky for a description.\n"
    "\n"
    "The sky is defined by the _mfSkyAngle and _mfSkyColor fields, the ground by the\n"
    "_mfGroundAngle and _mfGround Color fields. The resolution of the sky sphere can\n"
    "be influenced by the _sfSphereRes field. The sky box is defined by the\n"
    "_sfBackTexture, _sfFrontTexture, _sfLeftTexture, _sfRightTexture, _sfTopTexture\n"
    "and _sfBottomTexture fields.\n"
    "\t<Field\n"
    "\t\tname=\"skyColor\"\n"
    "\t\ttype=\"Color4f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe colors for the sky gradient bands. Corresponds to the skyAngle\n"
    "        angles.  The first value is for the apex (i.e. straight up), which\n"
    "        doesn't need an angle, thus there  should be one more color than\n"
    "        angles. If no angles are given color[0] is used, or black if none are\n"
    "        given.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"skyAngle\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe angles for the sky gradient bands. Corresponds to the skyColor colors,\n"
    "        with the exception of the apex. Values should be between 0 and PI.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"groundColor\"\n"
    "\t\ttype=\"Color4f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe colors of the ground sphere-part. Interpretation is similar to the sky.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"groundAngle\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe angles of the ground sphere-part. Interpretation is similar to the sky, with\n"
    "        0 being straight down.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sphereRes\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"8\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe polygonal resolution of the sky/ground sphere.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"backTexture\"\n"
    "\t\ttype=\"TextureObjChunkPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"NullFC\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture for the back (+Z) side of the sky cube.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bottomTexture\"\n"
    "\t\ttype=\"TextureObjChunkPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"NullFC\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture for the bottom (-Y) side of the sky cube.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frontTexture\"\n"
    "\t\ttype=\"TextureObjChunkPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"NullFC\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture for the front (-Z) side of the sky cube.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"leftTexture\"\n"
    "\t\ttype=\"TextureObjChunkPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"NullFC\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture for the left (-X) side of the sky cube.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"rightTexture\"\n"
    "\t\ttype=\"TextureObjChunkPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"NullFC\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture for the right (+X) side of the sky cube.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"topTexture\"\n"
    "\t\ttype=\"TextureObjChunkPtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"NullFC\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture for the top (+Y) side of the sky cube.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"boxInside\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tFlag to draw the box inside or outside of the sphere\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"topTexCoord\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tTexture coordinates for the top face\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"bottomTexCoord\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tBottom texture coordinates.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"rightTexCoord\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tRight texture coordinates.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"leftTexCoord\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tLeft texture coordinates.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"frontTexCoord\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tFront texture coordinates.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"backTexCoord\"\n"
    "\t\ttype=\"Vec3f\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tBack texture coordinates.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"beacon\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tThe object that defines the orientation of the background, i.e. the\n"
    "\tlocal coordinate system it is drawn in.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "\\ingroup GrpSystemWindowBackgrounds\n"
    "\n"
    "A Sky/Ground/Skybox background, inspired by VRML, see \\ref\n"
    "PageSystemWindowBackgroundSky for a description.\n"
    "\n"
    "The sky is defined by the _mfSkyAngle and _mfSkyColor fields, the ground by the\n"
    "_mfGroundAngle and _mfGround Color fields. The resolution of the sky sphere can\n"
    "be influenced by the _sfSphereRes field. The sky box is defined by the\n"
    "_sfBackTexture, _sfFrontTexture, _sfLeftTexture, _sfRightTexture, _sfTopTexture\n"
    "and _sfBottomTexture fields.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &SkyBackgroundBase::getType(void)
{
    return _type;
}

const FieldContainerType &SkyBackgroundBase::getType(void) const
{
    return _type;
}

UInt32 SkyBackgroundBase::getContainerSize(void) const
{
    return sizeof(SkyBackground);
}

/*------------------------- decorator get ------------------------------*/


MFColor4f *SkyBackgroundBase::editMFSkyColor(void)
{
    editMField(SkyColorFieldMask, _mfSkyColor);

    return &_mfSkyColor;
}

const MFColor4f *SkyBackgroundBase::getMFSkyColor(void) const
{
    return &_mfSkyColor;
}

#ifdef OSG_1_COMPAT
MFColor4f           *SkyBackgroundBase::getMFSkyColor       (void)
{
    return this->editMFSkyColor       ();
}
#endif

MFReal32 *SkyBackgroundBase::editMFSkyAngle(void)
{
    editMField(SkyAngleFieldMask, _mfSkyAngle);

    return &_mfSkyAngle;
}

const MFReal32 *SkyBackgroundBase::getMFSkyAngle(void) const
{
    return &_mfSkyAngle;
}

#ifdef OSG_1_COMPAT
MFReal32            *SkyBackgroundBase::getMFSkyAngle       (void)
{
    return this->editMFSkyAngle       ();
}
#endif

MFColor4f *SkyBackgroundBase::editMFGroundColor(void)
{
    editMField(GroundColorFieldMask, _mfGroundColor);

    return &_mfGroundColor;
}

const MFColor4f *SkyBackgroundBase::getMFGroundColor(void) const
{
    return &_mfGroundColor;
}

#ifdef OSG_1_COMPAT
MFColor4f           *SkyBackgroundBase::getMFGroundColor    (void)
{
    return this->editMFGroundColor    ();
}
#endif

MFReal32 *SkyBackgroundBase::editMFGroundAngle(void)
{
    editMField(GroundAngleFieldMask, _mfGroundAngle);

    return &_mfGroundAngle;
}

const MFReal32 *SkyBackgroundBase::getMFGroundAngle(void) const
{
    return &_mfGroundAngle;
}

#ifdef OSG_1_COMPAT
MFReal32            *SkyBackgroundBase::getMFGroundAngle    (void)
{
    return this->editMFGroundAngle    ();
}
#endif

SFUInt32 *SkyBackgroundBase::editSFSphereRes(void)
{
    editSField(SphereResFieldMask);

    return &_sfSphereRes;
}

const SFUInt32 *SkyBackgroundBase::getSFSphereRes(void) const
{
    return &_sfSphereRes;
}

#ifdef OSG_1_COMPAT
SFUInt32            *SkyBackgroundBase::getSFSphereRes      (void)
{
    return this->editSFSphereRes      ();
}
#endif

//! Get the SkyBackground::_sfBackTexture field.
const SFTextureObjChunkPtr *SkyBackgroundBase::getSFBackTexture(void) const
{
    return &_sfBackTexture;
}

//! Get the SkyBackground::_sfBottomTexture field.
const SFTextureObjChunkPtr *SkyBackgroundBase::getSFBottomTexture(void) const
{
    return &_sfBottomTexture;
}

//! Get the SkyBackground::_sfFrontTexture field.
const SFTextureObjChunkPtr *SkyBackgroundBase::getSFFrontTexture(void) const
{
    return &_sfFrontTexture;
}

//! Get the SkyBackground::_sfLeftTexture field.
const SFTextureObjChunkPtr *SkyBackgroundBase::getSFLeftTexture(void) const
{
    return &_sfLeftTexture;
}

//! Get the SkyBackground::_sfRightTexture field.
const SFTextureObjChunkPtr *SkyBackgroundBase::getSFRightTexture(void) const
{
    return &_sfRightTexture;
}

//! Get the SkyBackground::_sfTopTexture field.
const SFTextureObjChunkPtr *SkyBackgroundBase::getSFTopTexture(void) const
{
    return &_sfTopTexture;
}

SFBool *SkyBackgroundBase::editSFBoxInside(void)
{
    editSField(BoxInsideFieldMask);

    return &_sfBoxInside;
}

const SFBool *SkyBackgroundBase::getSFBoxInside(void) const
{
    return &_sfBoxInside;
}

#ifdef OSG_1_COMPAT
SFBool              *SkyBackgroundBase::getSFBoxInside      (void)
{
    return this->editSFBoxInside      ();
}
#endif

MFVec3f *SkyBackgroundBase::editMFTopTexCoord(void)
{
    editMField(TopTexCoordFieldMask, _mfTopTexCoord);

    return &_mfTopTexCoord;
}

const MFVec3f *SkyBackgroundBase::getMFTopTexCoord(void) const
{
    return &_mfTopTexCoord;
}

#ifdef OSG_1_COMPAT
MFVec3f             *SkyBackgroundBase::getMFTopTexCoord    (void)
{
    return this->editMFTopTexCoord    ();
}
#endif

MFVec3f *SkyBackgroundBase::editMFBottomTexCoord(void)
{
    editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

    return &_mfBottomTexCoord;
}

const MFVec3f *SkyBackgroundBase::getMFBottomTexCoord(void) const
{
    return &_mfBottomTexCoord;
}

#ifdef OSG_1_COMPAT
MFVec3f             *SkyBackgroundBase::getMFBottomTexCoord (void)
{
    return this->editMFBottomTexCoord ();
}
#endif

MFVec3f *SkyBackgroundBase::editMFRightTexCoord(void)
{
    editMField(RightTexCoordFieldMask, _mfRightTexCoord);

    return &_mfRightTexCoord;
}

const MFVec3f *SkyBackgroundBase::getMFRightTexCoord(void) const
{
    return &_mfRightTexCoord;
}

#ifdef OSG_1_COMPAT
MFVec3f             *SkyBackgroundBase::getMFRightTexCoord  (void)
{
    return this->editMFRightTexCoord  ();
}
#endif

MFVec3f *SkyBackgroundBase::editMFLeftTexCoord(void)
{
    editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

    return &_mfLeftTexCoord;
}

const MFVec3f *SkyBackgroundBase::getMFLeftTexCoord(void) const
{
    return &_mfLeftTexCoord;
}

#ifdef OSG_1_COMPAT
MFVec3f             *SkyBackgroundBase::getMFLeftTexCoord   (void)
{
    return this->editMFLeftTexCoord   ();
}
#endif

MFVec3f *SkyBackgroundBase::editMFFrontTexCoord(void)
{
    editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

    return &_mfFrontTexCoord;
}

const MFVec3f *SkyBackgroundBase::getMFFrontTexCoord(void) const
{
    return &_mfFrontTexCoord;
}

#ifdef OSG_1_COMPAT
MFVec3f             *SkyBackgroundBase::getMFFrontTexCoord  (void)
{
    return this->editMFFrontTexCoord  ();
}
#endif

MFVec3f *SkyBackgroundBase::editMFBackTexCoord(void)
{
    editMField(BackTexCoordFieldMask, _mfBackTexCoord);

    return &_mfBackTexCoord;
}

const MFVec3f *SkyBackgroundBase::getMFBackTexCoord(void) const
{
    return &_mfBackTexCoord;
}

#ifdef OSG_1_COMPAT
MFVec3f             *SkyBackgroundBase::getMFBackTexCoord   (void)
{
    return this->editMFBackTexCoord   ();
}
#endif

//! Get the SkyBackground::_sfBeacon field.
const SFNodePtr *SkyBackgroundBase::getSFBeacon(void) const
{
    return &_sfBeacon;
}


void SkyBackgroundBase::pushToField(      FieldContainerPtrConstArg pNewElement,
                                    const UInt32                    uiFieldId  )
{
    Inherited::pushToField(pNewElement, uiFieldId);

    if(uiFieldId == BackTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setBackTexture(
            cast_dynamic<TextureObjChunkPtr>(pNewElement));
    }
    if(uiFieldId == BottomTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setBottomTexture(
            cast_dynamic<TextureObjChunkPtr>(pNewElement));
    }
    if(uiFieldId == FrontTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setFrontTexture(
            cast_dynamic<TextureObjChunkPtr>(pNewElement));
    }
    if(uiFieldId == LeftTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setLeftTexture(
            cast_dynamic<TextureObjChunkPtr>(pNewElement));
    }
    if(uiFieldId == RightTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setRightTexture(
            cast_dynamic<TextureObjChunkPtr>(pNewElement));
    }
    if(uiFieldId == TopTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setTopTexture(
            cast_dynamic<TextureObjChunkPtr>(pNewElement));
    }
    if(uiFieldId == BeaconFieldId)
    {
        static_cast<SkyBackground *>(this)->setBeacon(
            cast_dynamic<NodePtr>(pNewElement));
    }
}

void SkyBackgroundBase::insertIntoMField(const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::insertIntoMField(uiIndex, pNewElement, uiFieldId);

}

void SkyBackgroundBase::replaceInMField (const UInt32                    uiIndex,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::replaceInMField(uiIndex, pNewElement, uiFieldId);

}

void SkyBackgroundBase::replaceInMField (      FieldContainerPtrConstArg pOldElement,
                                               FieldContainerPtrConstArg pNewElement,
                                         const UInt32                    uiFieldId  )
{
    Inherited::replaceInMField(pOldElement, pNewElement, uiFieldId);

}

void SkyBackgroundBase::removeFromMField(const UInt32 uiIndex,
                                         const UInt32 uiFieldId)
{
    Inherited::removeFromMField(uiIndex, uiFieldId);

}

void SkyBackgroundBase::removeFromMField(      FieldContainerPtrConstArg pElement,
                                         const UInt32                    uiFieldId)
{
    Inherited::removeFromMField(pElement, uiFieldId);

}

void SkyBackgroundBase::clearField(const UInt32 uiFieldId)
{
    Inherited::clearField(uiFieldId);

    if(uiFieldId == BackTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setBackTexture(NullFC);
    }
    if(uiFieldId == BottomTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setBottomTexture(NullFC);
    }
    if(uiFieldId == FrontTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setFrontTexture(NullFC);
    }
    if(uiFieldId == LeftTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setLeftTexture(NullFC);
    }
    if(uiFieldId == RightTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setRightTexture(NullFC);
    }
    if(uiFieldId == TopTextureFieldId)
    {
        static_cast<SkyBackground *>(this)->setTopTexture(NullFC);
    }
    if(uiFieldId == BeaconFieldId)
    {
        static_cast<SkyBackground *>(this)->setBeacon(NullFC);
    }
}

/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToSkyColor(const Color4f& value)
{
    editMField(SkyColorFieldMask, _mfSkyColor);
    _mfSkyColor.push_back(value);
}

void SkyBackgroundBase::insertIntoSkyColor(UInt32                uiIndex,
                                                   const Color4f& value   )
{
    editMField(SkyColorFieldMask, _mfSkyColor);

    MFColor4f::iterator fieldIt = _mfSkyColor.begin();

    fieldIt += uiIndex;

    _mfSkyColor.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInSkyColor(UInt32                uiIndex,
                                                       const Color4f& value   )
{
    if(uiIndex >= _mfSkyColor.size())
        return;

    editMField(SkyColorFieldMask, _mfSkyColor);

    _mfSkyColor[uiIndex] = value;
}

void SkyBackgroundBase::replaceInSkyColor(const Color4f& pOldElem,
                                                        const Color4f& pNewElem)
{
    Int32  elemIdx = _mfSkyColor.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(SkyColorFieldMask, _mfSkyColor);

        MFColor4f::iterator fieldIt = _mfSkyColor.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromSkyColor(UInt32 uiIndex)
{
    if(uiIndex < _mfSkyColor.size())
    {
        editMField(SkyColorFieldMask, _mfSkyColor);

        MFColor4f::iterator fieldIt = _mfSkyColor.begin();

        fieldIt += uiIndex;
        _mfSkyColor.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromSkyColor(const Color4f& value)
{
    Int32 iElemIdx = _mfSkyColor.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(SkyColorFieldMask, _mfSkyColor);

        MFColor4f::iterator fieldIt = _mfSkyColor.begin();

        fieldIt += iElemIdx;

        _mfSkyColor.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearSkyColor(void)
{
    editMField(SkyColorFieldMask, _mfSkyColor);

    _mfSkyColor.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToSkyAngle(const Real32& value)
{
    editMField(SkyAngleFieldMask, _mfSkyAngle);
    _mfSkyAngle.push_back(value);
}

void SkyBackgroundBase::insertIntoSkyAngle(UInt32                uiIndex,
                                                   const Real32& value   )
{
    editMField(SkyAngleFieldMask, _mfSkyAngle);

    MFReal32::iterator fieldIt = _mfSkyAngle.begin();

    fieldIt += uiIndex;

    _mfSkyAngle.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInSkyAngle(UInt32                uiIndex,
                                                       const Real32& value   )
{
    if(uiIndex >= _mfSkyAngle.size())
        return;

    editMField(SkyAngleFieldMask, _mfSkyAngle);

    _mfSkyAngle[uiIndex] = value;
}

void SkyBackgroundBase::replaceInSkyAngle(const Real32& pOldElem,
                                                        const Real32& pNewElem)
{
    Int32  elemIdx = _mfSkyAngle.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(SkyAngleFieldMask, _mfSkyAngle);

        MFReal32::iterator fieldIt = _mfSkyAngle.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromSkyAngle(UInt32 uiIndex)
{
    if(uiIndex < _mfSkyAngle.size())
    {
        editMField(SkyAngleFieldMask, _mfSkyAngle);

        MFReal32::iterator fieldIt = _mfSkyAngle.begin();

        fieldIt += uiIndex;
        _mfSkyAngle.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromSkyAngle(const Real32& value)
{
    Int32 iElemIdx = _mfSkyAngle.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(SkyAngleFieldMask, _mfSkyAngle);

        MFReal32::iterator fieldIt = _mfSkyAngle.begin();

        fieldIt += iElemIdx;

        _mfSkyAngle.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearSkyAngle(void)
{
    editMField(SkyAngleFieldMask, _mfSkyAngle);

    _mfSkyAngle.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToGroundColor(const Color4f& value)
{
    editMField(GroundColorFieldMask, _mfGroundColor);
    _mfGroundColor.push_back(value);
}

void SkyBackgroundBase::insertIntoGroundColor(UInt32                uiIndex,
                                                   const Color4f& value   )
{
    editMField(GroundColorFieldMask, _mfGroundColor);

    MFColor4f::iterator fieldIt = _mfGroundColor.begin();

    fieldIt += uiIndex;

    _mfGroundColor.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInGroundColor(UInt32                uiIndex,
                                                       const Color4f& value   )
{
    if(uiIndex >= _mfGroundColor.size())
        return;

    editMField(GroundColorFieldMask, _mfGroundColor);

    _mfGroundColor[uiIndex] = value;
}

void SkyBackgroundBase::replaceInGroundColor(const Color4f& pOldElem,
                                                        const Color4f& pNewElem)
{
    Int32  elemIdx = _mfGroundColor.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(GroundColorFieldMask, _mfGroundColor);

        MFColor4f::iterator fieldIt = _mfGroundColor.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromGroundColor(UInt32 uiIndex)
{
    if(uiIndex < _mfGroundColor.size())
    {
        editMField(GroundColorFieldMask, _mfGroundColor);

        MFColor4f::iterator fieldIt = _mfGroundColor.begin();

        fieldIt += uiIndex;
        _mfGroundColor.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromGroundColor(const Color4f& value)
{
    Int32 iElemIdx = _mfGroundColor.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(GroundColorFieldMask, _mfGroundColor);

        MFColor4f::iterator fieldIt = _mfGroundColor.begin();

        fieldIt += iElemIdx;

        _mfGroundColor.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearGroundColor(void)
{
    editMField(GroundColorFieldMask, _mfGroundColor);

    _mfGroundColor.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToGroundAngle(const Real32& value)
{
    editMField(GroundAngleFieldMask, _mfGroundAngle);
    _mfGroundAngle.push_back(value);
}

void SkyBackgroundBase::insertIntoGroundAngle(UInt32                uiIndex,
                                                   const Real32& value   )
{
    editMField(GroundAngleFieldMask, _mfGroundAngle);

    MFReal32::iterator fieldIt = _mfGroundAngle.begin();

    fieldIt += uiIndex;

    _mfGroundAngle.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInGroundAngle(UInt32                uiIndex,
                                                       const Real32& value   )
{
    if(uiIndex >= _mfGroundAngle.size())
        return;

    editMField(GroundAngleFieldMask, _mfGroundAngle);

    _mfGroundAngle[uiIndex] = value;
}

void SkyBackgroundBase::replaceInGroundAngle(const Real32& pOldElem,
                                                        const Real32& pNewElem)
{
    Int32  elemIdx = _mfGroundAngle.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(GroundAngleFieldMask, _mfGroundAngle);

        MFReal32::iterator fieldIt = _mfGroundAngle.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromGroundAngle(UInt32 uiIndex)
{
    if(uiIndex < _mfGroundAngle.size())
    {
        editMField(GroundAngleFieldMask, _mfGroundAngle);

        MFReal32::iterator fieldIt = _mfGroundAngle.begin();

        fieldIt += uiIndex;
        _mfGroundAngle.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromGroundAngle(const Real32& value)
{
    Int32 iElemIdx = _mfGroundAngle.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(GroundAngleFieldMask, _mfGroundAngle);

        MFReal32::iterator fieldIt = _mfGroundAngle.begin();

        fieldIt += iElemIdx;

        _mfGroundAngle.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearGroundAngle(void)
{
    editMField(GroundAngleFieldMask, _mfGroundAngle);

    _mfGroundAngle.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToTopTexCoord(const Vec3f& value)
{
    editMField(TopTexCoordFieldMask, _mfTopTexCoord);
    _mfTopTexCoord.push_back(value);
}

void SkyBackgroundBase::insertIntoTopTexCoord(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(TopTexCoordFieldMask, _mfTopTexCoord);

    MFVec3f::iterator fieldIt = _mfTopTexCoord.begin();

    fieldIt += uiIndex;

    _mfTopTexCoord.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInTopTexCoord(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfTopTexCoord.size())
        return;

    editMField(TopTexCoordFieldMask, _mfTopTexCoord);

    _mfTopTexCoord[uiIndex] = value;
}

void SkyBackgroundBase::replaceInTopTexCoord(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfTopTexCoord.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(TopTexCoordFieldMask, _mfTopTexCoord);

        MFVec3f::iterator fieldIt = _mfTopTexCoord.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromTopTexCoord(UInt32 uiIndex)
{
    if(uiIndex < _mfTopTexCoord.size())
    {
        editMField(TopTexCoordFieldMask, _mfTopTexCoord);

        MFVec3f::iterator fieldIt = _mfTopTexCoord.begin();

        fieldIt += uiIndex;
        _mfTopTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromTopTexCoord(const Vec3f& value)
{
    Int32 iElemIdx = _mfTopTexCoord.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(TopTexCoordFieldMask, _mfTopTexCoord);

        MFVec3f::iterator fieldIt = _mfTopTexCoord.begin();

        fieldIt += iElemIdx;

        _mfTopTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearTopTexCoord(void)
{
    editMField(TopTexCoordFieldMask, _mfTopTexCoord);

    _mfTopTexCoord.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToBottomTexCoord(const Vec3f& value)
{
    editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);
    _mfBottomTexCoord.push_back(value);
}

void SkyBackgroundBase::insertIntoBottomTexCoord(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

    MFVec3f::iterator fieldIt = _mfBottomTexCoord.begin();

    fieldIt += uiIndex;

    _mfBottomTexCoord.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInBottomTexCoord(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfBottomTexCoord.size())
        return;

    editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

    _mfBottomTexCoord[uiIndex] = value;
}

void SkyBackgroundBase::replaceInBottomTexCoord(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfBottomTexCoord.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

        MFVec3f::iterator fieldIt = _mfBottomTexCoord.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromBottomTexCoord(UInt32 uiIndex)
{
    if(uiIndex < _mfBottomTexCoord.size())
    {
        editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

        MFVec3f::iterator fieldIt = _mfBottomTexCoord.begin();

        fieldIt += uiIndex;
        _mfBottomTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromBottomTexCoord(const Vec3f& value)
{
    Int32 iElemIdx = _mfBottomTexCoord.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

        MFVec3f::iterator fieldIt = _mfBottomTexCoord.begin();

        fieldIt += iElemIdx;

        _mfBottomTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearBottomTexCoord(void)
{
    editMField(BottomTexCoordFieldMask, _mfBottomTexCoord);

    _mfBottomTexCoord.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToRightTexCoord(const Vec3f& value)
{
    editMField(RightTexCoordFieldMask, _mfRightTexCoord);
    _mfRightTexCoord.push_back(value);
}

void SkyBackgroundBase::insertIntoRightTexCoord(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(RightTexCoordFieldMask, _mfRightTexCoord);

    MFVec3f::iterator fieldIt = _mfRightTexCoord.begin();

    fieldIt += uiIndex;

    _mfRightTexCoord.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInRightTexCoord(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfRightTexCoord.size())
        return;

    editMField(RightTexCoordFieldMask, _mfRightTexCoord);

    _mfRightTexCoord[uiIndex] = value;
}

void SkyBackgroundBase::replaceInRightTexCoord(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfRightTexCoord.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(RightTexCoordFieldMask, _mfRightTexCoord);

        MFVec3f::iterator fieldIt = _mfRightTexCoord.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromRightTexCoord(UInt32 uiIndex)
{
    if(uiIndex < _mfRightTexCoord.size())
    {
        editMField(RightTexCoordFieldMask, _mfRightTexCoord);

        MFVec3f::iterator fieldIt = _mfRightTexCoord.begin();

        fieldIt += uiIndex;
        _mfRightTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromRightTexCoord(const Vec3f& value)
{
    Int32 iElemIdx = _mfRightTexCoord.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(RightTexCoordFieldMask, _mfRightTexCoord);

        MFVec3f::iterator fieldIt = _mfRightTexCoord.begin();

        fieldIt += iElemIdx;

        _mfRightTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearRightTexCoord(void)
{
    editMField(RightTexCoordFieldMask, _mfRightTexCoord);

    _mfRightTexCoord.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToLeftTexCoord(const Vec3f& value)
{
    editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);
    _mfLeftTexCoord.push_back(value);
}

void SkyBackgroundBase::insertIntoLeftTexCoord(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

    MFVec3f::iterator fieldIt = _mfLeftTexCoord.begin();

    fieldIt += uiIndex;

    _mfLeftTexCoord.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInLeftTexCoord(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfLeftTexCoord.size())
        return;

    editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

    _mfLeftTexCoord[uiIndex] = value;
}

void SkyBackgroundBase::replaceInLeftTexCoord(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfLeftTexCoord.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

        MFVec3f::iterator fieldIt = _mfLeftTexCoord.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromLeftTexCoord(UInt32 uiIndex)
{
    if(uiIndex < _mfLeftTexCoord.size())
    {
        editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

        MFVec3f::iterator fieldIt = _mfLeftTexCoord.begin();

        fieldIt += uiIndex;
        _mfLeftTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromLeftTexCoord(const Vec3f& value)
{
    Int32 iElemIdx = _mfLeftTexCoord.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

        MFVec3f::iterator fieldIt = _mfLeftTexCoord.begin();

        fieldIt += iElemIdx;

        _mfLeftTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearLeftTexCoord(void)
{
    editMField(LeftTexCoordFieldMask, _mfLeftTexCoord);

    _mfLeftTexCoord.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToFrontTexCoord(const Vec3f& value)
{
    editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);
    _mfFrontTexCoord.push_back(value);
}

void SkyBackgroundBase::insertIntoFrontTexCoord(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

    MFVec3f::iterator fieldIt = _mfFrontTexCoord.begin();

    fieldIt += uiIndex;

    _mfFrontTexCoord.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInFrontTexCoord(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfFrontTexCoord.size())
        return;

    editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

    _mfFrontTexCoord[uiIndex] = value;
}

void SkyBackgroundBase::replaceInFrontTexCoord(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfFrontTexCoord.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

        MFVec3f::iterator fieldIt = _mfFrontTexCoord.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromFrontTexCoord(UInt32 uiIndex)
{
    if(uiIndex < _mfFrontTexCoord.size())
    {
        editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

        MFVec3f::iterator fieldIt = _mfFrontTexCoord.begin();

        fieldIt += uiIndex;
        _mfFrontTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromFrontTexCoord(const Vec3f& value)
{
    Int32 iElemIdx = _mfFrontTexCoord.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

        MFVec3f::iterator fieldIt = _mfFrontTexCoord.begin();

        fieldIt += iElemIdx;

        _mfFrontTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearFrontTexCoord(void)
{
    editMField(FrontTexCoordFieldMask, _mfFrontTexCoord);

    _mfFrontTexCoord.clear();
}
/*********************************** Non-ptr code ********************************/
void SkyBackgroundBase::pushToBackTexCoord(const Vec3f& value)
{
    editMField(BackTexCoordFieldMask, _mfBackTexCoord);
    _mfBackTexCoord.push_back(value);
}

void SkyBackgroundBase::insertIntoBackTexCoord(UInt32                uiIndex,
                                                   const Vec3f& value   )
{
    editMField(BackTexCoordFieldMask, _mfBackTexCoord);

    MFVec3f::iterator fieldIt = _mfBackTexCoord.begin();

    fieldIt += uiIndex;

    _mfBackTexCoord.insert(fieldIt, value);
}

void SkyBackgroundBase::replaceInBackTexCoord(UInt32                uiIndex,
                                                       const Vec3f& value   )
{
    if(uiIndex >= _mfBackTexCoord.size())
        return;

    editMField(BackTexCoordFieldMask, _mfBackTexCoord);

    _mfBackTexCoord[uiIndex] = value;
}

void SkyBackgroundBase::replaceInBackTexCoord(const Vec3f& pOldElem,
                                                        const Vec3f& pNewElem)
{
    Int32  elemIdx = _mfBackTexCoord.findIndex(pOldElem);

    if(elemIdx != -1)
    {
        editMField(BackTexCoordFieldMask, _mfBackTexCoord);

        MFVec3f::iterator fieldIt = _mfBackTexCoord.begin();

        fieldIt += elemIdx;

        (*fieldIt) = pNewElem;
    }
}

void SkyBackgroundBase::removeFromBackTexCoord(UInt32 uiIndex)
{
    if(uiIndex < _mfBackTexCoord.size())
    {
        editMField(BackTexCoordFieldMask, _mfBackTexCoord);

        MFVec3f::iterator fieldIt = _mfBackTexCoord.begin();

        fieldIt += uiIndex;
        _mfBackTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::removeFromBackTexCoord(const Vec3f& value)
{
    Int32 iElemIdx = _mfBackTexCoord.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(BackTexCoordFieldMask, _mfBackTexCoord);

        MFVec3f::iterator fieldIt = _mfBackTexCoord.begin();

        fieldIt += iElemIdx;

        _mfBackTexCoord.erase(fieldIt);
    }
}

void SkyBackgroundBase::clearBackTexCoord(void)
{
    editMField(BackTexCoordFieldMask, _mfBackTexCoord);

    _mfBackTexCoord.clear();
}


/*------------------------------ access -----------------------------------*/

UInt32 SkyBackgroundBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (SkyColorFieldMask & whichField))
    {
        returnValue += _mfSkyColor.getBinSize();
    }
    if(FieldBits::NoField != (SkyAngleFieldMask & whichField))
    {
        returnValue += _mfSkyAngle.getBinSize();
    }
    if(FieldBits::NoField != (GroundColorFieldMask & whichField))
    {
        returnValue += _mfGroundColor.getBinSize();
    }
    if(FieldBits::NoField != (GroundAngleFieldMask & whichField))
    {
        returnValue += _mfGroundAngle.getBinSize();
    }
    if(FieldBits::NoField != (SphereResFieldMask & whichField))
    {
        returnValue += _sfSphereRes.getBinSize();
    }
    if(FieldBits::NoField != (BackTextureFieldMask & whichField))
    {
        returnValue += _sfBackTexture.getBinSize();
    }
    if(FieldBits::NoField != (BottomTextureFieldMask & whichField))
    {
        returnValue += _sfBottomTexture.getBinSize();
    }
    if(FieldBits::NoField != (FrontTextureFieldMask & whichField))
    {
        returnValue += _sfFrontTexture.getBinSize();
    }
    if(FieldBits::NoField != (LeftTextureFieldMask & whichField))
    {
        returnValue += _sfLeftTexture.getBinSize();
    }
    if(FieldBits::NoField != (RightTextureFieldMask & whichField))
    {
        returnValue += _sfRightTexture.getBinSize();
    }
    if(FieldBits::NoField != (TopTextureFieldMask & whichField))
    {
        returnValue += _sfTopTexture.getBinSize();
    }
    if(FieldBits::NoField != (BoxInsideFieldMask & whichField))
    {
        returnValue += _sfBoxInside.getBinSize();
    }
    if(FieldBits::NoField != (TopTexCoordFieldMask & whichField))
    {
        returnValue += _mfTopTexCoord.getBinSize();
    }
    if(FieldBits::NoField != (BottomTexCoordFieldMask & whichField))
    {
        returnValue += _mfBottomTexCoord.getBinSize();
    }
    if(FieldBits::NoField != (RightTexCoordFieldMask & whichField))
    {
        returnValue += _mfRightTexCoord.getBinSize();
    }
    if(FieldBits::NoField != (LeftTexCoordFieldMask & whichField))
    {
        returnValue += _mfLeftTexCoord.getBinSize();
    }
    if(FieldBits::NoField != (FrontTexCoordFieldMask & whichField))
    {
        returnValue += _mfFrontTexCoord.getBinSize();
    }
    if(FieldBits::NoField != (BackTexCoordFieldMask & whichField))
    {
        returnValue += _mfBackTexCoord.getBinSize();
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        returnValue += _sfBeacon.getBinSize();
    }

    return returnValue;
}

void SkyBackgroundBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (SkyColorFieldMask & whichField))
    {
        _mfSkyColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SkyAngleFieldMask & whichField))
    {
        _mfSkyAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GroundColorFieldMask & whichField))
    {
        _mfGroundColor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GroundAngleFieldMask & whichField))
    {
        _mfGroundAngle.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SphereResFieldMask & whichField))
    {
        _sfSphereRes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BackTextureFieldMask & whichField))
    {
        _sfBackTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BottomTextureFieldMask & whichField))
    {
        _sfBottomTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrontTextureFieldMask & whichField))
    {
        _sfFrontTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LeftTextureFieldMask & whichField))
    {
        _sfLeftTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RightTextureFieldMask & whichField))
    {
        _sfRightTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TopTextureFieldMask & whichField))
    {
        _sfTopTexture.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BoxInsideFieldMask & whichField))
    {
        _sfBoxInside.copyToBin(pMem);
    }
    if(FieldBits::NoField != (TopTexCoordFieldMask & whichField))
    {
        _mfTopTexCoord.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BottomTexCoordFieldMask & whichField))
    {
        _mfBottomTexCoord.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RightTexCoordFieldMask & whichField))
    {
        _mfRightTexCoord.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LeftTexCoordFieldMask & whichField))
    {
        _mfLeftTexCoord.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FrontTexCoordFieldMask & whichField))
    {
        _mfFrontTexCoord.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BackTexCoordFieldMask & whichField))
    {
        _mfBackTexCoord.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        _sfBeacon.copyToBin(pMem);
    }
}

void SkyBackgroundBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (SkyColorFieldMask & whichField))
    {
        _mfSkyColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SkyAngleFieldMask & whichField))
    {
        _mfSkyAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GroundColorFieldMask & whichField))
    {
        _mfGroundColor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GroundAngleFieldMask & whichField))
    {
        _mfGroundAngle.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SphereResFieldMask & whichField))
    {
        _sfSphereRes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BackTextureFieldMask & whichField))
    {
        _sfBackTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BottomTextureFieldMask & whichField))
    {
        _sfBottomTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrontTextureFieldMask & whichField))
    {
        _sfFrontTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LeftTextureFieldMask & whichField))
    {
        _sfLeftTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RightTextureFieldMask & whichField))
    {
        _sfRightTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TopTextureFieldMask & whichField))
    {
        _sfTopTexture.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BoxInsideFieldMask & whichField))
    {
        _sfBoxInside.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (TopTexCoordFieldMask & whichField))
    {
        _mfTopTexCoord.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BottomTexCoordFieldMask & whichField))
    {
        _mfBottomTexCoord.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RightTexCoordFieldMask & whichField))
    {
        _mfRightTexCoord.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LeftTexCoordFieldMask & whichField))
    {
        _mfLeftTexCoord.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FrontTexCoordFieldMask & whichField))
    {
        _mfFrontTexCoord.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BackTexCoordFieldMask & whichField))
    {
        _mfBackTexCoord.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BeaconFieldMask & whichField))
    {
        _sfBeacon.copyFromBin(pMem);
    }
}

//! create an empty new instance of the class, do not copy the prototype
SkyBackgroundPtr SkyBackgroundBase::createEmpty(void)
{
    SkyBackgroundPtr returnValue;

    newPtr<SkyBackground>(returnValue);

    return returnValue;
}

FieldContainerPtr SkyBackgroundBase::shallowCopy(void) const
{
    SkyBackgroundPtr returnValue;

    newPtr(returnValue, dynamic_cast<const SkyBackground *>(this));

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

SkyBackgroundBase::SkyBackgroundBase(void) :
    Inherited(),
    _mfSkyColor               (),
    _mfSkyAngle               (),
    _mfGroundColor            (),
    _mfGroundAngle            (),
    _sfSphereRes              (UInt32(8)),
    _sfBackTexture            (TextureObjChunkPtr(NullFC)),
    _sfBottomTexture          (TextureObjChunkPtr(NullFC)),
    _sfFrontTexture           (TextureObjChunkPtr(NullFC)),
    _sfLeftTexture            (TextureObjChunkPtr(NullFC)),
    _sfRightTexture           (TextureObjChunkPtr(NullFC)),
    _sfTopTexture             (TextureObjChunkPtr(NullFC)),
    _sfBoxInside              (bool(true)),
    _mfTopTexCoord            (),
    _mfBottomTexCoord         (),
    _mfRightTexCoord          (),
    _mfLeftTexCoord           (),
    _mfFrontTexCoord          (),
    _mfBackTexCoord           (),
    _sfBeacon                 ()
{
}

SkyBackgroundBase::SkyBackgroundBase(const SkyBackgroundBase &source) :
    Inherited(source),
    _mfSkyColor               (source._mfSkyColor               ),
    _mfSkyAngle               (source._mfSkyAngle               ),
    _mfGroundColor            (source._mfGroundColor            ),
    _mfGroundAngle            (source._mfGroundAngle            ),
    _sfSphereRes              (source._sfSphereRes              ),
    _sfBackTexture            (),
    _sfBottomTexture          (),
    _sfFrontTexture           (),
    _sfLeftTexture            (),
    _sfRightTexture           (),
    _sfTopTexture             (),
    _sfBoxInside              (source._sfBoxInside              ),
    _mfTopTexCoord            (source._mfTopTexCoord            ),
    _mfBottomTexCoord         (source._mfBottomTexCoord         ),
    _mfRightTexCoord          (source._mfRightTexCoord          ),
    _mfLeftTexCoord           (source._mfLeftTexCoord           ),
    _mfFrontTexCoord          (source._mfFrontTexCoord          ),
    _mfBackTexCoord           (source._mfBackTexCoord           ),
    _sfBeacon                 ()
{
}

/*-------------------------- destructors ----------------------------------*/

SkyBackgroundBase::~SkyBackgroundBase(void)
{
}

void SkyBackgroundBase::onCreate(const SkyBackground *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {

        this->setBackTexture(source->getBackTexture());

        this->setBottomTexture(source->getBottomTexture());

        this->setFrontTexture(source->getFrontTexture());

        this->setLeftTexture(source->getLeftTexture());

        this->setRightTexture(source->getRightTexture());

        this->setTopTexture(source->getTopTexture());

        this->setBeacon(source->getBeacon());
    }
}

#ifdef OSG_MT_FIELDCONTAINERPTR
void SkyBackgroundBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo,
                                        UInt32             uiCopyOffset)
{
    this->execSync(static_cast<SkyBackgroundBase *>(&oFrom),
                   whichField,
                   syncMode,
                   uiSyncInfo,
                   uiCopyOffset);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
void SkyBackgroundBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    this->execSync(static_cast<SkyBackgroundBase *>(&oFrom),
                   whichField,
                   oOffsets,
                   syncMode,
                   uiSyncInfo);
}
#endif

#if 0
void SkyBackgroundBase::execBeginEditV(ConstFieldMaskArg whichField,
                                       UInt32            uiAspect,
                                       UInt32            uiContainerSize)
{
    this->execBeginEdit(whichField, uiAspect, uiContainerSize);
}
#endif

#ifdef OSG_MT_CPTR_ASPECT
FieldContainerPtr SkyBackgroundBase::createAspectCopy(void) const
{
    SkyBackgroundPtr returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const SkyBackground *>(this));

    return returnValue;
}
#endif

void SkyBackgroundBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<SkyBackground *>(this)->setBackTexture(NullFC);

    static_cast<SkyBackground *>(this)->setBottomTexture(NullFC);

    static_cast<SkyBackground *>(this)->setFrontTexture(NullFC);

    static_cast<SkyBackground *>(this)->setLeftTexture(NullFC);

    static_cast<SkyBackground *>(this)->setRightTexture(NullFC);

    static_cast<SkyBackground *>(this)->setTopTexture(NullFC);

    static_cast<SkyBackground *>(this)->setBeacon(NullFC);
}


OSG_END_NAMESPACE

#include "OSGMField.ins"

#if defined(OSG_TMPL_STATIC_MEMBER_NEEDS_FUNCTION_INSTANTIATION) || \
    defined(OSG_TMPL_STATIC_MEMBER_NEEDS_CLASS_INSTANTIATION   )

#include "OSGMFieldFuncs.ins"
#endif

OSG_BEGIN_NAMESPACE

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<SkyBackgroundPtr>::_type("SkyBackgroundPtr", "BackgroundPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(SkyBackgroundPtr)

OSG_FIELD_DLLEXPORT_DEF1(MField, SkyBackgroundPtr);


/*------------------------------------------------------------------------*/
/*                              cvs id's                                  */

#ifdef OSG_SGI_CC
#pragma set woff 1174
#endif

#ifdef OSG_LINUX_ICC
#pragma warning( disable : 177 )
#endif

namespace
{
    static Char8 cvsid_cpp       [] = "@(#)$Id$";
    static Char8 cvsid_hpp       [] = OSGSKYBACKGROUNDBASE_HEADER_CVSID;
    static Char8 cvsid_inl       [] = OSGSKYBACKGROUNDBASE_INLINE_CVSID;

    static Char8 cvsid_fields_hpp[] = OSGSKYBACKGROUNDFIELDS_HEADER_CVSID;
}

OSG_END_NAMESPACE
