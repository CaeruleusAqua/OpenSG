/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class Skeleton!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>



#include "OSGSkeletonJoint.h"           // Joints Class
#include "OSGGeometry.h"                // Meshes Class
#include "OSGShaderProgramVariableChunk.h" // ShaderData Class
#include "OSGShaderProgramChunk.h"      // ShaderCode Class

#include "OSGSkeletonBase.h"
#include "OSGSkeleton.h"

#include "boost/bind.hpp"

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::Skeleton
    A Skeleton is one or more meshes (geometries) that are deformed by a set
    of matrices called joints. All meshes must provide two vertex attributes:
    One that is used to determine which joints influence the vertex (i.e. the
    components of the attribute Vec4f are interpreted as integer indices into
    the boneMatrices array) and one that gives the weight of the used joint.
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var SkeletonJoint * SkeletonBase::_mfJoints
    The joints (or bones) of the skeleton. Sorted by jointId.
*/

/*! \var Matrix          SkeletonBase::_mfJointMatrices
    Matrices for all joints of the skeleton. Elements correspond to
    joints at the same index in _mfJoints.
    These matrices are absolute, not relative to the parent joint.
*/

/*! \var Geometry *      SkeletonBase::_mfMeshes
    The meshes controlled by this skeleton.
*/

/*! \var ShaderProgramVariableChunk * SkeletonBase::_sfShaderData
    Internal object to pass data to the vertex skinning shader.
*/

/*! \var ShaderProgramChunk * SkeletonBase::_sfShaderCode
    Internal object to store the vertex skinning shader code.
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<Skeleton *>::_type("SkeletonPtr", "DrawablePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(Skeleton *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           Skeleton *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           Skeleton *,
                           0);

DataType &FieldTraits< Skeleton *, 1 >::getType(void)
{
    return FieldTraits<Skeleton *, 0>::getType();
}


OSG_EXPORT_PTR_SFIELD(ChildPointerSField,
                      Skeleton *,
                      UnrecordedRefCountPolicy,
                      1);


OSG_EXPORT_PTR_MFIELD(ChildPointerMField,
                      Skeleton *,
                      UnrecordedRefCountPolicy,
                      1);


DataType &FieldTraits<Skeleton *, 2 >::getType(void)
{
    return FieldTraits<Skeleton *, 0>::getType();
}


OSG_SFIELDTYPE_INST(ParentPointerSField,
                    Skeleton *,
                    NoRefCountPolicy,
                    2);

OSG_FIELD_DLLEXPORT_DEF3(ParentPointerSField,
                         Skeleton *,
                         NoRefCountPolicy,
                         2);


OSG_MFIELDTYPE_INST(ParentPointerMField,
                    Skeleton *,
                    NoRefCountPolicy,
                    2);

OSG_FIELD_DLLEXPORT_DEF3(ParentPointerMField,
                         Skeleton *,
                         NoRefCountPolicy,
                         2);


/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void SkeletonBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFUnrecChildSkeletonJointPtr::Description(
        MFUnrecChildSkeletonJointPtr::getClassType(),
        "joints",
        "The joints (or bones) of the skeleton. Sorted by jointId.\n",
        JointsFieldId, JointsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleJoints),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleJoints));

    oType.addInitialDesc(pDesc);

    pDesc = new MFMatrix::Description(
        MFMatrix::getClassType(),
        "jointMatrices",
        "Matrices for all joints of the skeleton. Elements correspond to\n"
        "joints at the same index in _mfJoints.\n"
        "These matrices are absolute, not relative to the parent joint.\n",
        JointMatricesFieldId, JointMatricesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleJointMatrices),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleJointMatrices));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecGeometryPtr::Description(
        MFUnrecGeometryPtr::getClassType(),
        "meshes",
        "The meshes controlled by this skeleton.\n",
        MeshesFieldId, MeshesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleMeshes),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleMeshes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecShaderProgramVariableChunkPtr::Description(
        SFUnrecShaderProgramVariableChunkPtr::getClassType(),
        "shaderData",
        "Internal object to pass data to the vertex skinning shader.\n",
        ShaderDataFieldId, ShaderDataFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleShaderData),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleShaderData));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecShaderProgramChunkPtr::Description(
        SFUnrecShaderProgramChunkPtr::getClassType(),
        "shaderCode",
        "Internal object to store the vertex skinning shader code.\n",
        ShaderCodeFieldId, ShaderCodeFieldMask,
        true,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&Skeleton::editHandleShaderCode),
        static_cast<FieldGetMethodSig >(&Skeleton::getHandleShaderCode));

    oType.addInitialDesc(pDesc);
}


SkeletonBase::TypeObject SkeletonBase::_type(
    SkeletonBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&SkeletonBase::createEmptyLocal),
    Skeleton::initMethod,
    Skeleton::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&Skeleton::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "   name=\"Skeleton\"\n"
    "   parent=\"Drawable\"\n"
    "   library=\"Dynamics\"\n"
    "   pointerfieldtypes=\"both\"\n"
    "   structure=\"concrete\"\n"
    "   systemcomponent=\"true\"\n"
    "   parentsystemcomponent=\"true\"\n"
    "   decoratable=\"false\"\n"
    "   childFields=\"both\"\n"
    "   parentFields=\"both\"\n"
    ">\n"
    "  A Skeleton is one or more meshes (geometries) that are deformed by a set\n"
    "  of matrices called joints. All meshes must provide two vertex attributes:\n"
    "  One that is used to determine which joints influence the vertex (i.e. the\n"
    "  components of the attribute Vec4f are interpreted as integer indices into\n"
    "  the boneMatrices array) and one that gives the weight of the used joint.\n"
    "  <Field\n"
    "     name=\"joints\"\n"
    "     type=\"SkeletonJoint\"\n"
    "     category=\"childpointer\"\n"
    "     linkParentField=\"Skeleton\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"external\"\n"
    "     access=\"protected\"\n"
    "     >\n"
    "    The joints (or bones) of the skeleton. Sorted by jointId.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"jointMatrices\"\n"
    "     type=\"Matrix\"\n"
    "     category=\"data\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"external\"\n"
    "     access=\"protected\"\n"
    "     >\n"
    "    Matrices for all joints of the skeleton. Elements correspond to\n"
    "    joints at the same index in _mfJoints.\n"
    "    These matrices are absolute, not relative to the parent joint.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"meshes\"\n"
    "     type=\"Geometry\"\n"
    "     category=\"pointer\"\n"
    "     cardinality=\"multi\"\n"
    "     visibility=\"external\"\n"
    "     access=\"public\"\n"
    "     >\n"
    "    The meshes controlled by this skeleton.\n"
    "  </Field>\n"
    "\n"
    "\n"
    "  <Field\n"
    "     name=\"shaderData\"\n"
    "     type=\"ShaderProgramVariableChunk\"\n"
    "     category=\"pointer\"\n"
    "     cardinality=\"single\"\n"
    "     defaultValue=\"NULL\"\n"
    "     visibility=\"internal\"\n"
    "     access=\"protected\"\n"
    "     >\n"
    "    Internal object to pass data to the vertex skinning shader.\n"
    "  </Field>\n"
    "\n"
    "  <Field\n"
    "     name=\"shaderCode\"\n"
    "     type=\"ShaderProgramChunk\"\n"
    "     category=\"pointer\"\n"
    "     cardinality=\"single\"\n"
    "     defaultValue=\"NULL\"\n"
    "     visibility=\"internal\"\n"
    "     access=\"protected\"\n"
    "     >\n"
    "    Internal object to store the vertex skinning shader code.\n"
    "  </Field>\n"
    "</FieldContainer>\n",
    "A Skeleton is one or more meshes (geometries) that are deformed by a set\n"
    "of matrices called joints. All meshes must provide two vertex attributes:\n"
    "One that is used to determine which joints influence the vertex (i.e. the\n"
    "components of the attribute Vec4f are interpreted as integer indices into\n"
    "the boneMatrices array) and one that gives the weight of the used joint.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &SkeletonBase::getType(void)
{
    return _type;
}

const FieldContainerType &SkeletonBase::getType(void) const
{
    return _type;
}

UInt32 SkeletonBase::getContainerSize(void) const
{
    return sizeof(Skeleton);
}

/*------------------------- decorator get ------------------------------*/


//! Get the Skeleton::_mfJoints field.
const MFUnrecChildSkeletonJointPtr *SkeletonBase::getMFJoints(void) const
{
    return &_mfJoints;
}

MFUnrecChildSkeletonJointPtr *SkeletonBase::editMFJoints         (void)
{
    editMField(JointsFieldMask, _mfJoints);

    return &_mfJoints;
}

MFMatrix *SkeletonBase::editMFJointMatrices(void)
{
    editMField(JointMatricesFieldMask, _mfJointMatrices);

    return &_mfJointMatrices;
}

const MFMatrix *SkeletonBase::getMFJointMatrices(void) const
{
    return &_mfJointMatrices;
}


//! Get the Skeleton::_mfMeshes field.
const MFUnrecGeometryPtr *SkeletonBase::getMFMeshes(void) const
{
    return &_mfMeshes;
}

MFUnrecGeometryPtr  *SkeletonBase::editMFMeshes         (void)
{
    editMField(MeshesFieldMask, _mfMeshes);

    return &_mfMeshes;
}

//! Get the Skeleton::_sfShaderData field.
const SFUnrecShaderProgramVariableChunkPtr *SkeletonBase::getSFShaderData(void) const
{
    return &_sfShaderData;
}

SFUnrecShaderProgramVariableChunkPtr *SkeletonBase::editSFShaderData     (void)
{
    editSField(ShaderDataFieldMask);

    return &_sfShaderData;
}

//! Get the Skeleton::_sfShaderCode field.
const SFUnrecShaderProgramChunkPtr *SkeletonBase::getSFShaderCode(void) const
{
    return &_sfShaderCode;
}

SFUnrecShaderProgramChunkPtr *SkeletonBase::editSFShaderCode     (void)
{
    editSField(ShaderCodeFieldMask);

    return &_sfShaderCode;
}



void SkeletonBase::pushToJoints(SkeletonJoint * const value)
{
    editMField(JointsFieldMask, _mfJoints);

    _mfJoints.push_back(value);
}

void SkeletonBase::assignJoints   (const MFUnrecChildSkeletonJointPtr &value)
{
    MFUnrecChildSkeletonJointPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecChildSkeletonJointPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Skeleton *>(this)->clearJoints();

    while(elemIt != elemEnd)
    {
        this->pushToJoints(*elemIt);

        ++elemIt;
    }
}

void SkeletonBase::removeFromJoints(UInt32 uiIndex)
{
    if(uiIndex < _mfJoints.size())
    {
        editMField(JointsFieldMask, _mfJoints);

        _mfJoints.erase(uiIndex);
    }
}

void SkeletonBase::removeObjFromJoints(SkeletonJoint * const value)
{
    Int32 iElemIdx = _mfJoints.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(JointsFieldMask, _mfJoints);

        _mfJoints.erase(iElemIdx);
    }
}
void SkeletonBase::clearJoints(void)
{
    editMField(JointsFieldMask, _mfJoints);


    _mfJoints.clear();
}

void SkeletonBase::pushToMeshes(Geometry * const value)
{
    editMField(MeshesFieldMask, _mfMeshes);

    _mfMeshes.push_back(value);
}

void SkeletonBase::assignMeshes   (const MFUnrecGeometryPtr &value)
{
    MFUnrecGeometryPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecGeometryPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<Skeleton *>(this)->clearMeshes();

    while(elemIt != elemEnd)
    {
        this->pushToMeshes(*elemIt);

        ++elemIt;
    }
}

void SkeletonBase::removeFromMeshes(UInt32 uiIndex)
{
    if(uiIndex < _mfMeshes.size())
    {
        editMField(MeshesFieldMask, _mfMeshes);

        _mfMeshes.erase(uiIndex);
    }
}

void SkeletonBase::removeObjFromMeshes(Geometry * const value)
{
    Int32 iElemIdx = _mfMeshes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(MeshesFieldMask, _mfMeshes);

        _mfMeshes.erase(iElemIdx);
    }
}
void SkeletonBase::clearMeshes(void)
{
    editMField(MeshesFieldMask, _mfMeshes);


    _mfMeshes.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 SkeletonBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (JointsFieldMask & whichField))
    {
        returnValue += _mfJoints.getBinSize();
    }
    if(FieldBits::NoField != (JointMatricesFieldMask & whichField))
    {
        returnValue += _mfJointMatrices.getBinSize();
    }
    if(FieldBits::NoField != (MeshesFieldMask & whichField))
    {
        returnValue += _mfMeshes.getBinSize();
    }
    if(FieldBits::NoField != (ShaderDataFieldMask & whichField))
    {
        returnValue += _sfShaderData.getBinSize();
    }
    if(FieldBits::NoField != (ShaderCodeFieldMask & whichField))
    {
        returnValue += _sfShaderCode.getBinSize();
    }

    return returnValue;
}

void SkeletonBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (JointsFieldMask & whichField))
    {
        _mfJoints.copyToBin(pMem);
    }
    if(FieldBits::NoField != (JointMatricesFieldMask & whichField))
    {
        _mfJointMatrices.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MeshesFieldMask & whichField))
    {
        _mfMeshes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderDataFieldMask & whichField))
    {
        _sfShaderData.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCodeFieldMask & whichField))
    {
        _sfShaderCode.copyToBin(pMem);
    }
}

void SkeletonBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (JointsFieldMask & whichField))
    {
        _mfJoints.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (JointMatricesFieldMask & whichField))
    {
        _mfJointMatrices.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MeshesFieldMask & whichField))
    {
        _mfMeshes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderDataFieldMask & whichField))
    {
        _sfShaderData.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShaderCodeFieldMask & whichField))
    {
        _sfShaderCode.copyFromBin(pMem);
    }
}

//! create a new instance of the class
SkeletonTransitPtr SkeletonBase::createLocal(BitVector bFlags)
{
    SkeletonTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<Skeleton>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
SkeletonTransitPtr SkeletonBase::createDependent(BitVector bFlags)
{
    SkeletonTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<Skeleton>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
SkeletonTransitPtr SkeletonBase::create(void)
{
    SkeletonTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<Skeleton>(tmpPtr);
    }

    return fc;
}

Skeleton *SkeletonBase::createEmptyLocal(BitVector bFlags)
{
    Skeleton *returnValue;

    newPtr<Skeleton>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
Skeleton *SkeletonBase::createEmpty(void)
{
    Skeleton *returnValue;

    newPtr<Skeleton>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr SkeletonBase::shallowCopyLocal(
    BitVector bFlags) const
{
    Skeleton *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Skeleton *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr SkeletonBase::shallowCopyDependent(
    BitVector bFlags) const
{
    Skeleton *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const Skeleton *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr SkeletonBase::shallowCopy(void) const
{
    Skeleton *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const Skeleton *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

SkeletonBase::SkeletonBase(void) :
    Inherited(),
    _mfJoints                 (this,
                          JointsFieldId,
                          SkeletonJoint::SkeletonFieldId),
    _mfJointMatrices          (),
    _mfMeshes                 (),
    _sfShaderData             (NULL),
    _sfShaderCode             (NULL)
{
}

SkeletonBase::SkeletonBase(const SkeletonBase &source) :
    Inherited(source),
    _mfJoints                 (this,
                          JointsFieldId,
                          SkeletonJoint::SkeletonFieldId),
    _mfJointMatrices          (source._mfJointMatrices          ),
    _mfMeshes                 (),
    _sfShaderData             (NULL),
    _sfShaderCode             (NULL)
{
}


/*-------------------------- destructors ----------------------------------*/

SkeletonBase::~SkeletonBase(void)
{
}

/*-------------------------------------------------------------------------*/
/* Child linking                                                           */

bool SkeletonBase::unlinkChild(
    FieldContainer * const pChild,
    UInt16           const childFieldId)
{
    if(childFieldId == JointsFieldId)
    {
        SkeletonJoint * pTypedChild =
            dynamic_cast<SkeletonJoint *>(pChild);

        if(pTypedChild != NULL)
        {
            Int32 iChildIdx = _mfJoints.findIndex(pTypedChild);

            if(iChildIdx != -1)
            {
                editMField(JointsFieldMask, _mfJoints);

                _mfJoints.erase(iChildIdx);

                return true;
            }

            FWARNING(("SkeletonBase::unlinkParent: Child <-> "
                      "Parent link inconsistent.\n"));

            return false;
        }

        return false;
    }


    return Inherited::unlinkChild(pChild, childFieldId);
}

void SkeletonBase::onCreate(const Skeleton *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        Skeleton *pThis = static_cast<Skeleton *>(this);

        MFUnrecChildSkeletonJointPtr::const_iterator JointsIt  =
            source->_mfJoints.begin();
        MFUnrecChildSkeletonJointPtr::const_iterator JointsEnd =
            source->_mfJoints.end  ();

        while(JointsIt != JointsEnd)
        {
            pThis->pushToJoints(*JointsIt);

            ++JointsIt;
        }

        MFUnrecGeometryPtr::const_iterator MeshesIt  =
            source->_mfMeshes.begin();
        MFUnrecGeometryPtr::const_iterator MeshesEnd =
            source->_mfMeshes.end  ();

        while(MeshesIt != MeshesEnd)
        {
            pThis->pushToMeshes(*MeshesIt);

            ++MeshesIt;
        }

        pThis->setShaderData(source->getShaderData());

        pThis->setShaderCode(source->getShaderCode());
    }
}

GetFieldHandlePtr SkeletonBase::getHandleJoints          (void) const
{
    MFUnrecChildSkeletonJointPtr::GetHandlePtr returnValue(
        new  MFUnrecChildSkeletonJointPtr::GetHandle(
             &_mfJoints,
             this->getType().getFieldDesc(JointsFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleJoints         (void)
{
    MFUnrecChildSkeletonJointPtr::EditHandlePtr returnValue(
        new  MFUnrecChildSkeletonJointPtr::EditHandle(
             &_mfJoints,
             this->getType().getFieldDesc(JointsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Skeleton::pushToJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Skeleton::removeFromJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Skeleton::removeObjFromJoints,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Skeleton::clearJoints,
                    static_cast<Skeleton *>(this)));

    editMField(JointsFieldMask, _mfJoints);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleJointMatrices   (void) const
{
    MFMatrix::GetHandlePtr returnValue(
        new  MFMatrix::GetHandle(
             &_mfJointMatrices,
             this->getType().getFieldDesc(JointMatricesFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleJointMatrices  (void)
{
    MFMatrix::EditHandlePtr returnValue(
        new  MFMatrix::EditHandle(
             &_mfJointMatrices,
             this->getType().getFieldDesc(JointMatricesFieldId),
             this));


    editMField(JointMatricesFieldMask, _mfJointMatrices);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleMeshes          (void) const
{
    MFUnrecGeometryPtr::GetHandlePtr returnValue(
        new  MFUnrecGeometryPtr::GetHandle(
             &_mfMeshes,
             this->getType().getFieldDesc(MeshesFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleMeshes         (void)
{
    MFUnrecGeometryPtr::EditHandlePtr returnValue(
        new  MFUnrecGeometryPtr::EditHandle(
             &_mfMeshes,
             this->getType().getFieldDesc(MeshesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&Skeleton::pushToMeshes,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&Skeleton::removeFromMeshes,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&Skeleton::removeObjFromMeshes,
                    static_cast<Skeleton *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&Skeleton::clearMeshes,
                    static_cast<Skeleton *>(this)));

    editMField(MeshesFieldMask, _mfMeshes);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleShaderData      (void) const
{
    SFUnrecShaderProgramVariableChunkPtr::GetHandlePtr returnValue(
        new  SFUnrecShaderProgramVariableChunkPtr::GetHandle(
             &_sfShaderData,
             this->getType().getFieldDesc(ShaderDataFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleShaderData     (void)
{
    SFUnrecShaderProgramVariableChunkPtr::EditHandlePtr returnValue(
        new  SFUnrecShaderProgramVariableChunkPtr::EditHandle(
             &_sfShaderData,
             this->getType().getFieldDesc(ShaderDataFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Skeleton::setShaderData,
                    static_cast<Skeleton *>(this), _1));

    editSField(ShaderDataFieldMask);

    return returnValue;
}

GetFieldHandlePtr SkeletonBase::getHandleShaderCode      (void) const
{
    SFUnrecShaderProgramChunkPtr::GetHandlePtr returnValue(
        new  SFUnrecShaderProgramChunkPtr::GetHandle(
             &_sfShaderCode,
             this->getType().getFieldDesc(ShaderCodeFieldId),
             const_cast<SkeletonBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SkeletonBase::editHandleShaderCode     (void)
{
    SFUnrecShaderProgramChunkPtr::EditHandlePtr returnValue(
        new  SFUnrecShaderProgramChunkPtr::EditHandle(
             &_sfShaderCode,
             this->getType().getFieldDesc(ShaderCodeFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&Skeleton::setShaderCode,
                    static_cast<Skeleton *>(this), _1));

    editSField(ShaderCodeFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void SkeletonBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    Skeleton *pThis = static_cast<Skeleton *>(this);

    pThis->execSync(static_cast<Skeleton *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *SkeletonBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    Skeleton *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const Skeleton *>(pRefAspect),
                  dynamic_cast<const Skeleton *>(this));

    return returnValue;
}
#endif

void SkeletonBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<Skeleton *>(this)->clearJoints();

    static_cast<Skeleton *>(this)->clearMeshes();

    static_cast<Skeleton *>(this)->setShaderData(NULL);

    static_cast<Skeleton *>(this)->setShaderCode(NULL);

#ifdef OSG_MT_CPTR_ASPECT
    AspectOffsetStore oOffsets;

    _pAspectStore->fillOffsetArray(oOffsets, this);
#endif

#ifdef OSG_MT_CPTR_ASPECT
    _mfJointMatrices.terminateShare(Thread::getCurrentAspect(),
                                      oOffsets);
#endif
}


OSG_END_NAMESPACE
