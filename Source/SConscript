#!python
import os, os.path
pj = os.path.join
from LibraryUtils import *

Import('*')

common_lib_env = build_env.Copy()
common_lib_env.Append(CPPDEFINES=["OSG_BUILD_DLL"])

if not verbose_build:
   print "Setting up build for libraries: ",
   
for (lib_name, library) in lib_map.iteritems():
   if verbose_build:
      print "Library: ", lib_name, "  tests:", library.test_files, "  unittests:", library.unittest_files
   else:
      print "%s"%lib_name,
   
   # ---- Setup and Build library --- #
   lib_env = common_lib_env.Copy()

   # XXX: Apply custom options
   #
   # Add the define needed for declspec to know what library we are building
   compile_define = "OSG_COMPILE%sLIB"%lib_name[3:].upper()
   lib_env.Append(CPPDEFINES=[compile_define])
    
   if "shared" in combo["libtype"]:
      shared_lib = lib_env.SharedLibrary(lib_name + shared_lib_suffix, library.source_files,
                         LIBS=[l+shared_lib_suffix for l in library.osg_dep_libs] + library.libs, 
                         LIBPATH=inst_paths['lib_inst_combo'])
      shared_lib_inst = lib_env.Install(inst_paths['lib_inst_combo'], shared_lib)
      
      # If default combo type, then make links from lib dir
      if default_combo_type == combo["type"] and (GetPlatform() != "win32"):
         lib_env.Install(inst_paths["lib"], shared_lib_inst)      
      
   #if "static" in combo["libtype"]:
   #   static_lib = lib_env.StaticLibrary(lib_name + static_lib_suffix, library.source_files)
   #   lib_env.Install(inst_paths['lib'], static_lib)
   
   # Install headers (but only do it once during variant_pass 0 )
   if variant_pass == 0:      
      lib_env.Install(pj(inst_paths["include"],"OpenSG"), library.header_files)
   
   # ---- Build Tests ---- #   
   # Verify we have all the deps for the tests
   #   todo: How do we verify the "other test libs"
   have_test_deps = True
   for n in library.osg_test_libs:
      if not lib_map.has_key(n):
         have_test_deps = False
         print "   missing test dep library:", n
   
   if have_test_deps:
      # default settings to pass to config info   
      default_lib_settings = LibraryInfo()
      default_lib_settings.libpath.insert(0, inst_paths["lib_inst_combo"]) 
      default_lib_settings.cpppath.insert(0, inst_paths["include"])
      config_info = ConfigInfoAdapter(library.osg_test_libs, lib_map, default_lib_settings)
   
      test_env = build_env.Copy()
      test_env.Append(CPPPATH=library.test_cpppath + config_info.getIncPath(),
                      LIBPATH=library.test_libpath + config_info.getLibPath(),
                      LIBS=[lib_name] + config_info.getLibs() + library.other_test_libs)
   
      # - Build them all in the local 'test' subdir
      for s in library.test_files:
         test_env.Program(target= pj("..","test",os.path.splitext(os.path.basename(s))[0]),
                          source=s)
   
      # ---- Build Unit Tests ---- #   
      if len(library.unittest_files) > 0:
         unittest_env = test_env.Copy()
         unittest_env.Append(CPPPATH=unittest_inc,
                             LIBPATH=unittest_libpath,
                             LIBS=unittest_lib)

         # - Build them all in the local 'unittest' subdir
         unittest_objs = []
         for s in library.unittest_files:
            t=pj("..","unittest",os.path.splitext(os.path.basename(s))[0])
            unittest_objs += unittest_env.Object(target=t, source=s)

         # Build the unit test runner
         t=pj("..","unittest",lib_name + "Runner")
         unittest_objs += unittest_env.Object(target=t, source=unittest_runner)
         runner = unittest_env.Program(target=pj("..","unittest","run" + lib_name), source=unittest_objs)


         # Run the Test once the program is built
         def runTest(target, source, env):
            print "Running ", os.path.basename(str(target[0]))
            os.system(str(target[0]))

         AddPostAction(runner, runTest)

      
   # Done   
if not verbose_build:
   print ""
